class Bucket<T, U> {
    key: T
    value: U
    is_empty: bool
    constructor(this){
        this.is_empty = true
    }
    set(this, key: T, value: U){
        this.is_empty = false
        this.key = key
        this.value = value
    }
}
class Map<T, U> {
    private buckets: Bucket<T, U>*
    private length: int
    private size: int
    constructor(this){
        let initial_capacity = 256
        this.buckets = new Bucket<T, U>*(initial_capacity)
        for let i = 0; i < initial_capacity; i++ {
            this.buckets[i] = new Bucket<T, U>()
        }
        this.size = initial_capacity
        this.length = 0
    }
    private hash_fnc(this, key: T): int {
        let str = key as string
        let hash = 0
        for let i = 0; i < str.length; ++i {
            hash = (hash << 1) + (str.get_byte(i) as int)
        }
        return hash < 0 ? -hash : hash
    }
    private resize(this){
        let buckets = this.get_buckets()
        this.size *= 2
        this.length = 0
        this.buckets = this.buckets.resize(this.size)
        for let i = 0; i < this.size; i++{
            this.buckets[i] = new Bucket<T, U>()
        }
        for i = 0; i < buckets.length; i++ {
            this.set(buckets[i].key, buckets[i].value)
        }
    }
    public set(this, key: T, value: U){
        let ratio = this.length / (this.size as float)
        if (ratio > 0.75) this.resize()
        let hash = this.hash_fnc(key) % this.size
        while !this.buckets[hash].is_empty {
            if this.buckets[hash].key == key
                break
            hash = (hash + 1) % this.size
        } 
        this.length++
        this.buckets[hash].set(key, value)
    }
    public get(this, key: T): U {
        let hash = this.hash_fnc(key) % this.size
        while !this.buckets[hash].is_empty {
            if this.buckets[hash].key == key
                break
            else
                hash = (hash + 1) % this.size
        }
        if !this.buckets[hash].is_empty
            return this.buckets[hash].value
        return null
    }
    public get_buckets(this): Bucket<T, U>[] {
        let buckets: Bucket<T, U>[] = []
        for let i = 0; i < this.size; ++i {
            let current_bucket = this.buckets[i]
            if !current_bucket.is_empty {
                buckets << current_bucket
            }
        }
        return buckets  
    }
}