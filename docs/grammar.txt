

stmts: ln* stmt (newlines stmt)*

newlines: ln+

block: newlines (lbrace stmts rbrace | stmt)

stmt: import_stmt
      | const_declaration
      | interface_declaration
      | class_declaration
      | if_stmt
      | for_stmt
      | foreach_stmt
      | while_stmt
      | fnc_def_stmt
      | change_flow_stmt
      | expr

      
import_stmt: import (identifier_list from)? string

const_declaration: const identifier eq expr

class_declaration: class block

if_stmt: if expr block newlines (else (if_stmt | block)) *

for_stmt: for (expr semicolumn expr semicolumn expr) block 

foreach_stmt: foreach (identifier in expr) block

while_stmt: while expr block

fnc_def_stmt: fnc identifier lpar arg_list rpar arrow expr rpar column composite_type block

arg_list: (arg_item (comma arg_item)* (comma dot_dot_dot arg_item)?)?

arg_item: identifier ((column composite_type) 
                     | ((column composite_type)? eq expr))

change_flow_stmt: return expr?
                  | continue
                  | break

expr: bit_expr (("as" | "is") composite_type)?

bit_expr: comp_expr (("and" | "or" | xor | in | sl | sr) (comp_expr | assign_part))?

comp_expr: exclamation_mark comp_expr 
         | arith_expr (comp_op arith_expr)?

arith_expr: arith_expr1 (( plus | minus ) (arith_expr1 | assign_part))?

arith_expr1: unary_expr ((times | div | mod | exp ) (unary_expr | assign_part))?


unary_expr: (plus | minus | amp ) unary_expr
      | (plus_plus | minus_minus) unary_expr
      | unary_expr1

unary_expr1: expr_value_op  (plus_plus | minus_minus)?

expr_list: (expr (comma expr)*)?
expr_value_op: expr_value ((dot identifier) | (lbracket expr lbracket) | (lpar expr_list rpar))* assign_part?
expr_value:   number
            | string
            | identifier
            | rbracket expr lbracket
            | lpar expr (property_acess) rpar
            | new_kw composite_type lpar expr_list? rpar 

assign_part: (column composite_type)? eq expr

fnc_type: lpar (composite_type (comma composite_type)*)? lpar arrow composite_type

composite_type:  prim_type (lbracket expr rbracket)*
            |    prim_type times*
            |    fnc_type

prim_type:
    | "float"
    | "int"
    | "bool"
    | "void"
    | "byte"
    | identifier


## tokens
lpar: "("
rpar: ")"
lbracket: "["
rbracket: "]"
lbrace: "{"
rbrace: "}"
plus: "+"
minus: "-"
eq: "="
times: "*"
div: "/"
exp: "^"
column: ":"
mod: "%"
question_mark: "?"
exclamation_mark: "!"
identifier: ([a-zA-Z]|_)[A-Za-z | 0-9 | _]*
sl: "<<"
sr: ">>"
semicolumn: ";"
comma: ","
ln: "\n"
number: /[0-9]+([0-9]*)+(.?)+([0-9]*)/
string: /"(*?)"/
      | /'(*?)'/
plus_plus: "++"
minus_minus: "--"
dot: "."
amp: &
dot_dot: ".."
dot_dot_dot: "..."
xor: "xor"



## keywords 
if: "if"
else: "else"
for: "for"
while: "while"
fnc: "fnc"
import: "import"
foreach: "foreach"
in: "in"
let: "let"
const: "const"
class: "class"
new_kw: "new"
          

comp_op: ">"
       | "<"
       | "=="
       | ">="
       | "<="
       | "!="

bin_op: plus
      | minus
      | times
      | div
      | mod
      | exp

access: "pub"
      | "priv"



