fnc fflush(fd: int)
class FloRange {
    start: int
    end: int
    col: int
    line: int
    constructor(start: int, end: int, col: int, line: int){
        this.start = start
        this.end = end
        this.col = col
        this.line = line
    }
}
class Optional<T> {
    value: T
    has_value: bool
    construtor(){
        this.has_value = false
    }
    set_value(value: T){
        this.has_value = true
        this.value = value
    }
}
class Bucket<T, U> {
    key: T
    value: U
    is_empty: bool
    constructor(){
        this.is_empty = true
    }
    set(key: T, value: U){
        this.is_empty = false
        this.key = key
        this.value = value
    }
    __as_string__(): string {
        return this.key + ":" + this.value
    }
}
class Map<T, U> {
    buckets: Bucket<T, U>*
    length: int
    size: int
    constructor(){
        initial_capacity = 256
        this.buckets = new Bucket<T, U>[initial_capacity]
        for i = 0; i < initial_capacity; i++ {
            this.buckets[i] = new Bucket<T, U>()
        }
        this.size = initial_capacity
        this.length = 0
    }
    hash_fnc(key: T): int {
        str = key as string
        hash = 5381
        for i = 0; i < str; ++i {
            hash = ((hash << 5) + hash) + (str.get_byte(i) as int)
        }
        return hash
    }
    resize(){
        original_size = this.size
        this.size *= 2
        this.buckets = this.buckets.resize(this.size)
        for i = original_size; i < this.size; i++ {
            this.buckets[i] = new Bucket<T, U>()
        }
    }
    set(key: T, value: U){
        hash = this.hash_fnc(key) % this.size
        if (this.size <= this.length) this.resize()

        while !this.buckets[hash].is_empty {
            if this.buckets[hash].key != key
                break
            hash++
        } 
        this.length++
        this.buckets[hash].set(key, value)
    }
    get(key: T): Optional<U> {
        hash = this.hash_fnc(key) % this.size
        result = new Optional<U>
        while !this.buckets[hash].is_empty {
            if this.buckets[hash].key == key
                break
            else
                hash++
        }
        if !this.buckets[hash].is_empty
            if this.buckets[hash].key == key
                result.set_value(this.buckets[hash].value)
        return result
    }
}
fnc merge_range(r1: FloRange, r2: FloRange): FloRange {
    return new FloRange(r1.start, r2.end, r1.col, r2.line)
}
fnc color(color: string): string {
    if color == "red"
        return "\033[1;31m"
    return "\033[0m"
}