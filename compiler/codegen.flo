import "llvm/bindings"
class GeneratedModule {
    llvm_mod: LLVMModuleRef
    constructor(llvm_mod: LLVMModuleRef){
        this.llvm_mod = llvm_mod
        LLVMLinkInMCJIT()
        FloLLVMInitializeNativeTarget()
        FloLLVMInitializeNativeAsmPrinter()
        FloLLVMInitializeNativeAsmParser()
    }
    exec(){
        zero: i8 = 0    
        NULL = &zero
        errors= &zero
        LLVMVerifyModule(this.llvm_mod, /*LLVMAbortProcessAction*/ 0, &errors)
        LLVMDisposeMessage(errors)

        engine: LLVMExecutionEngineRef = new i8[64] as LLVMExecutionEngineRef
        if (LLVMCreateExecutionEngineForModule(&engine, this.llvm_mod, &errors) != 0) {
            println("failed to create execution engine")
            exit()
        }
        if (zero) {
            println("error:", string_from_cstring(errors))
            LLVMDisposeMessage(errors)
            exit()
        }
        functionPtr = LLVMGetFunctionAddress(engine, "main".to_cstring())
        main_fnc = functionPtr as () => int
        println(main_fnc())
    }
    write_object(fn: string){
        zero: i8 = 0  
        errors = &zero
        triple = LLVMGetDefaultTargetTriple()
        target = LLVMGetFirstTarget()
        LLVMGetTargetFromTriple(triple, &target, &errors)
        CPU = "generic".to_cstring()
        Features = "".to_cstring()
        tm = LLVMCreateTargetMachine(target, triple, CPU, LLVMGetHostCPUFeatures(), 0, 0, 0)
        LLVMSetDataLayout(this.llvm_mod, LLVMCreateTargetDataLayout(tm))
        LLVMSetTarget(this.llvm_mod, triple)
        LLVMTargetMachineEmitToFile(tm, this.llvm_mod, fn.to_cstring(), 1, &errors)
    }
    print(){
        LLVMDumpModule(this.llvm_mod)
    }
}
class CodeGen {
    modules: Array<LLVMModuleRef>
    module: LLVMModuleRef
    codegenProgram(program: Program): GeneratedModule{
        this.modules = []
        for i = 0; i < program.modules.length; ++i {
            this.modules << this.codegenModule(program.modules[i])
        }
        this.linkModules()
        return new GeneratedModule(this.modules[0])
    }
    linkModules(){
        for i = 1; i < this.modules.length; ++i {
            LLVMLinkModules2(this.modules[0], this.modules[i])
        }
    }
    codegenModule(module: Module): LLVMModuleRef {
        this.module = LLVMModuleCreateWithName(module.name.to_cstring())
        for i = 0; i < module.functions.length; ++i {
            this.codegenFunction(module.functions[i])
        }
        return this.module
    }
    codegenType(tt: Type): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidType()
        if tt.kind == TypeKind.BOOL
            return LLVMInt1Type()
        if tt.kind == TypeKind.I4
            return LLVMIntType(4)
        if tt.kind == TypeKind.I8
            return LLVMInt8Type()
        if tt.kind == TypeKind.I16
            return LLVMInt16Type()
        if tt.kind == TypeKind.I32
            return LLVMInt32Type()
        if tt.kind == TypeKind.I64 or tt.kind == TypeKind.INT
            return LLVMInt64Type()
        if tt.kind == TypeKind.I128
            return LLVMInt128Type()
        if tt.kind == TypeKind.F16 
            return LLVMHalfType()
        if tt.kind == TypeKind.F32
            return LLVMFloatType()
        if tt.kind == TypeKind.F64 or tt.kind == TypeKind.FLOAT
            return LLVMDoubleType()
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegenType((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            arr_ty = tt as ArrayType
            arr_len = arr_ty.length
            element_type = this.codegenType(arr_ty.element_type)
            if arr_len.is_constant
                return LLVMArrayType(element_type, (arr_len as IntExpression).value)
            return LLVMPointerType(element_type)
        }
        if tt.kind == TypeKind.FNC {
            param_types: Array<LLVMTypeRef> = []
            func_ty = tt as FunctionType
            for i = 0; i < func_ty.arg_types.length; ++i {
                param_types << this.codegenType(func_ty.arg_types[i])
                //TODO: add a new context and put the argnames to context
            }
            ret_type = this.codegenType(func_ty.return_type)
            return  LLVMFunctionType(ret_type, param_types.buffer, param_types.length, false)
        }
        
        //if tt.kind == TypeKind.ENUM
            return LLVMInt32Type()
            // STRING
            // OBJECT
            // GENERIC_TEMPLATE
            // RESOLVED_GENERIC

    }
    codegenReturnStmt(builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value.has_value 
            LLVMBuildRet(builder, this.codegenExpression(builder, return_stmt.return_value.value))
        else
            LLVMBuildRetVoid(builder)
    }
    codegenInt(intExp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegenType(intExp.value_type), intExp.value, false)
    }
    codegenFloat(floatExp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegenType(floatExp.value_type), floatExp.value)
    }
    codegenBinExp(builder: LLVMBuilderRef, binExp: BinaryExpression): LLVMValueRef {
        lhs = this.codegenExpression(builder, binExp.lhs)
        rhs = this.codegenExpression(builder, binExp.rhs)
        op = binExp.op
        name = "".to_cstring()
        if op == BinaryOp.ADD and binExp.rhs.value_type.kind == TypeKind.INT {
            if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                return LLVMConstAdd(lhs, rhs)
            } else {
                return LLVMBuildAdd(builder, lhs, rhs, name)
            }
        } else if op == BinaryOp.ADD and binExp.rhs.value_type.kind == TypeKind.FLOAT {
            if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                return LLVMConstFAdd(lhs, rhs)
            } else {
                return LLVMBuildFAdd(builder, lhs, rhs, name)
            }
        }
        return lhs
    }
    codegenExpression(builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        if expression.expr_kind == ExpressionKind.INT
            return this.codegenInt(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegenFloat(expression as FloatExpression)
        // if expression.expr_kind == ExpressionKind.STR
        //     return this.codegenChar(builder, expression as StringExpression)
        // if expression.expr_kind == ExpressionKind.VAR 
        //     return this.codegenBinExp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegenBinExp(builder, expression as BinaryExpression)
        // if expression.expr_kind == ExpressionKind.UNARY
        //     return this.codegenUnaryExp(builder, expression as UnaryExpression)
        // if expression.expr_kind == ExpressionKind.CALL
        //     return this.codegenCallExp(builder, expression as CallExpression)
        // if expression.expr_kind == ExpressionKind.MEMBER
        //     return this.codegenMemberExp(builder, expression as MemberExpression)
        // if expression.expr_kind == ExpressionKind.INDEX
        //     return this.codegenIndexExp(builder, expression as IndexExpression)
        // if expression.expr_kind == ExpressionKind.NEW
        //     return this.codegenNewExp(builder, expression as NewExpression)
        // if expression.expr_kind == ExpressionKind.TYPEBOUND
        //     return this.codegenCastExp(builder, expression as CastExpression)
        // if expression.expr_kind == ExpressionKind.ARRAY
        //     return this.codegenArrayExp(builder, expression as ArrayExpression)
        return LLVMConstInt(LLVMInt32Type(), 0, false)
    }
    // codegenIfStmt(builder: LLVMBuilderRef, if_statmt: IfStatement){

    // }
    // codegenForStmt(builder: LLVMBuilderRef, for_stmt: ForStatement){

    // }
    // codegenWhileStmt(builder: LLVMBuilderRef, while_stmt: WhileStatement){

    // }
    codegenStatement(builder: LLVMBuilderRef, statement: Statement){
        // if statement.kind == StatementKind.IF
        //     this.codegenIfStmt(builder, statement as IfStatement)
        // if statement.kind == StatementKind.FOR
        //     this.codegenForStmt(builder, statement as ForStatement)
        // if statement.kind == StatementKind.WHILE
        //     this.codegenWhileStmt(builder, statement as WhileStatement)
        // if statement.kind == StatementKind.CONTINUE
        // if statement.kind == StatementKind.BREAK
        if statement.kind == StatementKind.RETURN
            this.codegenReturnStmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegenExpression(builder, statement as Expression)
    }
    codegenBlock(builder: LLVMBuilderRef, block: Block){
        for i = 0; i < block.statements.length; ++i {
            this.codegenStatement(builder, block.statements[i])
        }
    }
    codegenFunction(func: Function){
        llvm_fnc: LLVMValueRef = LLVMAddFunction(this.module, func.name.to_cstring(), this.codegenType(func.value_type))
        entry_block: LLVMBasicBlockRef  = LLVMAppendBasicBlock(llvm_fnc, (func.name + ".entry").to_cstring())
        func_builder: LLVMBuilderRef = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, entry_block)
        this.codegenBlock(func_builder, func.block)
    }
}