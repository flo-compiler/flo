import 'llvm/bindings'
class CodeGen {
    modules: Array<LLVMModuleRef>
    module: LLVMModuleRef
    codegenProgram(program: Program){
        this.modules = []
        for i = 0; i < program.modules.length; ++i {
            this.modules << this.codegenModule(program.modules[i])
        }
    }
    codegenModule(module: Module): LLVMModuleRef {
        this.module = LLVMModuleCreateWithName(module.name.to_cstring())
        return this.module
    }
    codegenType(tt: Type): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidType()
        if tt.kind == TypeKind.BOOL
            return LLVMInt1Type()
        if tt.kind == TypeKind.I4
            return LLVMIntType(4)
        if tt.kind == TypeKind.I8
            return LLVMInt8Type()
        if tt.kind == TypeKind.I16
            return LLVMInt16Type()
        if tt.kind == TypeKind.I32
            return LLVMInt32Type()
        if tt.kind == TypeKind.I64
            return LLVMInt64Type()
        if tt.kind == TypeKind.I128
            return LLVMInt128Type()
        if tt.kind == TypeKind.F16 
            return LLVMHalfType()
        if tt.kind == TypeKind.F32
            return LLVMFloatType()
        if tt.kind == TypeKind.F64
            return LLVMDoubleType()
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegenType((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            arr_ty = tt as ArrayType
            arr_len = arr_ty.length
            element_type = this.codegenType(arr_ty.element_type)
            if arr_len.is_constant
                return LLVMArrayType(element_type, (arr_len as ConstantInt).value)
            return LLVMPointerType(element_type)
        }
        if tt.kind == TypeKind.ENUM
            return LLVMInt32Type()
        if tt.kind == TypeKind.FNC {
            param_types: Array<LLVMTypeRef> = []
            func_ty = tt as FunctionType
            for i = 0; i < func_ty.args.length; ++i {
                param_types << this.codegenType(func_ty.args[i].kind)
                //TODO: add a new context and put the argnames to context
            }
            ret_type = this.codegenType(func_ty.return_type)
            return  LLVMFunctionType(ret_type, param_types.buffer, param_types.length, false)
        }
            // STRING
            // OBJECT
            // GENERIC_TEMPLATE
            // RESOLVED_GENERIC

    }
    codegenReturnStmt(builder: LLVMBasicBlockRef, return_stmt: ReturnStatement){
        if return_stmt.has_value
            LLVMBuildRet(builder, return_stmt.value)
        else
            LLVMBuildRetVoid(builder)
    }
    codegenExpression(builder: LLVMBasicBlockRef, exp: Expression): LLVMValueRef {
        if expression.kind == ExpressionKind.INT
            return this.codegenInt(builder, exp as IntExpression)
        if expression.kind == ExpressionKind.FLOAT
            return this.codegenFloat(builder, exp as FloatExpression)
        if expression.kind == ExpressionKind.CHAR
            return this.codegenChar(builder, exp as CharExpression)
        if expression.kind == ExpressionKind.STR
            return this.codegenChar(builder, exp as StringExpression)
        if expression.kind == ExpressionKind.VAR 
            return this.codegenBinExp(builder, exp as VarAccessExpression)
        if expression.kind == ExpressionKind.BIN 
            return this.codegenBinExp(builder, exp as BinaryExpression)
        if expression.kind == ExpressionKind.UNARY
            return this.codegenUnaryExp(builder, exp as UnaryExpression)
        if expression.kind == ExpressionKind.CALL
            return this.codegenCallExp(builder, exp as CallExpression)
        if expression.kind == ExpressionKind.MEMBER
            return this.codegenMemberExp(builder, exp as MemberExpression)
        if expression.kind == ExpressionKind.INDEX
            return this.codegenIndexExp(builder, exp as IndexExpression)
        if expression.kind == ExpressionKind.NEW
            return this.codegenNewExp(builder, exp as NewExpression)
        if expression.kind == ExpressionKind.TYPEBOUND
            return this.codegenCastExp(builder, exp as CastExpression)
        if expression.kind == ExpressionKind.ARRAY
            return this.codegenArrayExp(builder, exp as ArrayExpression)
    }
    codegenIfStmt(builder: LLVMBasicBlockRef, if_statmt: IfStatement){

    }
    codegenForStmt(builder: LLVMBasicBlockRef, for_stmt: ForStatement){

    }
    codegenWhileStmt(builder: LLVMBasicBlockRef, while_stmt: WhileStatement){

    }
    codegenStatement(builder: LLVMBuilderRef, statement: Statement){
        if statement.kind == StatementKind.IF
            this.codegenIfStmt(builder, statement as IfStatement)
        if statement.kind == StatementKind.FOR
            this.codegenForStmt(builder, statement as ForStatement)
        if statement.kind == StatementKind.WHILE
            this.codegenWhileStmt(builder, statement as WhileStatement)
        if statement.kind == StatementKind.CONTINUE
        if statement.kind == StatementKind.BREAK
        if statement.kind == StatementKind.RETURN
            this.codegenReturnStmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegenExpression(builder, statement as Expression)
    }
    codegenBlock(builder: LLVMBuilderRef, block: Block){
        for i = 0; i < block.statements.length; ++i {
            this.codegenStatement(builder, block.statements[i])
        }
    }
    codegenFunction(func: Function): {
        func = LLVMAddFunction(this.module, func.name.to_cstring(), this.codegenType(func.value_type))
        entry_block: LLVMBasicBlockRef  = LLVMAppendBasicBlock(func, (func.name + ".entry").to_cstring())
        func_builder: LLVMBuilderRef = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, entry_block)
        this.codegenBlock(fnc_builder, func.block)
    }
}