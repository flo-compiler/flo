import "llvm/bindings"
class GeneratedModule {
    llvm_mod: LLVMModuleRef
    errors: i8*
    constructor(llvm_mod: LLVMModuleRef){
        this.llvm_mod = llvm_mod
        zero: i8 = 0
        this.errors = &zero
        LLVMLinkInMCJIT()
        FloLLVMInitializeNativeTarget()
        FloLLVMInitializeNativeAsmPrinter()
        FloLLVMInitializeNativeAsmParser()
    }
    check_errors(){
        if (this.errors[0]) {
            println("error:", string_from_cstring(this.errors))
            LLVMDisposeMessage(this.errors)
            exit()
        }
    }
    exec(){
        LLVMVerifyModule(this.llvm_mod, /*LLVMAbortProcessAction*/ 0, &this.errors)
        this.check_errors()

        engine: LLVMExecutionEngineRef = new i8[64] as LLVMExecutionEngineRef
        if (LLVMCreateExecutionEngineForModule(&engine, this.llvm_mod, &this.errors) != 0) {
            println("failed to create execution engine")
        }
        this.check_errors()
        functionPtr = LLVMGetFunctionAddress(engine, "main".to_cstring())
        main_fnc = functionPtr as () => float
        println(main_fnc())
    }
    create_target_machine(): LLVMTargetMachineRef {
        triple = LLVMGetDefaultTargetTriple()
        target = LLVMGetFirstTarget()
        if (LLVMGetTargetFromTriple(triple, &target, &this.errors) != 0) {
            println("failed to get target tripple")
        }
        this.check_errors()
        CPU = "generic".to_cstring()
        return LLVMCreateTargetMachine(target, triple, CPU, LLVMGetHostCPUFeatures(), 0, 0, 0)
    }
    write_object(fn: string){
        tm = this.create_target_machine()
        LLVMSetDataLayout(this.llvm_mod, LLVMCreateTargetDataLayout(tm))
        LLVMSetTarget(this.llvm_mod, LLVMGetTargetMachineTriple(tm))
        if (LLVMTargetMachineEmitToFile(tm, this.llvm_mod, fn.to_cstring(), 1, &this.errors) != 0) {
            println("target machine failed to emit object code")
        }
        this.check_errors()
        LLVMDisposeTargetMachine(tm)
    }
    print(){
        LLVMDumpModule(this.llvm_mod)
    }
    destroy(){
        LLVMDisposeModule(this.llvm_mod)
    }
}
class IntrinsicResult {
    call: LLVMValueRef
    fnc_type: LLVMTypeRef
}
fnc get_intrinsic(mod: LLVMModuleRef, name: string, params: Array<LLVMTypeRef>): IntrinsicResult {
    result = new IntrinsicResult()
    result.fnc_type = LLVMFunctionType(params[0], params.buffer, params.length, false)
    result.call = LLVMAddFunction(mod, name.to_cstring(), result.fnc_type)
    return result
}
fnc array_to_pointer(arr: Array<LLVMValueRef>): LLVMValueRef*{
    return arr.buffer
}
class CodeGen {
    modules: Array<LLVMModuleRef>
    module: LLVMModuleRef
    codegenProgram(program: Program): GeneratedModule{
        this.modules = []
        for i = 0; i < program.modules.length; ++i {
            this.modules << this.codegenModule(program.modules[i])
        }
        this.linkModules()
        return new GeneratedModule(this.modules[0])
    }
    linkModules(){
        for i = 1; i < this.modules.length; ++i {
            LLVMLinkModules2(this.modules[0], this.modules[i])
        }
    }
    codegenModule(module: Module): LLVMModuleRef {
        this.module = LLVMModuleCreateWithName(module.name.to_cstring())
        for i = 0; i < module.functions.length; ++i {
            this.codegenFunction(module.functions[i])
        }
        return this.module
    }
    codegenType(tt: Type): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidType()
        if tt.kind == TypeKind.BOOL
            return LLVMInt1Type()
        if tt.kind == TypeKind.I4
            return LLVMIntType(4)
        if tt.kind == TypeKind.I8
            return LLVMInt8Type()
        if tt.kind == TypeKind.I16
            return LLVMInt16Type()
        if tt.kind == TypeKind.I32
            return LLVMInt32Type()
        if tt.kind == TypeKind.I64 or tt.kind == TypeKind.INT
            return LLVMInt64Type()
        if tt.kind == TypeKind.I128
            return LLVMInt128Type()
        if tt.kind == TypeKind.F16 
            return LLVMHalfType()
        if tt.kind == TypeKind.F32
            return LLVMFloatType()
        if tt.kind == TypeKind.F64 or tt.kind == TypeKind.FLOAT
            return LLVMDoubleType()
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegenType((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            arr_ty = tt as ArrayType
            arr_len = arr_ty.length
            element_type = this.codegenType(arr_ty.element_type)
            if arr_len.is_constant
                return LLVMArrayType(element_type, (arr_len as IntExpression).value)
            return LLVMPointerType(element_type)
        }
        if tt.kind == TypeKind.FNC {
            param_types: Array<LLVMTypeRef> = []
            func_ty = tt as FunctionType
            for i = 0; i < func_ty.arg_types.length; ++i {
                param_types << this.codegenType(func_ty.arg_types[i])
                //TODO: add a new context and put the argnames to context
            }
            ret_type = this.codegenType(func_ty.return_type)
            return  LLVMFunctionType(ret_type, param_types.buffer, param_types.length, false)
        }
        
        //if tt.kind == TypeKind.ENUM
            return LLVMInt32Type()
            // STRING
            // OBJECT
            // GENERIC_TEMPLATE
            // RESOLVED_GENERIC

    }
    codegenReturnStmt(builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value.has_value 
            LLVMBuildRet(builder, this.codegenExpression(builder, return_stmt.return_value.value))
        else
            LLVMBuildRetVoid(builder)
    }
    codegenInt(intExp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegenType(intExp.value_type), intExp.value, true)
    }
    codegenFloat(floatExp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegenType(floatExp.value_type), floatExp.value)
    }
    codegenBinExp(builder: LLVMBuilderRef, binExp: BinaryExpression): LLVMValueRef {        
        op = binExp.op
        if binExp.lhs.value_type != binExp.rhs.value_type {
            if op == BinaryOp.EEQ
                return LLVMConstInt(LLVMInt1Type(), 0, false)
            else if op == BinaryOp.NEQ
                return LLVMConstInt(LLVMInt1Type(), 1, false)
        }
        lhs = this.codegenExpression(builder, binExp.lhs)
        rhs = this.codegenExpression(builder, binExp.rhs)
        rty = binExp.rhs.value_type
        llvmty = this.codegenType(rty)
        call = rhs
        name = "".to_cstring()
        pred = 0
        if is_numeric(rty) and op == BinaryOp.POW {
            tys: Array<LLVMTypeRef> = [llvmty, llvmty]
            args = [lhs, rhs]
            res = get_intrinsic(this.module, "llvm.pow."+dump_type(rty), tys)
            return LLVMBuildCall2(builder, res.fnc_type, res.call, &(args[0]), 2, name)
        }
        if is_int(rty) {
            if op == BinaryOp.ADD { 
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstAdd(lhs, rhs)
                } else {
                    return LLVMBuildAdd(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.SUB {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstSub(lhs, rhs)
                } else {
                    return LLVMBuildSub(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.MUL {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstMul(lhs, rhs)
                } else {
                    return LLVMBuildMul(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.DIV {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstSDiv(lhs, rhs)
                } else {
                    return LLVMBuildSDiv(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.MOD {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstSRem(lhs, rhs)
                } else {
                    return LLVMBuildSRem(builder, lhs, rhs, name)
                }
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + 38
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstICmp(pred, lhs, rhs)
                } else {
                    return LLVMBuildICmp(builder, pred, lhs, rhs, name)
                }
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = op - BinaryOp.EEQ + 32
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstICmp(pred, lhs, rhs)
                } else {
                    return LLVMBuildICmp(builder, pred, lhs, rhs, name)
                }
            } else if op == BinaryOp.SL {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstShl(lhs, rhs)
                } else {
                    return LLVMBuildShl(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.SR {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstAShr(lhs, rhs)
                } else {
                    return LLVMBuildAShr(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.OR {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstOr(lhs, rhs)
                } else {
                    return LLVMBuildOr(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.AND {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstAnd(lhs, rhs)
                } else {
                    return LLVMBuildAnd(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.XOR {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstXor(lhs, rhs)
                } else {
                    return LLVMBuildXor(builder, lhs, rhs, name)
                }
            }
        } else if is_float(rty) {
            if op == BinaryOp.ADD { 
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFAdd(lhs, rhs)
                } else {
                    return LLVMBuildFAdd(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.SUB {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFSub(lhs, rhs)
                } else {
                    return LLVMBuildFSub(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.MUL {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFMul(lhs, rhs)
                } else {
                    return LLVMBuildFMul(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.DIV {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFDiv(lhs, rhs)
                } else {
                    return LLVMBuildFDiv(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.MOD {
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFRem(lhs, rhs)
                } else {
                    return LLVMBuildFRem(builder, lhs, rhs, name)
                }
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + 2
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstFCmp(pred, lhs, rhs)
                } else {
                    return LLVMBuildFCmp(builder, pred, lhs, rhs, name)
                }
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = 1
                if op == BinaryOp.NEQ
                    pred = 6
                if LLVMIsConstant(rhs) and LLVMIsConstant(rhs) {
                    return LLVMConstICmp(pred, lhs, rhs)
                } else {
                    return LLVMBuildICmp(builder, pred, lhs, rhs, name)
                }
            }
        } else if is_bool(rty) {
            if op == BinaryOp.AND {
                if LLVMIsConstant(lhs) and LLVMIsConstant(rhs) {
                    return LLVMConstAnd(lhs, rhs)
                } else {
                    return LLVMBuildAnd(builder, lhs, rhs, name)
                }
            } else if op == BinaryOp.OR {
                if LLVMIsConstant(lhs) and LLVMIsConstant(rhs) {
                    return LLVMConstOr(lhs, rhs)
                } else {
                    return LLVMBuildOr(builder, lhs, rhs, name)
                }
            }
        }
        return lhs
    }
    codegenTypeExp(builder: LLVMBuilderRef, tyExp: TypeExpression): LLVMValueRef {
        name = "".to_cstring()
        exp = tyExp.expr
        bty = tyExp.bound_type
        val = this.codegenExpression(builder, exp)
        ty = this.codegenType(bty)
        if tyExp.ty_op == TypeExprOp.AS {
            if is_int(exp.value_type) and is_float(bty) {
                if LLVMIsConstant(val){
                    return LLVMConstSIToFP(val, ty)
                } else {
                    return LLVMBuildSIToFP(builder, val, ty, name)
                }
            } else if is_float(exp.value_type) and is_int(bty) {
                if LLVMIsConstant(val){
                    return LLVMConstFPToSI(val, ty)
                } else {
                    return LLVMBuildFPToSI(builder, val, ty, name)
                }
            } else if is_int(exp.value_type) and is_int(bty){
                if exp.value_type.kind > bty.kind {
                    if LLVMIsConstant(val){
                        return LLVMConstTrunc(val, ty)
                    } else {
                        return LLVMBuildTrunc(builder, val, ty, name)
                    }
                } else {
                    if LLVMIsConstant(val){
                        return LLVMConstZExt(val, ty)
                    } else {
                        return LLVMBuildTrunc(builder, val, ty,name)
                    }
                }
            } else if is_float(exp.value_type) and is_float(bty){
                if exp.value_type.kind > bty.kind {
                    if LLVMIsConstant(val){
                        return LLVMConstFPTrunc(val, ty)
                    } else {
                        return LLVMBuildFPTrunc(builder, val, ty, name)
                    }
                } else {
                    if LLVMIsConstant(val){
                        return LLVMConstFPExt(val, ty)
                    } else {
                        return LLVMBuildFPExt(builder, val, ty,name)
                    }
                }
            }
            if LLVMIsConstant(val)
                return LLVMConstBitCast(val, ty)
            return LLVMBuildBitCast(builder, val, ty, name)
            
        } 
        return val
    }
    codegenBool(boolExp: BooleanExpression): LLVMValueRef {
        val = boolExp.value
        return LLVMConstInt(LLVMInt1Type(), val, false)
    }
    codegenExpression(builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        if expression.expr_kind == ExpressionKind.BOOL
            return this.codegenBool(expression as BooleanExpression)
        if expression.expr_kind == ExpressionKind.INT
            return this.codegenInt(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegenFloat(expression as FloatExpression)
        // if expression.expr_kind == ExpressionKind.STR
        //     return this.codegenChar(builder, expression as StringExpression)
        // if expression.expr_kind == ExpressionKind.VAR 
        //     return this.codegenBinExp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegenBinExp(builder, expression as BinaryExpression)
        // if expression.expr_kind == ExpressionKind.UNARY
        //     return this.codegenUnaryExp(builder, expression as UnaryExpression)
        // if expression.expr_kind == ExpressionKind.CALL
        //     return this.codegenCallExp(builder, expression as CallExpression)
        // if expression.expr_kind == ExpressionKind.MEMBER
        //     return this.codegenMemberExp(builder, expression as MemberExpression)
        // if expression.expr_kind == ExpressionKind.INDEX
        //     return this.codegenIndexExp(builder, expression as IndexExpression)
        // if expression.expr_kind == ExpressionKind.NEW
        //     return this.codegenNewExp(builder, expression as NewExpression)
        if expression.expr_kind == ExpressionKind.TYPEBOUND {
             return this.codegenTypeExp(builder, expression as TypeExpression)
        }
        // if expression.expr_kind == ExpressionKind.ARRAY
        //     return this.codegenArrayExp(builder, expression as ArrayExpression)
        return LLVMConstInt(LLVMInt32Type(), 0, false)
    }
    // codegenIfStmt(builder: LLVMBuilderRef, if_statmt: IfStatement){

    // }
    // codegenForStmt(builder: LLVMBuilderRef, for_stmt: ForStatement){

    // }
    // codegenWhileStmt(builder: LLVMBuilderRef, while_stmt: WhileStatement){

    // }
    codegenStatement(builder: LLVMBuilderRef, statement: Statement){
        // if statement.kind == StatementKind.IF
        //     this.codegenIfStmt(builder, statement as IfStatement)
        // if statement.kind == StatementKind.FOR
        //     this.codegenForStmt(builder, statement as ForStatement)
        // if statement.kind == StatementKind.WHILE
        //     this.codegenWhileStmt(builder, statement as WhileStatement)
        // if statement.kind == StatementKind.CONTINUE
        // if statement.kind == StatementKind.BREAK
        if statement.kind == StatementKind.RETURN
            this.codegenReturnStmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegenExpression(builder, statement as Expression)
    }
    codegenBlock(builder: LLVMBuilderRef, block: Block){
        for i = 0; i < block.statements.length; ++i {
            this.codegenStatement(builder, block.statements[i])
        }
    }
    codegenFunction(func: Function){
        llvm_fnc: LLVMValueRef = LLVMAddFunction(this.module, func.name.to_cstring(), this.codegenType(func.value_type))
        entry_block: LLVMBasicBlockRef  = LLVMAppendBasicBlock(llvm_fnc, (func.name + ".entry").to_cstring())
        func_builder: LLVMBuilderRef = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, entry_block)
        this.codegenBlock(func_builder, func.block)
    }
}