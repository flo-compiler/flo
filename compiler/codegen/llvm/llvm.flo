import "bindings"
fnc main(argc: int, argv: i8**) {
    mod: LLVMModuleRef  = LLVMModuleCreateWithName("my_module".to_cstring())

    param_types: Array<LLVMTypeRef> = [LLVMInt32Type(), LLVMInt32Type()]
    ret_type: LLVMTypeRef  = LLVMFunctionType(LLVMInt32Type(), param_types.buffer, 2, 0)
    sum: LLVMValueRef  = LLVMAddFunction(mod, "sum".to_cstring(), ret_type)

    entry: LLVMBasicBlockRef  = LLVMAppendBasicBlock(sum, "entry".to_cstring())

    builder: LLVMBuilderRef  = LLVMCreateBuilder()
    LLVMPositionBuilderAtEnd(builder, entry)
    tmp: LLVMValueRef  = LLVMBuildAdd(builder, LLVMGetParam(sum, 0), LLVMGetParam(sum, 1), "tmp".to_cstring())
    LLVMBuildRet(builder, tmp)

    zero: i8 = 0
    LLVMVerifyModule(mod, LLVMAbortProcessAction, &error)
    LLVMDisposeMessage(error)

    engine: LLVMExecutionEngineRef
    error = &zero
    LLVMLinkInJIT()
    LLVMInitializeNativeTarget()
    if (LLVMCreateExecutionEngineForModule(&engine, mod, &error) != 0) {
        println("failed to create execution engine")
        abort()
    }
    if (error) {
        println("error:", error)
        LLVMDisposeMessage(error)
        exit(EXIT_FAILURE)
    }

    if (argc < 3) {
        println("usage:", argv[0], "x y")
        exit(EXIT_FAILURE)
    }
    x = argv[1] as i64
    y = argv[2] as i64

    args: Array<LLVMGenericValueRef> = [
        LLVMCreateGenericValueOfInt(LLVMInt32Type(), x, 0),
        LLVMCreateGenericValueOfInt(LLVMInt32Type(), y, 0)
    ]
    LLVMGenericValueRef res = LLVMRunFunction(engine, sum, 2, args.buffer)
    println(LLVMGenericValueToInt(res, 0) as int)

    // Write out bitcode to file
    if (LLVMWriteBitcodeToFile(mod, "sum.bc") != 0) {
        print("error writing bitcode to file, skipping\n")
    }

    LLVMDisposeBuilder(builder)
    LLVMDisposeExecutionEngine(engine)
}