import "bindings"
import exit from "@flo/core"
fnc strtol(nptr: i8*, end: i8*, base: int): i64
fnc main(argc: int, argv: i8**) {
    mod: LLVMModuleRef  = LLVMModuleCreateWithName("my_module".to_cstring())

    param_types = [LLVMInt32Type(), LLVMInt32Type()]
    ret_type: LLVMTypeRef  = LLVMFunctionType(LLVMInt32Type(), &param_types[0], 2, false)
    sum: LLVMValueRef  = LLVMAddFunction(mod, "sum".to_cstring(), ret_type)

    entry: LLVMBasicBlockRef  = LLVMAppendBasicBlock(sum, "entry".to_cstring())

    builder: LLVMBuilderRef  = LLVMCreateBuilder()
    LLVMPositionBuilderAtEnd(builder, entry)
    tmp: LLVMValueRef  = LLVMBuildAdd(builder, LLVMGetParam(sum, 0), LLVMGetParam(sum, 1), "tmp".to_cstring())
    LLVMBuildRet(builder, tmp)

    zero: i8 = 0
    
    NULL = &zero
    error_ = &zero
    LLVMVerifyModule(mod, /*LLVMAbortProcessAction*/ 0, &error_)
    LLVMDisposeMessage(error_)

    engine: LLVMExecutionEngineRef = new i8[64] as LLVMExecutionEngineRef
    LLVMLinkInMCJIT()
    FloLLVMInitializeNativeTarget()
    if (LLVMCreateExecutionEngineForModule(&engine, mod, &error_) != 0) {
        println("failed to create execution engine")
        exit()
    }
    if (error_[0]) {
        println("error:", error_)
        LLVMDisposeMessage(error_)
        exit()
    }

    if (argc < 3) {
        println("usage:", argv[0], "x y")
        exit()
    }
    x = strtol(argv[0], NULL, 10) 
    y = strtol(argv[1], NULL, 10)

    args = [
        LLVMCreateGenericValueOfInt(LLVMInt32Type(), x, false),
        LLVMCreateGenericValueOfInt(LLVMInt32Type(), y, false)
    ]
    LLVMGenericValueRef res = LLVMRunFunction(engine, sum, 2, &args[0])
    println(LLVMGenericValueToInt(res, false) as int)

    // Write out bitcode to file
    if (LLVMWriteBitcodeToFile(mod, "sum.bc".to_cstring()) != 0) {
        print("error writing bitcode to file, skipping\n")
    }

    LLVMDisposeBuilder(builder)
    LLVMDisposeExecutionEngine(engine)
}