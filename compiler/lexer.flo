fnc string_to_kw_token(word: string): TokType {
    if word == "and"
        return TokType.AND_KW
    if word == "or"
        return TokType.OR_KW
    if word == "xor"
        return TokType.XOR_KW
    if word == "const"
        return TokType.CONST_KW
    if word == "if" 
        return TokType.IF_KW
    if word == "else"
        return TokType.ELSE_KW
    if word == "bool"
        return TokType.BOOL_KW
    if word == "i4"
        return TokType.I4_KW
    if word == "i8"
        return TokType.I8_KW
    if word == "i16"
        return TokType.I16_KW
    if word == "i32"
        return TokType.I32_KW
    if word == "i64"
        return TokType.I64_KW
    if word == "i128"
        return TokType.I128_KW
    if word == "int"
        return TokType.INT_KW
    if word == "f16"
        return TokType.F16_KW
    if word == "f32"
        return TokType.F32_KW
    if word == "f64"
        return TokType.F64_KW
    if word == "float"
        return TokType.FLOAT_KW
    if word == "void"
        return TokType.VOID_KW
    if word == "for"
        return TokType.FOR_KW
    if word == "while"
        return TokType.WHILE_KW
    if word == "fnc"
        return TokType.FNC_KW
    if word == "break"
        return TokType.BREAK_KW
    if word == "continue"
        return TokType.CONTINUE_KW
    if word == "return"
        return TokType.RETURN_KW
    if word == "import"
        return TokType.IMPORT_KW
    if word == "type"
        return TokType.TYPE_KW
    if word == "from"
        return TokType.FROM_KW
    if word == "in"
        return TokType.IN_KW
    if word == "class"
        return TokType.CLASS_KW
    if word == "enum"
        return TokType.ENUM_KW
    if word == "new"
        return TokType.NEW_KW
    if word == "as"
        return TokType.AS_KW
    if word == "is"
        return TokType.IS_KW
    if word == "extends"
        return TokType.EXTENDS_KW
    return -1
}
fnc is_identifier_char(char: i8): bool {
    return (char >= 'A' and char <= 'Z') or (char >= 'a' and char <= 'z') or (char == '_')
}
fnc is_number_char(char: i8): bool {
    return (char >= '0' and char <= '9')
}
fnc capitalize(char: i8): i8 {
    if char >= 'a' and char <= 'z'
        return char - ' '
    return char 
}
fnc in_base_range(char: i8, base: int): bool {
    if base < 10 
        return char >= '0' and char <= (base + 48)
    return (char >= '0' and char <= (base + 48)) or (char >= 'A' and char <= (base + 65))
}
class Token {
    ttype: TokType
    range: FloRange
    constructor(ttype: TokType, range: FloRange){
        this.ttype = ttype
        this.range = range
    }
}
class IntToken extends Token {
    value: int
    constructor(value: int, range: FloRange){
        super(TokType.INT, range)
        this.value = value
    }
}
class FloatToken extends Token {
    value: float
    constructor(value: float, range: FloRange){
        super(TokType.FLOAT, range)
        this.value = value
    }
}
class CharToken extends Token {
    value: i8
    constructor(value: i8, range: FloRange){
        super(TokType.CHAR, range)
        this.value = value
    }
}
class StrToken extends Token {
    value: string
    constructor(value: string, range: FloRange){
        super(TokType.STR, range)
        this.value = value
    }
}
class IdentifierToken extends Token {
    value: string
    constructor(value: string, range: FloRange){
        super(TokType.IDENTIFER, range)
        this.value = value
    }
}
class Lexer {
    current_char: i8
    text: string
    errors: Array<FloError>
    idx: int
    col: int
    line: int
    constructor(text: string, errors: Array<FloError>){
        this.idx = -1
        this.line = 1
        this.col = 0
        this.text = text
        this.errors = errors
    }
    eof(): bool{
        return this.idx >= this.text.length
    }
    peek(offset = 1): i8 {
        if this.idx + offset < this.text.length 
            return this.text.get_byte(this.idx + offset)
        return '\0'
    }
    advance(){
        this.current_char = this.text.get_byte(++this.idx)
        if this.current_char == '\n' {
            this.col = 0
            this.line++
        } else
            this.col++
    }
    get_range(back: int): FloRange {
        return new FloRange(this.idx - back + 1, this.idx + 1, this.col - back, this.line)
    }
    plus_token(): Token {
        if this.peek() == '+' {
            this.advance()
            return new Token(TokType.PLUS_PLUS, this.get_range(2))
        }
        return new Token(TokType.PLUS, this.get_range(1))
    }
    skip_comment(): bool{
        if this.peek() == '*' {
            this.advance()
            while true {
                if this.peek() == '*' and this.peek(2) == '/' break
                this.advance()
            }
            this.advance()
            this.advance()
            return true
        } else if this.peek() == '/' {
            this.advance()
            while this.peek() != '\n'
                this.advance()
            return true
        }
        return false
    }
    minus_token(): Token{
        if this.peek() == '-' {
            this.advance()
            return new Token(TokType.MINUS_MINUS, this.get_range(2))
        }
        return new Token(TokType.MINUS, this.get_range(2))
    }
    eq_token(): Token {
        if this.peek() == '='{
            this.advance()
            return new Token(TokType.EEQ, this.get_range(2))
        } 
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.ARROW, this.get_range(2))
        }
        return new Token(TokType.EQ, this.get_range(1))
    }
    neq_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.NEQ, this.get_range(2))
        }
        return new Token(TokType.NOT, this.get_range(1))
    }
    gt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.GTE, this.get_range(2))
        }
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.SR, this.get_range(2))
        }
        return new Token(TokType.GT, this.get_range(1))
    }
    lt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.LTE, this.get_range(2))
        }
        else if this.peek() == '<' {
            this.advance()
            return new Token(TokType.SL, this.get_range(2))
        }
        return new Token(TokType.LT, this.get_range(1))
    }
    dot_token(): Token {
        token = TokType.DOT
        length = 1
        if this.peek() == '.'{
            token = TokType.DOT_DOT
            length++
            this.advance()
            if this.peek() == '.' {
                token = TokType.DOT_DOT_DOT
                length++
                this.advance()
            }
        }
        return new Token(token, this.get_range(length))
    }
    base_int_token(base: int): IntToken{
        this.advance()
        this.advance()
        length = 3
        value = 0
        while in_base_range(current_char = capitalize(this.current_char), base) {
            value *= base
            add =  current_char - '0'
            if (current_char >= 'A') add = current_char - 'A' + 10
            value += add
            length++
            this.advance()
        }
        return new IntToken(value, this.get_range(length))
    }
    numeric_token(): Token {
        length = 1
        is_float = false
        if this.current_char == '0' and this.peek() == 'b'
            return this.base_int_token(2)
        if this.current_char == '0' and this.peek() == 'o'
            return this.base_int_token(8)
        if this.current_char == '0' and this.peek() == 'x'
            return this.base_int_token(16)
        while is_number_char(next_char = this.peek()) or next_char == '.' {
            if next_char == '.' and (is_float or !is_number_char(this.peek(2))) break
            if this.current_char == '.' is_float = true
            length++
            this.advance()
        }
        range = this.get_range(length)
        str_value = this.text.substring(range.start, length)
        if is_float 
            return new FloatToken(str_value as float, range)
        return new IntToken(str_value as int, range)
    }
    identifier_token(): Token {
        length = 1
        start = this.idx
        while is_identifier_char(next_char = this.peek()) or is_number_char(next_char){
            length++
            this.advance()
        }
        value = this.text.substring(start, length)
        range = this.get_range(length)
        if (keyword = string_to_kw_token(value)) != -1 return new Token(keyword, range)
        return new IdentifierToken(value, range)
    }
    string_token(): StrToken {
        length = 2
        this.advance()
        escape_next = false
        while true {
            if (this.current_char == '"' and !escape_next) break
            length++
            escape_next = this.current_char == '\\'
            this.advance()
        }
        range = this.get_range(length)
        value = this.text.substring(range.start+1, length-2)
        return new StrToken(value, range)
    }
    char_token(): CharToken {
        length = 3
        value = this.current_char
        this.advance()
        if this.current_char == '\\' {
            this.advance()
            if this.current_char == 'a'
                value = '\a'
            else if this.current_char == 'b'
                value = '\b'
            else if this.current_char == 't'
                value = '\t'
            else if this.current_char == 'n'
                value = '\n'
            else if this.current_char == 'r'
                value = '\r'
            else if this.current_char == 'v'
                value = '\v'
            else if this.current_char == '0'
                value = '\0'
            else if this.current_char == '\''
                value = '\''
            else if this.current_char == '\"'
                value = '\"'
            else if this.current_char == '\\'
                value = '\\'
            else
                value = this.current_char
            length+=2
        }
        this.advance()
        return new CharToken(value, this.get_range(length))
    }
    tokenize(): Array<Token> {
        this.advance()
        tokens: Array<Token> = []
        while !this.eof() and this.errors.length == 0 {
            char = this.current_char
            if char == ' ' true
            else if is_identifier_char(char)
                tokens << (this.identifier_token() as Token)
            else if char == '"'
                tokens << (this.string_token() as Token)
            else if is_number_char(char)
                tokens << (this.numeric_token() as Token)
            else if char == ':' 
                tokens << new Token(TokType.COL, this.get_range(1))
            else if char == ';'
                tokens << new Token(TokType.SEMICOL, this.get_range(1))
            else if char == ','
                tokens << new Token(TokType.COMMA, this.get_range(1))
            else if char == '+'
                tokens << this.plus_token()
            else if char == '-'
                tokens << this.minus_token()
            else if char == '*'
                tokens << new Token(TokType.MULT, this.get_range(1))
            else if char == '('
                tokens << new Token(TokType.LPAR, this.get_range(1))
            else if char == ')'
                tokens << new Token(TokType.RPAR, this.get_range(1))
            else if char == '%'
                tokens << new Token(TokType.MOD, this.get_range(1))
            else if char == '{'
                tokens << new Token(TokType.LBRACE, this.get_range(1))
            else if char == '}'
                tokens << new Token(TokType.RBRACE, this.get_range(1))
            else if char == '['
                tokens << new Token(TokType.LBRACKET, this.get_range(1))
            else if char == ']'
                tokens << new Token(TokType.RBRACKET, this.get_range(1))
            else if char == '\n' or char == '\r'
                tokens << new Token(TokType.LN, this.get_range(1))
            else if char == '\''
                tokens << (this.char_token() as Token)
            else if char == '^'
                tokens << new Token(TokType.POW, this.get_range(1))
            else if char == '?'
                tokens << new Token(TokType.QUES, this.get_range(1))
            else if char == '&'
                tokens << new Token(TokType.AMP, this.get_range(1))
            else if char == '='
                tokens << this.eq_token()
            else if char == '!'
                tokens << this.neq_token()
            else if char == '>'
                tokens << this.gt_token()
            else if char == '<'
                tokens << this.lt_token()
            else if char == '.'
                tokens << this.dot_token()
            else if char == '/' {
                if (!this.skip_comment())
                    tokens << new Token(TokType.DIV, this.get_range(1))
            } else {
                this.errors << new FloError(ErrorKind.ILLEGALCHAR, "Illegal character: '"+this.text.substring(this.idx, 1)+"'", this.get_range(1))
            }
            this.advance()
        }
        tokens << new Token(TokType.EOF, new FloRange(0, 0, this.col, this.line))
        return tokens
    }
}