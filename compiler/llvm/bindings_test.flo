import "bindings"
import "../utils"
import exit in "@flo/core"
fnc strtol(nptr: i8*, end: i8*, base: int): i64
fnc main(argc: int, argv: i8**) {
    let mod: LLVMModuleRef  = LLVMModuleCreateWithName("my_module")

    let param_types = [LLVMInt32Type(), LLVMInt32Type()]
    let ret_type: LLVMTypeRef  = LLVMFunctionType(LLVMInt32Type(), &param_types[0], 2, false)
    let sum: LLVMValueRef  = LLVMAddFunction(mod, "sum", ret_type)

    let entry: LLVMBasicBlockRef  = LLVMAppendBasicBlock(sum, "entry")

    let builder: LLVMBuilderRef  = LLVMCreateBuilder()
    LLVMPositionBuilderAtEnd(builder, entry)
    let tmp: LLVMValueRef  = LLVMBuildAdd(builder, LLVMGetParam(sum, 0), LLVMGetParam(sum, 1), "tmp")
    LLVMBuildRet(builder, tmp)

    let zero: i8 = 0
    
    let NULL = &zero
    let error_ = &zero
    LLVMVerifyModule(mod, /*LLVMAbortProcessAction*/ 0, &error_)
    LLVMDisposeMessage(error_)

    let engine: LLVMExecutionEngineRef = new i8[64] as LLVMExecutionEngineRef
    LLVMLinkInMCJIT()
    FloLLVMInitializeNativeTarget()
    FloLLVMInitializeNativeAsmPrinter()
    FloLLVMInitializeNativeAsmParser()
    if (LLVMCreateExecutionEngineForModule(&engine, mod, &error_) != 0) {
        println("failed to create execution engine")
        exit()
    }
    if (zero) {
        println("error:", string_from_cstring(error_))
        LLVMDisposeMessage(error_)
        exit()
    }

    if (argc < 2) {
        println("usage:", string_from_cstring(argv[0]), "x y")
        exit()
    }
    let x = strtol(argv[1], NULL, 10) 
    let y = strtol(argv[2], NULL, 10)
    let functionPtr = LLVMGetFunctionAddress(engine, "sum")
    let sum_fnc = functionPtr as (i64, i64) => i32
    println(sum_fnc(x, y))
    LLVMPrintModuleToFile(mod, "sum.ll", &error_)
    // Write out bitcode to file
    if (zero != 0) {
        println(string_from_cstring(error_))
    }

    LLVMDisposeBuilder(builder)
    LLVMDisposeExecutionEngine(engine)
}