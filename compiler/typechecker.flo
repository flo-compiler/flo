const machine_word_size = 64
class TypeId {
    module_id: int
    id: int
}
class Type {
    kind: TypeKind
    constructor(kind: TypeKind){
        this.kind = kind
    }
    __eq__(other: Type): bool {
        return this.kind == other.kind
    }
}
const unknown_type = new Type(TypeKind.UNKNOWN)
class BooleanType (Type) {
    constructor(){
        super(TypeKind.BOOL)
    }
}
class PointerType (Type) {
    pointee_type: Type
    constructor(pointee_type: Type){
        super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType (Type) {
    arg_types: Type[]
    return_type: Type
    constructor(arg_types: Type[], return_type: Type){
        super(TypeKind.FNC)
        this.arg_types = arg_types
        this.return_type = return_type
    }
}
class Value {
    value_type: Type
}
class Statement {
    kind: StatementKind
    constructor(kind: StatementKind){
        this.kind = kind
    }
}
class Expression (Statement) {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    constructor(expr_kind: ExpressionKind){
        super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.is_constant = false
    }
}
class ArrayType (Type) {
    element_type: Type
    length: Expression
    constructor(element_type: Type, length: Expression){
        super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
}
class IntExpression (Expression) {
    value: int
    constructor(value: int){
        super(ExpressionKind.INT)
        this.value_type = new Type(TypeKind.INT)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression (Expression) {
    value: int 
    constructor(value: int){
        super(ExpressionKind.BOOL)
        this.value_type = new BooleanType()
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression (Expression) {
    value: float
    constructor(value: float){
        super(ExpressionKind.FLOAT)
        this.value_type = new Type(TypeKind.FLOAT)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression (Expression) {
    value: string
    constructor(value: string){
        super(ExpressionKind.STRING)
        this.value_type = new Type(TypeKind.STRING)
        this.value = value
        this.is_constant = true
    }
}
class NullExpression (Expression) {
    constructor(value_type: Type){
        super(ExpressionKind.NULL)
        this.value_type = value_type 
        this.is_constant = true
    }
}
class ArrayExpression (Expression) {
    value: Expression[]
    constructor(value: Expression[]){
        super(ExpressionKind.ARRAY)
        this.value = value
        if value.length > 0
            this.value_type = new ArrayType(value[0].value_type, new IntExpression(value.length))
    }
}
class BinaryExpression (Expression) {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type){
        super(ExpressionKind.BIN)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.value_type = value_type
    }
}
class UnaryExpression (Expression) {
    op: UnaryOp
    expression: Expression
    constructor(op: UnaryOp, expression: Expression, value_type: Type){
        super(ExpressionKind.UNARY)
        this.op = op
        this.expression = expression
        this.value_type = value_type
    }
}
class TypeExpression (Expression) {
    expr: Expression
    ty_op: TypeExprOp
    bound_type: Type
    constructor(expr: Expression, ty_op: TypeExprOp, bound_type: Type){
        super(ExpressionKind.TYPEBOUND)
        this.expr = expr
        this.ty_op = ty_op
        if ty_op == TypeExprOp.AS 
            this.value_type = bound_type
        if ty_op == TypeExprOp.IS
            this.value_type = new BooleanType()
        this.bound_type = bound_type
    }
}
class NewExpression (Expression) {
    constructor(){
        super(ExpressionKind.NEW)
    }
} 
class MemberExpression (Expression) {
    constructor(){
        super(ExpressionKind.MEMBER)
    }
}
class IndexExpression (Expression) {
    constructor(){
        super(ExpressionKind.INDEX)
    }
}
class CallExpression (Expression) {
    callee: Expression
    args: Expression[]
    constructor(callee: Expression, args: Expression[], value_type: Type){
        super(ExpressionKind.CALL)
        this.callee = callee
        this.args = args
        this.value_type = value_type
    }
}
class VarId {
    kind: VarIdKind
    module_id: int
    id: int
    constructor(kind: VarIdKind, module_id: int, id: int){
        this.kind = kind
        this.module_id = module_id
        this.id = id
    }
}
class ClassId {
    module_id: int
    class_id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.class_id = id
    }
}
class EnumId {
    module_id: int
    enum_id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.enum_id = id
    }
}
class VarAccessExpression (Expression) {
    value_id: VarId
    constructor(value_id: VarId, value_type: Type){
        super(ExpressionKind.VAR)
        this.value_id = value_id
        this.value_type = value_type
    }
}
class AssignmentExression(BinaryExpression){
    assign_kind: AssignKind
    constructor(assign_kind: AssignKind, expression: Expression) {
        super(expression, BinaryOp.ASSIGN, expression, expression.value_type)// TODO: Need to change that
        this.assign_kind = assign_kind
    }
}
class VarAssignmentExpression (AssignmentExression) {
    value_id: VarId
    constructor(value_id: VarId, expression: Expression) {
        super(AssignKind.VAR, expression)
        this.value_id = value_id
    }
}
class Block {
    statements: Statement[]
    constructor(){
        this.statements = []
    }
}
class IfStatement (Statement) {
    condition: Expression
    block: Block
    else_block: Optional<Block>
    constructor(condition: Expression, block: Block, else_block: Optional<Block>){
        super(StatementKind.IF)
        this.condition = condition
        this.block = block
        this.else_block = else_block
    }
}
class VarDeclaration (Statement) {
    name: string
    var_id: VarId
    expression: Expression
    constructor(name: string, var_id: VarId, expression: Expression){
        this.var_id = var_id
        this.name = name
        this.expression = expression
        super(StatementKind.VAR)
    }
}
class ForStatement (Statement) {
    init: Expression
    comp: Expression
    incrdecr: Expression
    block: Block
    constructor(){
        super(StatementKind.FOR)
    }
}
class WhileStatement (Statement) {
    cond: Expression
    block: Block
    constructor(){
        super(StatementKind.WHILE)
    }
}
class ReturnStatement (Statement) {
    return_value: Optional<Expression>
    constructor(){
        super(StatementKind.RETURN)
        this.return_value = new Optional<Expression>()
    }
}


fnc is_numeric(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_float(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.F16 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_int(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.INT
}
fnc is_bool(val_ty: Type): bool {
    return val_ty.kind == TypeKind.BOOL
}
fnc is_null(exp: Expression): bool {
    return exp.expr_kind == ExpressionKind.NULL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    return exp.value_type == val_ty ? exp : new TypeExpression(exp, TypeExprOp.AS, val_ty)
}
fnc max_type(t1: Type, t2: Type): Type {
    return t1.kind > t2.kind ? t1 : t2
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    let ty1 = p1[0].value_type
    let ty2 = p2[0].value_type
    if ty1 != ty2 {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc dump_type(ty: Type): string {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if ty.kind == TypeKind.I4
        return "i4"
    if ty.kind == TypeKind.I8
        return "i8"
    if ty.kind == TypeKind.I16
        return "i16"
    if ty.kind == TypeKind.I32
        return "i32"
    if ty.kind == TypeKind.I64
        return "i64"
    if ty.kind == TypeKind.I128
        return "i128"
    if ty.kind == TypeKind.INT
        return "i"+machine_word_size
    if ty.kind == TypeKind.F16
        return "f16"
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.FLOAT
        return "f"+machine_word_size
    if ty.kind == TypeKind.VOID
        return "void"
    return "any"
}
fnc dump_bin_op(op: BinaryOp): string {
    if op == BinaryOp.ADD
        return "+"
    if op == BinaryOp.SUB
        return "-"
    if op == BinaryOp.MUL
        return "*"
    if op == BinaryOp.DIV
        return "/"
    if op == BinaryOp.MOD
        return "%"
    if op == BinaryOp.POW
        return "^"
    if op == BinaryOp.GT
        return ">"
    if op == BinaryOp.GTE
        return ">="
    if op == BinaryOp.LT
        return "<"
    if op == BinaryOp.LTE
        return "<="
    if op == BinaryOp.EEQ
        return "=="
    if op == BinaryOp.NEQ
        return "!"
    if op == BinaryOp.SL
        return "<<"
    if op == BinaryOp.SR
        return ">>"
    if op == BinaryOp.OR
        return "or"
    if op == BinaryOp.AND
        return "and"
    if op == BinaryOp.XOR
        return "xor"
    if op == BinaryOp.IN
        return "in"
    if op == BinaryOp.ASSIGN
        return "="
    return ".."
}
class Scope {
    vars: Map<string, VarId>
    classes: Map<string, ClassId>
    functions: Map<string, VarId>
    enums: Map<string, EnumId>
    parent: Optional<Scope>
    type_aliases: Map<string, Type>
    constructor(){
        this.vars = new Map<string, VarId>()
        this.classes = new Map<string, ClassId>()
        this.functions = new Map<string, VarId>()
        this.enums = new Map<string, EnumId>()
        this.type_aliases = new Map<string, Type>()
        this.parent = new Optional<Scope>() 
    }
    getVar(name: string): Optional<VarId> {
        let current_scope = this
        let value = this.vars.get(name)
        while current_scope.parent.has_value and !value.has_value {
            current_scope = current_scope.parent.value
            value = current_scope.vars.get(name)
            if !value.has_value
                value = current_scope.functions.get(name)
        }
        return value
    }
}
class FunctionArg {
    name: string
    default: Optional<Expression>
}
class Function (Value) {
    id: VarId
    name: string
    args: FunctionArg[]
    block: Block
    scope: Scope
}
class Var (Value) {
    var_id: VarId
    value: Expression
    constructor(value: Expression){
        this.value = value
        this.value_type = value.value_type
    }
}
class ClassField {
    name: string
    field_type: Type
}
class Class {
    id: ClassId
    name: string
    fields: ClassField[]
    methods: Function[]
    scope: Scope
}
class EnumField {
    name: string
    // value: Value
    constructor(name: string){
        this.name = name
    }
}
class Enum {
    id: EnumId
    name: string
    fields: EnumField[]
    constructor(){
        this.fields = []
    }
}
class Module {
    id: int
    name: string
    vars: Var[]
    classes: Class[]
    functions: Function[]
    enums: Enum[]
    scopes: Scope[]
    constructor(){
        this.functions = []
        this.vars = []
        this.classes = []
        this.functions = []
        this.enums = []
        this.scopes = []
    }
}
class Program {
    modules: Module[]
    constructor(){
        this.modules = []
    }
}
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    program: Program
    current_module: int
    current_class: int
    current_function: int
    current_scope: int
    filename: string
    content: string
    constants: string[]
    constructor(){
        this.current_module = -1
        this.current_function = -1
        this.current_class = -1
        this.current_scope = -1
        this.program = new Program()
        this.constants = ["true", "false", "null"]
    }
    get_current_module(): Module {
        return this.program.modules[this.current_module]
    }
    get_current_scope(): Scope {
        return this.get_current_module().scopes[this.current_scope]
    }
    error(kind: ErrorKind, message: string, range: FloRange){
        print_error(new FloError(kind, message, range), this.filename, this.content)
        exit()
    }
    check(module_ast: ModuleAST, name: string, content: string): Program {
        this.current_module++
        this.filename = name
        this.content = content
        let module = new Module()
        module.name = name
        this.current_scope = module.scopes.length
        module.scopes << new Scope()
        this.program.modules << module
        for let i = 0; i < module_ast.classes.length; i++ {
            let checked_class = this.declare_class(module_ast.classes[i])
            checked_class.id = new ClassId(this.current_module, i)
            module.classes << checked_class
            module.scopes[this.current_scope].classes.set(checked_class.name, checked_class.id)
        }
        for i = 0; i < module_ast.type_aliases.length; i++  {
            let type_alias_node = module_ast.type_aliases[i]
            let ty = this.check_type(type_alias_node.parsed_type)
            module.scopes[this.current_scope].type_aliases.set(type_alias_node.name.value, ty)
        }
        for i = 0; i < module_ast.functions.length; i++ {
            let checked_function = this.declare_function(module_ast.functions[i])
            checked_function.id = new VarId(VarIdKind.FNC, this.current_module, i)
            module.functions << checked_function
            module.scopes[this.current_scope].functions.set(checked_function.name, checked_function.id)
        }
        for i = 0; i < module_ast.enums.length; i++ {
            let checked_enum = this.declare_enum(module_ast.enums[i])
            checked_enum.id = new EnumId(this.current_module, i)
            module.enums << checked_enum
            module.scopes[this.current_scope].enums.set(checked_enum.name, checked_enum.id)
        }
        // We Now check bodies
        for i = 0; i < module_ast.functions.length; i++ {
            module.functions[i].block = this.check_block(module_ast.functions[i].block)
        }
        return this.program
    }
    declare_function(function_node: FunctionDeclarationNode): Function {
        let checked_function = new Function()
        let name = function_node.name.value
        checked_function.name = name
        if name in this.constants {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '"+name+"'", function_node.name.range)
        }
        let arg_types: Type[] = []
        checked_function.args = []
        for let i = 0; i < function_node.args.length; ++i {
            let arg = function_node.args[i]
            let fnc_arg = new FunctionArg()
            fnc_arg.name = arg.name.value
            fnc_arg.default = new Optional<Expression>()
            if arg.default.has_value
                fnc_arg.default.set_value(this.check_expression(unknown_type, arg.default.value))
            checked_function.args << fnc_arg
            arg_types << this.check_type(arg.parsed_type)
        }
        let ret_type = this.check_type(function_node.return_type)
        checked_function.value_type = new FunctionType(arg_types, ret_type)
        return checked_function
    }
    declare_class(class_decl_node: ClassDeclarationNode): Class{
        let declared_class = new Class()
        declared_class.fields = []
        declared_class.methods = []
        declared_class.name = class_decl_node.name.value
        for let i = 0; i < class_decl_node.generic_parameters.length; ++i {
            let generic_param = class_decl_node.generic_parameters[i]
        }
        for i = 0; i < class_decl_node.fields.length; ++i {
            let field = new ClassField()
            let current_f_node = class_decl_node.fields[i]
            field.name = current_f_node.name.value
            field.field_type = this.check_type(current_f_node.parsed_type)
            declared_class.fields << field
        }
        for i = 0; i < class_decl_node.methods.length; ++i {
            declared_class.methods << this.declare_function(class_decl_node.methods[i])
        }
        return declared_class
    }
    declare_enum(enum_node: EnumNode): Enum{
        let declared_enum = new Enum()
        declared_enum.name = enum_node.name.value
        for let i = 0; i < enum_node.fields.length; ++i {
            let enum_node_f = enum_node.fields[i]
            declared_enum.fields << new EnumField(enum_node_f.name.value)
        }
        return declared_enum
    }
    check_type(type_node: TypeNode): Type {
        if type_node.kind == TypeKind.BOOL
            return new Type(TypeKind.BOOL)
        if type_node.kind >= TypeKind.I4 and type_node.kind <= TypeKind.FLOAT
            return new Type(type_node.kind)
        if type_node.kind == TypeKind.VOID
            return new Type(TypeKind.VOID)
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY {
            let array_node = type_node as ArrayTypeNode
            let length = this.check_expression(new Type(TypeKind.INT), array_node.length)
            let element_type = this.check_type(array_node.element_type)
            return new ArrayType(element_type, length)
        }
        if type_node.kind == TypeKind.FNC {
            let fnc_node = type_node as FunctionTypeNode
            let arg_types: Type[] = []
            for let i = 0; i < fnc_node.args.length; i++ 
                arg_types << this.check_type(fnc_node.args[i])
            let return_type = this.check_type(fnc_node.return_type)
            return new FunctionType(arg_types, return_type)
        }
        // else
            return new Type(TypeKind.OBJECT)
    }
    check_array_expression(expected_type: Type, array_node: ArrayExpressionNode): ArrayExpression {
        //TODO: ARRAY is overloaded; Could be object or const so need to check which one it is.
        //TODO: Check Element type of expected type
        let elements: Expression[] = []
        if array_node.elements.length > 0 {
            elements << this.check_expression(expected_type, array_node.elements[0])
            let element_type =  elements[0].value_type
            for let i = 1; i < array_node.elements; ++i {
                let element = this.check_expression(element_type, array_node.elements[i])
                if element.value_type == element_type
                    elements << element
                else
                    this.error(ErrorKind.TYPE, "Expected element type of '"+dump_type(element_type)+"' but got type '"+dump_type(element.value_type)+"'", array_node.elements[i].range)
            }
        }
        return new ArrayExpression(elements)
    }
    check_var_access(expected_type: Type, var_access_node: VarAccessExpressionNode): Expression {
        let name = var_access_node.name.value
        if name == "true" 
            return new BooleanExpression(1) 
        if name == "false" 
            return new BooleanExpression(0)
        if name == "null"
            return new NullExpression(expected_type)
        let current_scope = this.get_current_scope()
        let resolved = current_scope.getVar(name)
        let var_ty = unknown_type
        if resolved.has_value {
            let var_id = resolved.value
            if var_id.kind == VarIdKind.FNC
                var_ty = this.program.modules[var_id.module_id].functions[var_id.id].value_type
            else
                var_ty = this.program.modules[var_id.module_id].vars[var_id.id].value_type
            return new VarAccessExpression(var_id, var_ty)
        } else {
            this.error(ErrorKind.NAME, "Undefined variable '" + name + "'", var_access_node.range)
        }
        return new VarAccessExpression(new VarId(0, -1, -1), var_ty)
    }
    check_assignment(left: Expression, right: Expression, binary_node: BinaryExpressionNode): BinaryExpression {
        if left.is_constant {
            this.error(ErrorKind.TYPE, "Cannot assign a value to a constant", binary_node.range)
        }
        if left.value_type != right.value_type {
            this.error(ErrorKind.TYPE, "Illegal assignment of variable of type '"+dump_type(right.value_type)+"' to '"+dump_type(left.value_type)+"'", binary_node.range)
        }
        if left.expr_kind == ExpressionKind.VAR {
            let var_access = left as VarAccessExpression
            let var_name = (binary_node.lhs as VarAccessExpressionNode).name
            let name = var_name.value
            return new VarAssignmentExpression(var_access.value_id, right)
        }
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type)
    }
    check_bin_expr(expected_type: Type, binary_node: BinaryExpressionNode): BinaryExpression {
        let left = this.check_expression(expected_type, binary_node.lhs)
        let right = this.check_expression(left.value_type, binary_node.rhs)
        let op = binary_node.op
        if is_null(left) and !is_null(right) {
            left.value_type = right.value_type
            /* Null check only goes 1 way */
            let tmp = left
            left = right
            right = tmp
        }
        if op == BinaryOp.ASSIGN 
            return this.check_assignment(left, right, binary_node)
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                if is_int(right.value_type)
                    right = cast_exp_to_type(right, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                return new BinaryExpression(left, op, right, left.value_type)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                //TODO: Check and cast the smaller bit size to the bigger one.
                check_cast_lower_bits(&left, &right)
                let exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = new BooleanType()
                
                return new BinaryExpression(left, op, right, exp_type)
            }
            if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                return new BinaryExpression(left, op, right, new BooleanType())
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                //TODO: Cast the float to int.
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                }
                return new BinaryExpression(left, op, right, left.value_type)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type)
        } 
        //TODO: Handle Range, In and Object Arithmetic and bit Cases.
        this.error(ErrorKind.TYPE, "Illegal binary operation '"+dump_bin_op(op)+"' between types '"+dump_type(left.value_type)+"' and '"+dump_type(right.value_type)+"'", binary_node.range)
        return new BinaryExpression(left, op, right, unknown_type)
    }
    check_unary_expr(unary_node: UnaryExpressionNode): UnaryExpression {
        let op = unary_node.op
        let expression = this.check_expression(unknown_type, unary_node.expression)
        let ty = expression.value_type
        if op == UnaryOp.NEG {
            if is_numeric(ty)
                return new UnaryExpression(op, expression, ty)
        }
        if op == UnaryOp.NOT {
            if is_bool(ty)
                return new UnaryExpression(op, expression, ty)
        }
        this.error(ErrorKind.GEN, "Illegal unary operation case", unary_node.range)
        return new UnaryExpression(op, expression, unknown_type)
    }
    check_type_expr(type_expr_node: TypeExpressionNode): TypeExpression {
        // Need to check if cast is compatible for typecase
        let exp = this.check_expression(unknown_type, type_expr_node.expression)
        let ty = this.check_type(type_expr_node.bound_type)
        return new TypeExpression(exp, type_expr_node.op, ty)
    }
    check_new_expr(new_expr_node: NewExpressionNode): NewExpression {
        return new NewExpression()
    }   
    check_member_expr(member_expr_node: MemberExpressionNode): MemberExpression {
        return new MemberExpression()
    }
    check_index_expr(index_expr_node: ExpressionIndexNode): IndexExpression {
        return new IndexExpression()
    }
    check_call_expr(call_expr_node: CallExpressionNode): CallExpression {
        let called = this.check_expression(unknown_type, call_expr_node.callee)
        //TODO: Check for generic functions.
        let func_ty = called.value_type as FunctionType
        let args: Expression[] = []
        if func_ty.kind == TypeKind.FNC {
            //TODO: fill default args.
            if func_ty.arg_types.length == call_expr_node.args.length {
                for let i = 0; i < call_expr_node.args.length; ++i {
                    let arg = this.check_expression(func_ty.arg_types[i], call_expr_node.args[i])
                    if arg.value_type == func_ty.arg_types[i]
                        args << arg
                    else
                        this.error(ErrorKind.TYPE, "Expected type '"+dump_type(func_ty.arg_types[i])+"' but got type '"+dump_type(arg.value_type)+"' as function call argument", call_expr_node.args[i].range)
                }
            } else {
                this.error(ErrorKind.GEN, "Expected "+func_ty.arg_types.length+" arguments on function call but got "+call_expr_node.args.length, call_expr_node.range)
            }
        } else {
            this.error(ErrorKind.TYPE, "Expected a function type for call but got '"+dump_type(func_ty)+"'", call_expr_node.callee.range)
        }
        return new CallExpression(called, args, func_ty.return_type)
    }
    check_expression(expected_type: Type, expr_node: ExpressionNode): Expression {
        let exp = new Expression(ExpressionKind.INT)
        if expr_node.expr_kind == ExpressionKind.INT {
            exp = new IntExpression((expr_node as IntExpressionNode).value.value)
            if is_int(expected_type){
                exp.value_type = expected_type
            }
            return exp
        }
        if expr_node.expr_kind == ExpressionKind.FLOAT {
            exp = new FloatExpression((expr_node as FloatExpressionNode).value.value)
            if is_float(expected_type){
                exp.value_type = expected_type
            }
            return exp
        }
        if expr_node.expr_kind == ExpressionKind.CHAR {
            let expr_value = new IntExpression((expr_node as CharExpressionNode).value.value as int)
            expr_value.value_type.kind = TypeKind.I8
            return expr_value
        }
        if expr_node.expr_kind == ExpressionKind.STR {
            return new StringExpression((expr_node as StringExpressionNode).value.value)
        }
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expected_type, expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.VAR
            return this.check_var_access(expected_type, expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expected_type, expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TYPEBOUND
            return this.check_type_expr(expr_node as TypeExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MEMBER
            return this.check_member_expr(expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expr_node as ExpressionIndexNode)
        /* if expr_node.expr_kind == ExpressionKind.CALL */
        return this.check_call_expr(expr_node as CallExpressionNode)
    }
    force_into_boolean(cond_node: ExpressionNode): Expression {
       let bool_type = new BooleanType()
       let condition = this.check_expression(bool_type, cond_node)
       return !is_bool(condition.value_type) ? cast_exp_to_type(condition, bool_type) : condition
    }
    check_if_stamement(if_stmt_node: IfStatementNode): IfStatement {
        let condition = this.force_into_boolean(if_stmt_node.condition)
       // TODO: Flow Check for returns/optionals.
        let block = this.check_block(if_stmt_node.block)
        let else_block = new Optional<Block>()
        if if_stmt_node.else_block.has_value
            else_block.set_value(this.check_block(if_stmt_node.else_block.value))
        return new IfStatement(condition, block, else_block)
    }
    check_var_declaration(var_decl_node: VarDeclarationStatement): VarDeclaration {
        let name = var_decl_node.var_name.value
        
        if name in this.constants
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '"+name+"'", var_decl_node.var_name.range)
        
        let var_type = unknown_type
        
        if var_decl_node.var_type.has_value
            var_type = this.check_type(var_decl_node.var_type.value)
        let value = this.check_expression(var_type, var_decl_node.value)
        
        if is_null(value) and value.value_type.kind == TypeKind.UNKNOWN
            this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", var_decl_node.range)
        
        if var_type.kind != TypeKind.UNKNOWN and var_type != value.value_type
            this.error(ErrorKind.TYPE, "Expected type '"+dump_type(var_type)+"' but got type '"+dump_type(value.value_type)+"' on variable declaration", var_decl_node.range)
        
        let var = new Var(value)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let id = new VarId(VarIdKind.VAR, this.current_module, current_module.vars.length)
        var.var_id = id
        
        if current_scope.vars.get(name).has_value
            this.error(ErrorKind.NAME, "Illegal re-declaration of already declared variable '"+name+"'", var_decl_node.var_name.range)
        
        current_scope.vars.set(name, id)
        current_module.vars << var
        return new VarDeclaration(name, id, value)
    }
    check_for_statement(for_stmt_node: ForStatementNode): ForStatement {
        return new ForStatement()
    }
    check_while_statment(while_stmt_node: WhileStatementNode): WhileStatement {
        return new WhileStatement()
    }
    check_can_break(): Statement {
        //TODO: check if we are in a loop
        return new Statement(StatementKind.BREAK)
    }
    check_can_continue(): Statement {
        //TODO: check if we are in a loop
        return new Statement(StatementKind.CONTINUE)
    }
    check_can_return(expr: Optional<ExpressionNode>): ReturnStatement {
        //TODO: check if we are in a function.
        //TODO: check if return type matches
        let current_function_return_type = unknown_type
        let rt_stmt = new ReturnStatement()
        if expr.has_value 
            rt_stmt.return_value.set_value(this.check_expression(current_function_return_type, expr.value))
        return rt_stmt
    }
    check_statement(stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue()
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break()
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode).value)
        return this.check_expression(unknown_type, stmt_node as ExpressionNode)
    }
    check_block(block_node: BlockNode): Block {
        let block = new Block()
        for let i = 0; i < block_node.statements.length; i++ {
            // TODO: check control flow and look for always return in the case of a function.
            block.statements << this.check_statement(block_node.statements[i])
        }
        return block
    }
}