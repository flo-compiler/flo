const machine_word_size = 64
class TypeId {
    module_id: int
    id: int
}
enum VarAccessType {
    FNC
    VAR
}
class Type {
    kind: TypeKind
    constructor(kind: TypeKind){
        this.kind = kind
    }
    __eq__(other: Type): bool {
        return this.kind == other.kind
    }
}
class BooleanType extends Type {
    constructor(){
        super(TypeKind.BOOL)
    }
}
class PointerType extends Type {
    pointee_type: Type
    constructor(pointee_type: Type){
        super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType extends Type {
    arg_types: Array<Type>
    return_type: Type
    constructor(arg_types: Array<Type>, return_type: Type){
        super(TypeKind.FNC)
        this.arg_types = arg_types
        this.return_type = return_type
    }
}
class Value {
    value_type: Type
}
class Statement {
    kind: StatementKind
    constructor(kind: StatementKind){
        this.kind = kind
    }
}
class Expression extends Statement {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    constructor(expr_kind: ExpressionKind){
        super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.is_constant = false
    }
}
class ArrayType extends Type {
    element_type: Type
    length: Expression
    constructor(element_type: Type, length: Expression){
        super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
}
class IntExpression extends Expression {
    value: int
    constructor(value: int){
        super(ExpressionKind.INT)
        this.value_type = new Type(TypeKind.INT)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression extends Expression {
    value: int 
    constructor(value: int){
        super(ExpressionKind.BOOL)
        this.value_type = new BooleanType()
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression extends Expression {
    value: float
    constructor(value: float){
        super(ExpressionKind.FLOAT)
        this.value_type = new Type(TypeKind.FLOAT)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression extends Expression {
    value: string
    constructor(value: string){
        super(ExpressionKind.STRING)
        this.value_type = new Type(TypeKind.STRING)
        this.value = value
        this.is_constant = true
    }
}
class ArrayExpression extends Expression {
    value: Array<Expression>
    constructor(value: Array<Expression>){
        super(ExpressionKind.ARRAY)
        this.value = value
        if value.length > 0
            this.value_type = new ArrayType(value[0].value_type, new IntExpression(value.length))
    }
}
class BinaryExpression extends Expression {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type){
        super(ExpressionKind.BIN)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.value_type = value_type
    }
}
class UnaryExpression extends Expression {
    op: UnaryOp
    expression: Expression
    constructor(op: UnaryOp, expression: Expression, value_type: Type){
        super(ExpressionKind.UNARY)
        this.op = op
        this.expression = expression
        this.value_type = value_type
    }
}
class TypeExpression extends Expression {
    expr: Expression
    ty_op: TypeExprOp
    bound_type: Type
    constructor(expr: Expression, ty_op: TypeExprOp, bound_type: Type){
        super(ExpressionKind.TYPEBOUND)
        this.expr = expr
        this.ty_op = ty_op
        if ty_op == TypeExprOp.AS 
            this.value_type = bound_type
        if ty_op == TypeExprOp.IS
            this.value_type = new BooleanType()
        this.bound_type = bound_type
    }
}
class NewExpression extends Expression {
    constructor(){
        super(ExpressionKind.NEW)
    }
} 
class MemberExpression extends Expression {
    constructor(){
        super(ExpressionKind.MEMBER)
    }
}
class IndexExpression extends Expression {
    constructor(){
        super(ExpressionKind.INDEX)
    }
}
class CallExpression extends Expression {
    callee: Expression
    args: Array<Expression>
    constructor(callee: Expression, args: Array<Expression>, value_type: Type){
        super(ExpressionKind.CALL)
        this.callee = callee
        this.args = args
        this.value_type = value_type
    }
}
class VarId {
    module_id: int
    id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.id = id
    }
}
class ClassId {
    module_id: int
    class_id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.class_id = id
    }
}
class EnumId {
    module_id: int
    enum_id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.enum_id = id
    }
}
class VarAccessExpression extends Expression {
    value_id: VarId
    constructor(value_id: VarId, value_type: Type){
        super(ExpressionKind.VAR)
        this.value_id = value_id
        this.value_type = value_type
    }
}
class Block {
    statements: Array<Statement>
    constructor(){
        this.statements = []
    }
}
class IfStatement extends Statement {
    pred: Expression
    if_block: Block
    else_block: Block
    constructor(){
        super(StatementKind.IF)
    }
}
class VarDeclaration extends Statement {
    name: string
    expression: Statement
    constructor(){
        super(StatementKind.VAR)
    }
}
class ForStatement extends Statement {
    init: Expression
    comp: Expression
    incrdecr: Expression
    block: Block
    constructor(){
        super(StatementKind.FOR)
    }
}
class WhileStatement extends Statement {
    cond: Expression
    block: Block
    constructor(){
        super(StatementKind.WHILE)
    }
}
class ReturnStatement extends Statement {
    return_value: Optional<Expression>
    constructor(){
        super(StatementKind.RETURN)
        this.return_value = new Optional<Expression>()
    }
}


fnc is_numeric(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_float(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.F16 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_int(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.INT
}
fnc is_bool(val_ty: Type): bool {
    return val_ty.kind == TypeKind.BOOL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    if exp.value_type == val_ty
        return exp
    return new TypeExpression(exp, TypeExprOp.AS, val_ty)
}
fnc max_type(t1: Type, t2: Type): Type {
    if t1.kind > t2.kind
        return t1
    return t2
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    ty1 = p1[0].value_type
    ty2 = p2[0].value_type
    if ty1 != ty2 {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc dump_type(ty: Type): string {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if ty.kind == TypeKind.I4
        return "i4"
    if ty.kind == TypeKind.I8
        return "i8"
    if ty.kind == TypeKind.I16
        return "i16"
    if ty.kind == TypeKind.I32
        return "i32"
    if ty.kind == TypeKind.I64
        return "i64"
    if ty.kind == TypeKind.I128
        return "i128"
    if ty.kind == TypeKind.INT
        return "i"+machine_word_size
    if ty.kind == TypeKind.F16
        return "f16"
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.FLOAT
        return "f"+machine_word_size
    if ty.kind == TypeKind.VOID
        return "void"
    return "any"
}
class Scope {
    vars: Map<string, VarId>
    classes: Map<string, ClassId>
    functions: Map<string, VarId>
    enums: Map<string, EnumId>
    parent: Optional<Scope>
    type_aliases: Map<string, Type>
    constructor(){
        this.vars = new Map<string, VarId>()
        this.classes = new Map<string, ClassId>()
        this.functions = new Map<string, VarId>()
        this.enums = new Map<string, EnumId>()
        this.type_aliases = new Map<string, Type>()
        this.parent = new Optional<Scope>() 
    }
}
class FunctionArg {
    name: string
    default: Optional<Expression>
}
class Function extends Value {
    id: VarId
    name: string
    args: Array<FunctionArg>
    block: Block
    scope: Scope
}
class Var extends Value {
    var_id: VarId
    value: Expression
    constructor(value: Expression){
        this.value = value
        this.value_type = value.value_type
    }
}
class ClassField {
    name: string
    field_type: Type
}
class Class {
    id: ClassId
    name: string
    fields: Array<ClassField>
    methods: Array<Function>
    scope: Scope
}
class EnumField {
    name: string
    // value: Value
    constructor(name: string){
        this.name = name
    }
}
class Enum {
    id: EnumId
    name: string
    fields: Array<EnumField>
    constructor(){
        this.fields = []
    }
}
class Module {
    id: int
    name: string
    vars: Array<Var>
    classes: Array<Class>
    functions: Array<Function>
    enums: Array<Enum>
    scope: Scope
    constructor(){
        this.functions = []
        this.vars = []
        this.classes = []
        this.functions = []
        this.enums = []
    }
}
class Program {
    modules: Array<Module>
    constructor(){
        this.modules = []
    }
}
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    program: Program
    current_module: int
    current_class: int
    current_function: int
    current_scope: Scope
    errors: Array<FloError>
    constructor(errors: Array<FloError>){
        this.current_module = -1
        this.errors = errors
        this.program = new Program()
    }
    check(module_ast: ModuleAST, name: string): Program {
        this.current_module++
        module = new Module()
        module.name = name
        module.scope = new Scope()
        this.current_scope = module.scope
        this.program.modules << module
        for i = 0; i < module_ast.classes.length; i++ {
            checked_class = this.declare_class(module_ast.classes[i])
            checked_class.id = new ClassId(this.current_module, i)
            module.classes << checked_class
            module.scope.classes.set(checked_class.name, checked_class.id)
        }
        for i = 0; i < module_ast.type_aliases.length; i++  {
            type_alias_node = module_ast.type_aliases[i]
            ty = this.check_type(type_alias_node.parsed_type)
            module.scope.type_aliases.set(type_alias_node.name.value, ty)
        }
        for i = 0; i < module_ast.functions.length; i++ {
            checked_function = this.declare_function(module_ast.functions[i])
            checked_function.id = new VarId(this.current_module, i)
            module.functions << checked_function
            module.scope.functions.set(checked_function.name, checked_function.id)
        }
        for i = 0; i < module_ast.enums.length; i++ {
            checked_enum = this.declare_enum(module_ast.enums[i])
            checked_enum.id = new EnumId(this.current_module, i)
            module.enums << checked_enum
            module.scope.enums.set(checked_enum.name, checked_enum.id)
        }
        // We New check bodies
        for i = 0; i < module_ast.functions.length; i++ {
            module.functions[i].block = this.check_block(module_ast.functions[i].block)
        }
        return this.program
    }
    declare_function(function_node: FunctionDeclarationNode): Function {
        checked_function = new Function()
        checked_function.name = function_node.name.value
        arg_types: Array<Type> = []
        checked_function.args = []
        for i = 0; i < function_node.args.length; ++i {
            arg = function_node.args[i]
            fnc_arg = new FunctionArg()
            fnc_arg.name = arg.name.value
            fnc_arg.default = new Optional<Expression>()
            if arg.default.has_value
                fnc_arg.default.set_value(this.check_expression(arg.default.value))
            checked_function.args << fnc_arg
            arg_types << this.check_type(arg.parsed_type)
        }
        ret_type = this.check_type(function_node.return_type)
        checked_function.value_type = new FunctionType(arg_types, ret_type)
        return checked_function
    }
    declare_class(class_decl_node: ClassDeclarationNode): Class{
        declared_class = new Class()
        declared_class.fields = []
        declared_class.methods = []
        declared_class.name = class_decl_node.name.value
        for i = 0; i < class_decl_node.generic_parameters.length; ++i {
            generic_param = class_decl_node.generic_parameters[i]
        }
        for i = 0; i < class_decl_node.fields.length; ++i {
            field = new ClassField()
            current_f_node = class_decl_node.fields[i]
            field.name = current_f_node.name.value
            field.field_type = this.check_type(current_f_node.parsed_type)
            declared_class.fields << field
        }
        for i = 0; i < class_decl_node.methods.length; ++i {
            declared_class.methods << this.declare_function(class_decl_node.methods[i])
        }
        return declared_class
    }
    declare_enum(enum_node: EnumNode): Enum{
        declared_enum = new Enum()
        declared_enum.name = enum_node.name.value
        for i = 0; i < enum_node.fields.length; ++i {
            enum_node_f = enum_node.fields[i]
            declared_enum.fields << new EnumField(enum_node_f.name.value)
        }
        return declared_enum
    }
    check_type(type_node: TypeNode): Type {
        if type_node.kind == TypeKind.BOOL
            return new Type(TypeKind.BOOL)
        if type_node.kind >= TypeKind.I4 and type_node.kind <= TypeKind.FLOAT
            return new Type(type_node.kind)
        if type_node.kind == TypeKind.VOID
            return new Type(TypeKind.VOID)
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY {
            array_node = type_node as ArrayTypeNode
            length = this.check_expression(array_node.length)
            element_type = this.check_type(array_node.element_type)
            return new ArrayType(element_type, length)
        }
        if type_node.kind == TypeKind.FNC {
            fnc_node = type_node as FunctionTypeNode
            arg_types: Array<Type> = []
            for i = 0; i < fnc_node.args.length; i++ 
                arg_types << this.check_type(fnc_node.args[i])
            return_type = this.check_type(fnc_node.return_type)
            return new FunctionType(arg_types, return_type)
        }
        // else
            return new Type(TypeKind.OBJECT)
    }
    check_array_expression(array_node: ArrayExpressionNode): ArrayExpression {
        //TODO: ARRAY is overloaded; Could be object or const so need to check which one it is.
        elements: Array<Expression> = []
        if array_node.elements.length > 0 {

            elements << this.check_expression(array_node.elements[0])
            element_type =  elements[0].value_type
            for i = 1; i < array_node.elements; ++i {
                element = this.check_expression(array_node.elements[i])
                if element.value_type == element_type
                    elements << element
                // TODO: Emit type mismatch error (else)
            }
        }
        return new ArrayExpression(elements)
    }
    check_var_access(var_access_node: VarAccessExpressionNode): Expression {
        name = var_access_node.name.value
        if name == "true" {
            return new BooleanExpression(1)
        } else if name == "false"{
            return new BooleanExpression(0)
        }
        resolved = this.current_scope.vars.get(name)
        var_ty = new Type(TypeKind.UNKNOWN)
        if !resolved.has_value {
            resolved = this.current_scope.functions.get(name)
        } else {
            var_ty = this.program.modules[resolved.value.module_id].vars[resolved.value.id].value_type
        }
        if resolved.has_value {
            val = resolved.value
            if var_ty.kind == TypeKind.UNKNOWN
            var_ty = this.program.modules[val.module_id].functions[val.id].value_type
            return new VarAccessExpression(val, var_ty)
        }
        return new VarAccessExpression(new VarId(-1, -1), var_ty)
        //TODO: Emit error when not found.(else)
    }
    check_assignment(left: Expression, right: Expression): BinaryExpression {
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type)
    }
    check_bin_expr(binary_node: BinaryExpressionNode): BinaryExpression {
        left = this.check_expression(binary_node.lhs)
        right = this.check_expression(binary_node.rhs)
        op = binary_node.op
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                if is_int(right.value_type){
                    right = cast_exp_to_type(right, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                }
                return new BinaryExpression(left, op, right, left.value_type)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                //TODO: Check and cast the smaller bit size to the bigger one.
                check_cast_lower_bits(&left, &right)
                exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = new BooleanType()
                
                return new BinaryExpression(left, op, right, exp_type)
            }
            if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                return new BinaryExpression(left, op, right, new BooleanType())
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                //TODO: Cast the float to int.
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                }
                return new BinaryExpression(left, op, right, left.value_type)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type)
        } 
        //TODO: Handle Range Case.
        else if op == BinaryOp.ASSIGN {
            return this.check_assignment(left, right)
        }
        //TODO: check if left and right are compatible and cast if necessary
        //TODO: Resolve type
        return new BinaryExpression(left, op, right, new Type(TypeKind.UNKNOWN))
    }
    check_unary_expr(unary_node: UnaryExpressionNode): UnaryExpression {
        op = unary_node.op
        expression = this.check_expression(unary_node.expression)
        ty = expression.value_type
        if op == UnaryOp.NEG {
            if is_numeric(ty)
                return new UnaryExpression(op, expression, ty)
        }
        if op == UnaryOp.NOT {
            if is_bool(ty)
                return new UnaryExpression(op, expression, ty)
        }
        //TODO: Resolve type
        return new UnaryExpression(op, expression, new Type(TypeKind.UNKNOWN))
    }
    check_type_expr(type_expr_node: TypeExpressionNode): TypeExpression {
        // Need to check if cast is compatible for typecase
        exp = this.check_expression(type_expr_node.expression)
        ty = this.check_type(type_expr_node.bound_type)
        return new TypeExpression(exp, type_expr_node.op, ty)
    }
    check_new_expr(new_expr_node: NewExpressionNode): NewExpression {
        return new NewExpression()
    }   
    check_member_expr(member_expr_node: MemberExpressionNode): MemberExpression {
        return new MemberExpression()
    }
    check_index_expr(index_expr_node: ExpressionIndexNode): IndexExpression {
        return new IndexExpression()
    }
    check_call_expr(call_expr_node: CallExpressionNode): CallExpression {
        called = this.check_expression(call_expr_node.callee)
        //TODO: Check for generic functions.
        func_ty = called.value_type as FunctionType
        args: Array<Expression> = []
        if func_ty.kind == TypeKind.FNC {
            //TODO: fill default args.
            if func_ty.arg_types.length == call_expr_node.args.length {
                for i = 0; i < call_expr_node.args.length; ++i {
                    arg = this.check_expression(call_expr_node.args[i])
                    if arg.value_type == func_ty.arg_types[i]
                        args << arg
                    // TODO: Emit error if argument types do not match.(else)
                }
            }
            //TODO: Emit Error if args length do not match. (else)
        }
        //TODO: Emit Type Error(else)
        return new CallExpression(called, args, func_ty.return_type)
    }
    check_expression(expr_node: ExpressionNode): Expression {
        if expr_node.expr_kind == ExpressionKind.INT
            return new IntExpression((expr_node as IntExpressionNode).value.value)
        if expr_node.expr_kind == ExpressionKind.FLOAT
            return new FloatExpression((expr_node as FloatExpressionNode).value.value)
        if expr_node.expr_kind == ExpressionKind.CHAR {
            expr_value = new IntExpression((expr_node as CharExpressionNode).value.value as int)
            expr_value.value_type.kind = TypeKind.I8
            return expr_value
        }
        if expr_node.expr_kind == ExpressionKind.STR
            return new StringExpression((expr_node as StringExpressionNode).value.value)
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.VAR
            return this.check_var_access(expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TYPEBOUND
            return this.check_type_expr(expr_node as TypeExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MEMBER
            return this.check_member_expr(expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expr_node as ExpressionIndexNode)
        /* if expr_node.expr_kind == ExpressionKind.CALL */
        return this.check_call_expr(expr_node as CallExpressionNode)
    }
    check_if_stamement(if_stmt_node: IfStatementNode): IfStatement {
        return new IfStatement()
    }
    check_var_declaration(var_decl: VarDeclarationStatement): VarDeclaration {
        return new VarDeclaration()
    }
    check_for_statement(for_stmt_node: ForStatementNode): ForStatement {
        return new ForStatement()
    }
    check_while_statment(while_stmt_node: WhileStatementNode): WhileStatement {
        return new WhileStatement()
    }
    check_can_break(): Statement {
        //TODO: check if we are in a loop
        return new Statement(StatementKind.BREAK)
    }
    check_can_continue(): Statement {
        //TODO: check if we are in a loop
        return new Statement(StatementKind.CONTINUE)
    }
    check_can_return(expr: Optional<ExpressionNode>): ReturnStatement {
        //TODO: check if we are in a function.
        //TODO: check if return type matches
        rt_stmt = new ReturnStatement()
        if expr.has_value 
            rt_stmt.return_value.set_value(this.check_expression(expr.value))
        return rt_stmt
    }
    check_statement(stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue()
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break()
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode).value)
        return this.check_expression(stmt_node as ExpressionNode)
    }
    check_block(block_node: BlockNode): Block {
        block = new Block()
        for i = 0; i < block_node.statements.length; i++ {
            // TODO: check control flow and look for always return in the case of a function.
            block.statements << this.check_statement(block_node.statements[i])
        }
        return block
    }
}