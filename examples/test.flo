class IntCMP {
    protected __cmp__(this, other: Int): int
    public __eq__(this, other: Int): bool {
        return this.__cmp__(other) == 0
    }
    public __ne__(this, other: Int): bool {
        return this.__cmp__(other) != 0
    }
    public __lt__(this, other: Int): bool {
        return this.__cmp__(other) < 0
    }
    public __gt__(this, other: Int): bool {
        return this.__cmp__(other) > 0
    }
    public __le__(this, other: Int): bool {
        return this.__cmp__(other) <= 0
    }
    public __ge__(this, other: Int): bool {
        return this.__cmp__(other) >= 0
    }
}
class Int(IntCMP) {
    private value: int
    constructor(this, value: int){
        this.value = value
    }
    public __add__(this, other: Int): Int {
        let v: Int(this.value + other.value)
        return v
    }
    public __sub__(this, other: Int): Int {
        let v: Int(this.value - other.value)
        return v
    }
    public __mul__(this, other: Int): Int {
        let v: Int(this.value - other.value)
        return v
    }
    public __div__(this, other: Int): Int {
        let v: Int(this.value / other.value)
        return v
    }
    public __pow__(this, other: Int): Int {
        let v: Int((this.value ^ other.value) as int)
        return v
    }
    public __getitem__(this, index: int): int {
        return this.value
    }
    public __setitem__(this, index: int, value: int) {
        this.value = value
    }
    protected __cmp__(this, other: Int): int {
        return this.value - other.value
    }
}
fnc main(): int {
    let x: Int(4)
    let y: Int(7)
    let z: Int = null
    if x > y {
        z = x - y
    } else {
        z = y - x
    }
    return z[0]
}