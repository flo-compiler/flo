enum TokType {
    COL
    SEMICOL
    COMMA
    PLUS
    PLUS_PLUS
    MINUS
    MINUS_MINUS
    MULT
    DIV
    LPAR
    RPAR
    MOD
    LBRACE
    RBRACE
    LBRACKET
    RBRACKET
    INT
    FLOAT
    LN
    STR
    CHAR
    POW
    QUES
    AMP
    EQ
    EEQ
    NEQ
    GT
    LT
    LTE
    GTE
    LEQ
    ARROW
    EOF
    NOT
    SL
    SR
    DOT
    DOT_DOT
    DOT_DOT_DOT
    IDENTIFER
    AND_KW
    OR_KW
    XOR_KW
    CONST_KW
    IF_KW
    ELSE_KW
    BOOL_KW
    I4_KW
    I8_KW
    I16_KW
    I32_KW
    I64_KW
    I128_KW
    INT_KW
    F16_KW
    F32_KW
    F64_KW
    FLOAT_KW
    VOID_KW
    FOR_KW
    WHILE_KW
    FNC_KW
    BREAK_KW
    CONTINUE_KW
    RETURN_KW
    IMPORT_KW
    TYPE_KW
    FROM_KW
    IN_KW
    CLASS_KW
    ENUM_KW
    NEW_KW
    AS_KW
    IS_KW
    EXTENDS_KW
}
fnc string_to_kw_token(word: string): TokType {
    if word == "and"
        return TokType.AND_KW
    if word == "or"
        return TokType.OR_KW
    if word == "xor"
        return TokType.XOR_KW
    if word == "const"
        return TokType.CONST_KW
    if word == "if"
        return TokType.IF_KW
    if word == "else"
        return TokType.ELSE_KW
    if word == "bool"
        return TokType.BOOL_KW
    if word == "i4"
        return TokType.I4_KW
    if word == "i8"
        return TokType.I8_KW
    if word == "i16"
        return TokType.I16_KW
    if word == "i32"
        return TokType.I32_KW
    if word == "i64"
        return TokType.I64_KW
    if word == "i128"
        return TokType.I128_KW
    if word == "int"
        return TokType.INT_KW
    if word == "f16"
        return TokType.F16_KW
    if word == "f32"
        return TokType.F32_KW
    if word == "f64"
        return TokType.F64_KW
    if word == "float"
        return TokType.FLOAT_KW
    if word == "void"
        return TokType.VOID_KW
    if word == "for"
        return TokType.FOR_KW
    if word == "while"
        return TokType.WHILE_KW
    if word == "fnc"
        return TokType.FNC_KW
    if word == "break"
        return TokType.BREAK_KW
    if word == "continue"
        return TokType.CONTINUE_KW
    if word == "return"
        return TokType.RETURN_KW
    if word == "import"
        return TokType.IMPORT_KW
    if word == "type"
        return TokType.TYPE_KW
    if word == "from"
        return TokType.FROM_KW
    if word == "in"
        return TokType.IN_KW
    if word == "class"
        return TokType.CLASS_KW
    if word == "enum"
        return TokType.ENUM_KW
    if word == "new"
        return TokType.NEW_KW
    if word == "as"
        return TokType.AS_KW
    if word == "is"
        return TokType.IS_KW
    if word == "extends"
        return TokType.EXTENDS_KW
    return -1
}
fnc is_identifier_char(char: i8): bool {
    return (char >= 'A' and char <= 'Z') or (char >= 'a' and char <= 'z') or (char == '_')
}
fnc is_number_char(char: i8): bool {
    return (char >= '0' and char <= '9')
}
class Token {
    ttype: TokType
    range: Range
    constructor(ttype: TokType, range: Range){
        this.ttype = ttype
        this.range = range
    }
}
fnc token_value(token: Token, text: string): string {
    return text.substring(token.range.start, token.range.end - token.range.start)
}

class Lexer {
    current_char: i8
    text: string
    errors: Array<FloError>
    idx: int
    constructor(text: string, errors: Array<FloError>){
        this.idx = -1
        this.text = text
        this.errors = errors
    }
    eof(): bool{
        return this.idx >= this.text.length
    }
    peek(offset = 1): i8 {
        if this.idx + offset < this.text.length 
            return this.text.get_byte(this.idx + offset)
        return '\0'
    }
    advance(){
        this.current_char = this.text.get_byte(++this.idx)
    }
    get_range(back: int): Range {
        return new Range(this.idx - back + 1, this.idx + 1)
    }
    plus_token(): Token {
        if this.peek() == '+' {
            this.advance()
            return new Token(TokType.PLUS_PLUS, this.get_range(2))
        }
        return new Token(TokType.PLUS, this.get_range(1))
    }
    skip_comment(): bool{
        if this.peek() == '*' {
            this.advance()
            while this.peek() != '*' and this.peek(2) != '/'
                this.advance()
            this.advance()
            this.advance()
            return true
        } else if this.peek() == '/' {
            this.advance()
            while this.peek() != '\n'
                this.advance()
            return true
        }
        return false
    }
    minus_token(): Token{
        if this.peek() == '-' {
            this.advance()
            return new Token(TokType.MINUS_MINUS, this.get_range(2))
        }
        return new Token(TokType.MINUS, this.get_range(2))
    }
    eq_token(): Token {
        if this.peek() == '='{
            this.advance()
            return new Token(TokType.EEQ, this.get_range(2))
        } 
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.ARROW, this.get_range(2))
        }
        return new Token(TokType.EQ, this.get_range(1))
    }
    neq_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.NEQ, this.get_range(2))
        }
        return new Token(TokType.NOT, this.get_range(1))
    }
    gt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.GTE, this.get_range(2))
        }
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.SR, this.get_range(2))
        }
        return new Token(TokType.GT, this.get_range(1))
    }
    lt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.LEQ, this.get_range(2))
        }
        else if this.peek() == '<' {
            this.advance()
            return new Token(TokType.SL, this.get_range(2))
        }
        return new Token(TokType.LT, this.get_range(1))
    }
    dot_token(): Token {
        token = TokType.DOT
        length = 1
        if this.peek() == '.'{
            token = TokType.DOT_DOT
            length++
            this.advance()
            if this.peek() == '.' {
                token = TokType.DOT_DOT_DOT
                length++
                this.advance()
            }
        }
        return new Token(token, this.get_range(length))
    }
    numeric_token(): Token {
        length = 1
        token = TokType.INT
        while is_number_char(next_char = this.peek()) or next_char == '.' {
            if next_char == '.' and (token == TokType.FLOAT or !is_number_char(this.peek(2))) break
            if this.current_char == '.' 
                token = TokType.FLOAT
            length++
            this.advance()
        }
        return new Token(token, this.get_range(length))
    }
    identifier_token(): Token {
        length = 1
        start = this.idx
        while is_identifier_char(next_char = this.peek()) or is_number_char(next_char){
            length++
            this.advance()
        }
        token = new Token(TokType.IDENTIFER, this.get_range(length))
        ttype = string_to_kw_token(token_value(token, this.text))
        if ttype != -1 return new Token(ttype, token.range)
        return token
    }
    string_token(): Token {
        length = 2
        this.advance()
        while this.current_char != '"' {
            length++
            this.advance()
        }
        return new Token(TokType.STR, this.get_range(length))
    }
    char_token(): Token {
        length = 3
        this.advance()
        if this.current_char == '\\' {
            this.advance()
            length+=2
        }
        this.advance()
        return new Token(TokType.CHAR, this.get_range(length))
    }
    tokenize(): Array<Token> {
        this.advance()
        tokens: Array<Token> = []
        while !this.eof() and this.errors.length == 0 {
            char = this.current_char
            if char == ' ' true
            else if is_identifier_char(char)
                tokens << this.identifier_token()
            else if char == '"'
                tokens << this.string_token()
            else if is_number_char(char)
                tokens << this.numeric_token()
            else if char == ':' 
                tokens << new Token(TokType.COL, this.get_range(1))
            else if char == ';'
                tokens << new Token(TokType.SEMICOL, this.get_range(1))
            else if char == ','
                tokens << new Token(TokType.COMMA, this.get_range(1))
            else if char == '+'
                tokens << this.plus_token()
            else if char == '-'
                tokens << this.minus_token()
            else if char == '*'
                tokens << new Token(TokType.MULT, this.get_range(1))
            else if char == '('
                tokens << new Token(TokType.LPAR, this.get_range(1))
            else if char == ')'
                tokens << new Token(TokType.RPAR, this.get_range(1))
            else if char == '%'
                tokens << new Token(TokType.MOD, this.get_range(1))
            else if char == '{'
                tokens << new Token(TokType.LBRACE, this.get_range(1))
            else if char == '}'
                tokens << new Token(TokType.RBRACE, this.get_range(1))
            else if char == '['
                tokens << new Token(TokType.LBRACKET, this.get_range(1))
            else if char == ']'
                tokens << new Token(TokType.RBRACKET, this.get_range(1))
            else if char == '\n' or char == '\r'
                tokens << new Token(TokType.LN, this.get_range(1))
            else if char == '\''
                tokens << this.char_token()
            else if char == '^'
                tokens << new Token(TokType.POW, this.get_range(1))
            else if char == '?'
                tokens << new Token(TokType.QUES, this.get_range(1))
            else if char == '&'
                tokens << new Token(TokType.AMP, this.get_range(1))
            else if char == '='
                tokens << this.eq_token()
            else if char == '!'
                tokens << this.neq_token()
            else if char == '>'
                tokens << this.gt_token()
            else if char == '<'
                tokens << this.lt_token()
            else if char == '.'
                tokens << this.dot_token()
            else if char == '/' {
                if (!this.skip_comment())
                    tokens << new Token(TokType.DIV, this.get_range(1))
            } else {
                end = this.idx + 1
                this.errors << new FloError("Illegal character:", this.idx..end)
            }
            this.advance()
        }
        tokens << new Token(TokType.EOF, 0..0)
        return tokens
    }
}