class ICMP {
    protected __cmp__(this, other: ICMP): int
    public __eq__(this, other: Int): bool {
        return this.__cmp__(other) == 0
    }
    public __ne__(this, other: ICMP): bool {
        return this.__cmp__(other) != 0
    }
    public __lt__(this, other: ICMP): bool {
        return this.__cmp__(other) < 0
    }
    public __gt__(this, other: ICMP): bool {
        return this.__cmp__(other) > 0
    }
    public __le__(this, other: ICMP): bool {
        return this.__cmp__(other) <= 0
    }
    public __ge__(this, other: ICMP): bool {
        return this.__cmp__(other) >= 0
    }
}
class Int(ICMP) {
    private value: int
    constructor(this, value: int){
        this.value = value
    }
    public __add__(this, other: Int): Int {
        let v: Int(this.value + other.value)
        return v
    }
    public __sub__(this, other: Int): Int {
        let v: Int(this.value - other.value)
        return v
    }
    public __mul__(this, other: Int): Int {
        let v: Int(this.value - other.value)
        return v
    }
    public __div__(this, other: Int): Int {
        let v: Int(this.value / other.value)
        return v
    }
    public __pow__(this, other: Int): Int {
        let v: Int((this.value ^ other.value) as int)
        return v
    }
    public __getitem__(this, index: int): int {
        return this.value
    }
    public __setitem__(this, index: int, value: int) {
        this.value = value
    }
    public make(value: int): Int {
        let res: Int(value)
        return res
    }
    protected __cmp__(this, other: Int): int {
        return this.value - other.value
    }
}
fnc main(): int {
    let x: Int(7)
    let y: Int(7)
    let z: ICMP
    if x == y {
        z = Int.make(2)
    } else if x > y {
        z = x - y
    } else {
        z = y - x
    }
    if z == null {
        return 0
    }
    let arr: ICMP[3] = [x, y, z]
    return (z as Int)[0]
}