import ARCH_WORD_SIZE in "@sys/lib"
import "@path/path"
import "types"
import Compiler in "compiler"
import panic, TextRange in "utils"
import FloError, ErrorKind in "error"
import Lexer, IdentifierToken in "lexer"
import "parser"
class Type {
    kind: TypeKind
    constructor(this, kind: TypeKind){
        this.kind = kind
    }
}
class IntType(Type){
    is_signed: bool
    constructor(this, ty: TypeKind, is_signed: bool){
        this.super(ty)
        this.is_signed = is_signed
    }
}
class PrimitiveTypes {
    unknown: Type = null
    bool: Type = null
    u4: Type = null
    u8: Type = null
    u16: Type = null
    u32: Type = null
    u64: Type = null
    u128: Type = null
    i4: Type = null
    i8: Type = null
    i16: Type = null
    i32: Type = null
    i64: Type = null
    i128: Type = null
    uint: Type = null
    int: Type = null
    f32: Type = null
    f64: Type = null
    void: Type = null
    init(){
        PrimitiveTypes.u4 = new IntType(TypeKind.I4, false)
        PrimitiveTypes.u8 = new IntType(TypeKind.I8, false)
        PrimitiveTypes.u16 = new IntType(TypeKind.I16, false)
        PrimitiveTypes.u32 = new IntType(TypeKind.I32, false)
        PrimitiveTypes.u64 = new IntType(TypeKind.I64, false)
        PrimitiveTypes.u128 = new IntType(TypeKind.I128, false)
        PrimitiveTypes.uint = new IntType(TypeKind.INT, false)
        PrimitiveTypes.i4 = new IntType(TypeKind.I4, true)
        PrimitiveTypes.i8 = new IntType(TypeKind.I8, true)
        PrimitiveTypes.i16 = new IntType(TypeKind.I16, true)
        PrimitiveTypes.i32 = new IntType(TypeKind.I32, true)
        PrimitiveTypes.i64 = new IntType(TypeKind.I64, true)
        PrimitiveTypes.i128 = new IntType(TypeKind.I128, true)
        PrimitiveTypes.int = new IntType(TypeKind.INT, true)
        PrimitiveTypes.bool = new Type(TypeKind.BOOL)
        PrimitiveTypes.f32 = new Type(TypeKind.F32)
        PrimitiveTypes.f64 = new Type(TypeKind.F64)
        PrimitiveTypes.void = new Type(TypeKind.VOID)
        PrimitiveTypes.unknown = new Type(TypeKind.UNKNOWN)
    }
}
class PointerType (Type) {
    pointee_type: Type
    constructor(this, pointee_type: Type){
        this.super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType (Type) {
    has_implicit_this: bool
    arg_types: Type[]
    return_type: Type
    constructor(this, has_implicit_this: bool, arg_types: Type[], return_type: Type){
        this.super(TypeKind.FNC)
        this.has_implicit_this = has_implicit_this
        this.arg_types = arg_types
        this.return_type = return_type
    }
}
class TupleType (Type) {
    element_types: Type[]
    constructor(this){
        this.super(TypeKind.TUPLE)
        this.element_types = []
    }
}
class Statement {
    kind: StatementKind
    constructor(this, kind: StatementKind){
        this.kind = kind
    }
}
class TypeId {
    module_id: uint
    kind: TypeIdKind
    id: uint
    constructor(this, module_id: uint, kind: TypeIdKind, id: uint){
        this.module_id = module_id
        this.kind = kind
        this.id =  id
    }
}
class ClassId(TypeId) {
    constructor(this, module_id: uint, id: uint){
        this.super(module_id, TypeIdKind.CLASS, id)
    }
}
class EnumId(TypeId) {
    constructor(this, module_id: uint, id: uint){
        this.super(module_id, TypeIdKind.ENUM, id)
    }
}
class Expression (Statement) {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    range: TextRange
    constructor(this, expr_kind: ExpressionKind, value_type: Type, range: TextRange){
        this.super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.value_type = value_type
        this.range = range
        this.is_constant = false
    }
}
class ArrayType (Type) {
    element_type: Type
    length: uint
    constructor(this, element_type: Type, length: uint){
        this.super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
}
class GenericType(Type) {
    name: String
    arg_types: Type[]
    instantiated_type: Type
    constructor(this, name: String, arg_types: Type[], instantiated_type: Type){
        this.super(TypeKind.RESOLVED_GENERIC)
        this.name = name
        this.arg_types = arg_types
        this.instantiated_type = instantiated_type
    }
}
class ObjectType (Type) {
    class_id: ClassId
    constructor(this, class_id: ClassId){
        this.super(TypeKind.OBJECT)
        this.class_id = class_id
    }
}
class EnumType (Type) {
    enum_id: EnumId
    constructor(this, enum_id: EnumId){
        this.super(TypeKind.ENUM)
        this.enum_id = enum_id
    }
}
class IntExpression (Expression) {
    value: u64
    constructor(this, value: u64, range: TextRange){
        this.super(ExpressionKind.INT, PrimitiveTypes.uint, range)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression (Expression) {
    value: bool 
    constructor(this, value: bool, range: TextRange){
        this.super(ExpressionKind.BOOL, PrimitiveTypes.bool, range)
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression (Expression) {
    value: f64
    constructor(this, value: f64, range: TextRange){
        this.super(ExpressionKind.FLOAT, PrimitiveTypes.f64, range)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression (Expression) {
    value: String
    fmt_indices: uint[]
    template_args: Expression[]
    constructor(this, value: String, fmt_indices: uint[], template_args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.STRING, value_type, range)
        this.template_args = template_args
        this.fmt_indices = fmt_indices
        this.value = value
        this.is_constant = true
    }
}
class NullExpression (Expression) {
    constructor(this, value_type: Type, range: TextRange){
        this.super(ExpressionKind.NULL, value_type, range)
        this.is_constant = true
    }
}
class ArrayExpression (Expression) {
    elements: Expression[]
    constructor(this, elements: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.ARRAY, value_type, range)
        this.elements = elements
    }
}
class TupleExpression (Expression) {
    elements: Expression[]
    constructor(this, elements: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.TUPLE, value_type, range)
        this.elements = elements
    }
}
class BinaryExpression (Expression) {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(this, lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type, range: TextRange, is_constant = false){
        this.super(ExpressionKind.BIN, value_type, range)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.is_constant = is_constant
    }
}
class UnaryExpression (Expression) {
    op: UnaryOp
    expression: Expression
    constructor(this, op: UnaryOp, expression: Expression, value_type: Type, range: TextRange, is_constant = false){
        this.super(ExpressionKind.UNARY, value_type, range)
        this.op = op
        this.expression = expression
        this.is_constant = is_constant
    }
}
class TernaryExpression (Expression) {
    cond: Expression
    is_true: Expression
    is_false: Expression
    constructor(this, cond: Expression, is_true: Expression, is_false: Expression){
        this.super(ExpressionKind.TERNARY, is_true.value_type, TextRange.merge(cond.range, is_false.range))
        this.cond = cond
        this.is_true = is_true
        this.is_false = is_false
    }
}
class TypeCastExpression (Expression) {
    expr: Expression
    constructor(this, expr: Expression, value_type: Type, range: TextRange){
        this.super(ExpressionKind.CAST, value_type, range)
        this.expr = expr
        this.is_constant = expr.is_constant
    }
}
class NewExpression (Expression) {
    args: Expression[]
    onheap: bool
    memory_type: Type
    constructor(this, onheap: bool, memory_type: Type, args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.NEW, value_type, range)
        this.memory_type = memory_type
        this.onheap = onheap
        this.args = args
    }
}
class RangeExpression (Expression) {
    left: Expression
    right: Expression
    constructor(this, left: Expression, right: Expression, value_type: Type){
        this.super(ExpressionKind.RANGE, value_type, TextRange.merge(left.range, right.range))
        this.left = left
        this.right = right
    }
}
class IndexExpression (Expression) {
    expression: Expression
    index: Expression
    constructor(this, expression: Expression, index: Expression, value_type: Type, range: TextRange){
        this.super(ExpressionKind.INDEX, value_type, range)
        this.expression = expression
        this.index = index
        this.value_type = value_type
    }
}
class CallExpression (Expression) {
    callee: Expression
    args: Expression[]
    constructor(this, callee: Expression, args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.CALL, value_type, range)
        this.callee = callee
        this.args = args
    }
}
class IntrinsicCall (Expression) {
    intrinsic: Intrinsics
    args: Expression[]
    constructor(this, intrinsic: Intrinsics, return_type: Type, range: TextRange){
        this.super(ExpressionKind.INTRINSIC, return_type, range)
        this.intrinsic = intrinsic
        this.args = []
    }
}
class VarId {
    kind: VarIdKind
    module_id: uint
    id: uint
    constructor(this, kind: VarIdKind, module_id: uint, id: uint){
        this.kind = kind
        this.module_id = module_id
        this.id = id
    }
}
class ClassVarId(VarId){
    constructor(this, class_id: ClassId){
        this.super(VarIdKind.CLASS, class_id.module_id, class_id.id)
    }
    public to_class_id(var_id: VarId): ClassId {
        return new ClassId(var_id.module_id, var_id.id)
    }
}
class EnumVarId(VarId){
    constructor(this, enum_id: EnumId){
        this.super(VarIdKind.ENUM, enum_id.module_id, enum_id.id)
    }
    public to_enum_id(var_id: VarId): EnumId {
        return new EnumId(var_id.module_id, var_id.id)
    }
}
class PropId {
    kind: PropIdKind
    type_id: TypeId
    id: uint
    constructor(this, kind: PropIdKind, type_id: TypeId, id: uint){
        this.kind = kind
        this.type_id = type_id
        this.id = id
    }
}
class MemberExpression (Expression) {
    expression: Expression
    member_id: PropId
    constructor(this, expression: Expression, member_id: PropId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.MEMBER, value_type, range)
        this.expression = expression
        this.member_id = member_id
    }
}
class VarAccessExpression (Expression) {
    value_id: VarId
    constructor(this, value_id: VarId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.ACCESS, value_type, range)
        this.value_id = value_id
        this.is_constant = value_id.kind == VarIdKind.CONST
    }
}
class Block {
    statements: Statement[]
    returns: bool /* Block contains a return */
    continues: bool /* Block contains a continue */
    breaks: bool /* Block contains a break */
    yields: Expression
    range: TextRange
    constructor(this, range: TextRange){
        this.range = range
        this.statements = []
        this.returns = false
        this.continues = false
        this.breaks = false
        this.yields = null
    }
    is_terminated(this): bool {
        return this.returns or this.continues or this.breaks
    }
}
class MatchExpressionCase {
    kind: MatchCaseKind
    condition: Expression
    block: Block
    constructor(this, kind: MatchCaseKind, condition: Expression, block: Block){
        this.kind = kind
        this.condition = condition
        this.block = block
    }
}
class MatchExpression(Expression){
    subject: Expression
    cases: MatchExpressionCase[]
    else_block: Block
    use_ifs: bool
    constructor(this, subject: Expression, use_ifs: bool){
        this.super(ExpressionKind.MATCH, PrimitiveTypes.void, subject.range) //TODO: Figure out if this is the best decision
        this.subject = subject
        this.use_ifs = use_ifs
        this.cases = []
        this.else_block = null
    }
}
class IfStatement (Statement) {
    condition: Expression
    block: Block
    else_block: Block
    constructor(this, condition: Expression, block: Block, else_block: Block){
        this.super(StatementKind.IF)
        this.condition = condition
        this.block = block
        this.else_block = else_block
    }
}
class VarDeclaration (Statement) {
    name: String
    var_id: VarId
    is_static: bool
    range: TextRange
    constructor(this, range: TextRange, name: String, var_id: VarId){
        this.super(StatementKind.VAR)
        this.range = range
        this.var_id = var_id
        this.name = name
        this.is_static = false
    }
}
class ForInStatement (Statement) {
    it_var: VarDeclaration
    iterator: Expression
    block: Block
    constructor(this, it_var: VarDeclaration, iterator: Expression, block: Block){
        this.super(StatementKind.FOR_IN)
        this.it_var = it_var
        this.iterator = iterator
        this.block = block
    }
}
class ForStatement (Statement) {
    initialization: Statement
    condition: Expression
    update: Expression
    block: Block
    constructor(this){
        this.super(StatementKind.FOR)
        this.initialization = null
        this.condition = null
        this.update = null
    }
}
class WhileStatement (Statement) {
    condition: Expression
    block: Block
    constructor(this, condition: Expression, block: Block){
        this.super(StatementKind.WHILE)
        this.condition = condition
        this.block = block
    }
}
class ReturnStatement (Statement) {
    return_value: Expression
    constructor(this){
        this.super(StatementKind.RETURN)
        this.return_value = null
    }
}
fnc is_numeric(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.F64
}
fnc is_float(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.F32 and val_ty.kind <= TypeKind.F64
}
fnc is_int(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.I128
}
fnc is_bool(val_ty: Type): bool {
    return val_ty.kind == TypeKind.BOOL
}
fnc is_u8_ptr(val_ty: Type): bool {
    if val_ty.kind == TypeKind.PTR {
        let pointee_type = (val_ty as PointerType).pointee_type
        if is_int(pointee_type) {
            return (pointee_type.kind == TypeKind.I8) and !((pointee_type as IntType).is_signed)
        }
    }
    return false
}
fnc is_object(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.RESOLVED_GENERIC)
        return is_object((val_ty as GenericType).instantiated_type)
    return val_ty.kind == TypeKind.OBJECT
}
fnc is_function(val_ty: Type): bool {
    return val_ty.kind == TypeKind.FNC
}
fnc is_pointer(val_ty: Type): bool {
    return val_ty.kind == TypeKind.PTR
}
fnc is_null_expression(exp: Expression): bool {
    return exp.expr_kind == ExpressionKind.NULL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    return new TypeCastExpression(exp, val_ty, exp.range)
}
fnc max_type(t1: Type, t2: Type): Type {
    return t1.kind > t2.kind ? t1 : t2
}
fnc get_unsigned_int_variant(type: Type): Type {
    if (type.kind == TypeKind.I4) return PrimitiveTypes.u4
    if (type.kind == TypeKind.I8) return PrimitiveTypes.u8
    if (type.kind == TypeKind.I16) return PrimitiveTypes.u16
    if (type.kind == TypeKind.I32) return PrimitiveTypes.u32
    if (type.kind == TypeKind.I64) return PrimitiveTypes.u64
    if (type.kind == TypeKind.INT) return PrimitiveTypes.uint
    else return PrimitiveTypes.u128
}
fnc get_signed_int_variant(type: Type): Type {
    if (type.kind == TypeKind.I4) return PrimitiveTypes.i4
    if (type.kind == TypeKind.I8) return PrimitiveTypes.i8
    if (type.kind == TypeKind.I16) return PrimitiveTypes.i16
    if (type.kind == TypeKind.I32) return PrimitiveTypes.i32
    if (type.kind == TypeKind.I64) return PrimitiveTypes.i64
    if (type.kind == TypeKind.INT) return PrimitiveTypes.int
    else return PrimitiveTypes.i128
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    let ty1 = p1[0].value_type
    let ty2 = p2[0].value_type
    if ty1.kind != ty2.kind {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            if is_int(ty1) and is_int(ty2){
                if (ty1 as IntType).is_signed != (ty2 as IntType).is_signed {
                    ty1 = get_signed_int_variant(ty2)
                }
            }
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc check_is_var(expr: Expression): bool{
    if expr.expr_kind == ExpressionKind.ACCESS {
        return (expr as VarAccessExpression).value_id.kind == VarIdKind.VAR
    }
    if expr.expr_kind == ExpressionKind.MEMBER {
        let prop_id = (expr as MemberExpression).member_id
        return prop_id.kind == PropIdKind.FIELD
    }
    if expr.expr_kind == ExpressionKind.INDEX {
        return (expr as IndexExpression).expression.value_type.kind != TypeKind.TUPLE
    }
    return false
}
fnc dump_type(ty: Type, force_bit_size = false): String {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if is_int(ty){
        if force_bit_size return "i$ARCH_WORD_SIZE"
        let is_signed = (ty as IntType).is_signed
        if ty.kind == TypeKind.INT {
            return is_signed ? "int" : "uint"
        }
        let char = is_signed ? "i" : "u"
        if ty.kind == TypeKind.I4
            return "$(char)4" 
        if ty.kind == TypeKind.I8
            return "$(char)8"
        if ty.kind == TypeKind.I16
            return "$(char)16"
        if ty.kind == TypeKind.I32
            return "$(char)32"
        if ty.kind == TypeKind.I64
            return "$(char)64"
        if ty.kind == TypeKind.I128
            return "$(char)128"
    }
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.VOID
        return "void"
    if ty.kind == TypeKind.RECORD
        return "record"
    return "unknown"
}
fnc dump_bin_op(op: BinaryOp): String {
    if op == BinaryOp.ADD
        return "+"
    if op == BinaryOp.SUB
        return "-"
    if op == BinaryOp.MUL
        return "*"
    if op == BinaryOp.DIV
        return "/"
    if op == BinaryOp.MOD
        return "**"
    if op == BinaryOp.POW
        return "^"
    if op == BinaryOp.GT
        return ">"
    if op == BinaryOp.GTE
        return ">="
    if op == BinaryOp.LT
        return "<"
    if op == BinaryOp.LTE
        return "<="
    if op == BinaryOp.EEQ
        return "=="
    if op == BinaryOp.NEQ
        return "!="
    if op == BinaryOp.SL
        return "<<"
    if op == BinaryOp.SR
        return ">>"
    if op == BinaryOp.OR
        return "or"
    if op == BinaryOp.AND
        return "and"
    if op == BinaryOp.XOR
        return "^"
    if op == BinaryOp.IN
        return "in"
    if op == BinaryOp.ASSIGN
        return "="
    return "<unknown>"
}
fnc dump_unary_op(op: UnaryOp): String{
    if op == UnaryOp.PREINCR
        return "++(pre)"
    if op == UnaryOp.PREDECR
        return "--(pre)"
    if op == UnaryOp.POSTINCR
        return "(post)++"
    if op == UnaryOp.POSTDECR
        return "(post)--"
    if op == UnaryOp.NEG
        return "-"
    if op == UnaryOp.NOT
        return "!"
    return "&"
}
fnc dump_access(visibility: ACCESS_ATTR): String {
    if visibility == ACCESS_ATTR.PRIVATE
        return "private"
    if visibility == ACCESS_ATTR.PUBLIC
        return "public"
    return "protected"
}
fnc lower_bin_assign_node(binary_node: BinaryExpressionNode): BinaryExpressionNode {
    let op = binary_node.op
    if op == BinaryOp.ADD_ASSIGN
        op = BinaryOp.ADD
    if op == BinaryOp.SUB_ASSIGN
        op = BinaryOp.SUB
    if op == BinaryOp.MUL_ASSIGN
        op = BinaryOp.MUL
    if op == BinaryOp.DIV_ASSIGN
        op = BinaryOp.DIV
    if op == BinaryOp.MOD_ASSIGN
        op = BinaryOp.MOD
    if op == BinaryOp.POW_ASSIGN
        op = BinaryOp.POW
    if op == BinaryOp.AND_ASSIGN
        op = BinaryOp.AND
    if op == BinaryOp.OR_ASSIGN
        op = BinaryOp.OR
    if op == BinaryOp.SL_ASSIGN
        op = BinaryOp.SL
    if op == BinaryOp.SR_ASSIGN
        op = BinaryOp.SR
    return new BinaryExpressionNode(binary_node.lhs, op, binary_node.rhs)
}
class ScopeId {
    module_id: uint
    id: uint
    constructor(this, module_id: uint, id: uint){
        this.module_id = module_id
        this.id = id
    }
}
class ModuleVarId(VarId){
    scope_id: ScopeId
    constructor(this, scope_id: ScopeId){
        this.super(VarIdKind.MODULE, scope_id.module_id, scope_id.id)
        this.scope_id = scope_id
    }
}
class Scope {
    public id: ScopeId
    public vars: [String: VarId]
    public classes: [String: ClassId]
    public functions: [String: VarId]
    public enums: [String: EnumId]
    public parent: ScopeId
    public type_aliases: [String: Type]
    public children: ScopeId[]
    constructor(this, module_id: uint, id: uint){
        this.id = new ScopeId(module_id, id)
        this.vars = new [String: VarId]()
        this.classes = new [String: ClassId]()
        this.functions = new [String: VarId]()
        this.enums = new [String: EnumId]()
        this.type_aliases = new [String: Type]()
        this.parent = null 
        this.children = []
    }
    private __del__(this){
        del this.id
        del this.vars
        del this.classes
        del this.functions
        del this.enums
        del this.type_aliases
    }
}
class FunctionArg(Expression) {
    id: VarId
    name: String
    default: Expression
    constructor(this, name: String, value_type: Type, range: TextRange){
        this.super(ExpressionKind.ACCESS, value_type, range)
        this.name = name
    }
}
class Function {
    id: VarId
    name: String
    args: FunctionArg[]
    block: Block
    fnc_type: FunctionType
    scope: ScopeId
    is_external: bool
    definition_range: TextRange
    constructor(this, definition_range: TextRange){
        this.definition_range = definition_range
        this.is_external = false
    }
}
class Var {
    var_id: VarId
    value: Expression
    value_type: Type
    constructor(this, value: Expression, value_type: Type){
        this.value = value
        this.value_type = value_type
    }
}

class ClassField {
    id: PropId
    is_static: bool
    visibility: ACCESS_ATTR
    name: String
    field_type: Type
    field_offset: uint
    definition_range: TextRange
    initializer: Expression
    constructor(this){
        this.is_static = false
    }
}
class ClassMethod {
    id: PropId
    is_static: bool
    visibility: ACCESS_ATTR
    definition_range: TextRange
    name: String
    method_type: FunctionType
    block: Block
    args: FunctionArg []
    is_abstract: bool
    scope: ScopeId
    constructor(this, definition_range: TextRange){
        this.is_abstract = false
        this.definition_range = definition_range
    }
}
class Class {
    id: ClassId
    name: String
    parent: Type
    definition_range: TextRange
    constructor_id: PropId
    fields: ClassField[]
    methods: ClassMethod[]
    prop_map: [String: PropId]
    static_prop_map: [String: PropId]
    inherited_methods_num: uint
    inherited_fields_num: uint
    is_abstract: bool
    constructor(this){
        this.constructor_id = null
        this.inherited_fields_num = 0
        this.inherited_methods_num = 0
        this.fields = []
        this.methods = []
        this.prop_map = new [String: PropId]()
        this.static_prop_map = new [String: PropId]()
        this.is_abstract = false
    }
    private __del__(this){
        del this.id
        del this.name
        if this.parent del this.parent
        for field in this.fields {
            del field
        }
        for method in this.methods {
            del method
        }
        del this.prop_map
        del this.static_prop_map
    }
}
class EnumField {
    id: PropId
    name: String
    initializer: Expression
    constructor(this, name: String){
        this.name = name
    }
    private __del__(this){
        del this.id
        del this.name
        del this.initializer
    }
}
class Enum {
    id: EnumId
    name: String
    fields: EnumField[]
    definition_range: TextRange
    variant_type: Type
    field_map: [String: PropId]
    constructor(this){
        this.fields = []
        this.field_map = new [String: PropId]()
    }
    private __del__(this){
        del this.id
        del this.name
        for field in this.fields {
            del field
        }
        del this.fields
        del this.field_map
    }
}
class Module {
    name: String
    vars: Var[]
    classes: Class[]
    functions: Function[]
    scope: ScopeId
    enums: Enum[]
    scopes: Scope[]
    global_vars: VarDeclaration[]
    constructor(this, name: String){
        this.name = name
        this.functions = []
        this.vars = []
        this.classes = []
        this.enums = []
        this.scopes = []
        this.global_vars = []
    }
    private __del__(this){
        for func in this.functions {
            del func
        }
        for var in this.vars {
            del var
        }
        for mod_class in this.classes {
            del mod_class
        }
        for mod_enum in this.enums {
            del mod_enum
        }
        for global_var in this.global_vars {
            del global_var
        }
        del this.scopes[this.scope.id]
        del this.name
        del this.functions
        del this.vars
        del this.classes
        del this.enums
        del this.scopes
        del this.global_vars
    }
}
class Program {
    modules: Module[]
    builtin_scope: ScopeId
    constructor(this){
        this.modules = []
        this.builtin_scope = null
    }
    private __del__(this){
        for module in this.modules {
            del module
        }
        del this.modules
    }
    public get_var(this, var_id: VarId): Var {
        return this.modules[var_id.module_id].vars[var_id.id]
    }
    public get_func(this, func_id: VarId): Function {
        return this.modules[func_id.module_id].functions[func_id.id]
    }
    public get_scope(this, scope_id: ScopeId): Scope {
        return this.modules[scope_id.module_id].scopes[scope_id.id]
    }
    public get_class(this, type_id: ClassId): Class {
        return this.modules[type_id.module_id].classes[type_id.id]   
    }
    public get_class_from_type(this, type_: Type): Class {
        if type_.kind == TypeKind.RESOLVED_GENERIC
            return this.get_class_from_type((type_ as GenericType).instantiated_type)
        if type_.kind == TypeKind.OBJECT
            return this.get_class((type_ as ObjectType).class_id)
        return null
    }
    public get_enum(this, enum_id: EnumId): Enum {
        return this.modules[enum_id.module_id].enums[enum_id.id]
    }
    public get_enum_from_type(this, type_: Type): Enum {
        return this.get_enum((type_ as EnumType).enum_id)
    }
    public get_class_from_prop_id(this, prop_id: PropId): Class {
        return this.get_class(prop_id.type_id as ClassId)
    }
    public get_method(this, prop_id: PropId): ClassMethod {
        return this.get_class_from_prop_id(prop_id).methods[prop_id.id]
    }
    public get_class_prop_type(this, prop_id: PropId): Type {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return owner.methods[prop_id.id].method_type
        }
        return owner.fields[prop_id.id].field_type
    }
    public get_class_prop_type_with_name(this, obj_ty: ObjectType, name: String): Type {
        let obj_class = this.get_class_from_type(obj_ty)
        if (obj_class == null) return null 
        let prop_id = obj_class.prop_map[name]
        if (prop_id == null) return null 
        return this.get_class_prop_type(prop_id)
    }
    public get_class_prop_visibility(this, prop_id: PropId): ACCESS_ATTR {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return owner.methods[prop_id.id].visibility
        }
        return owner.fields[prop_id.id].visibility
    }
    public get_class_prop_name(this, prop_id: PropId): String {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return owner.methods[prop_id.id].name
        }
        return owner.fields[prop_id.id].name
    }
    public is_class_prop_static(this, prop_id: PropId): bool {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return owner.methods[prop_id.id].is_static
        }
        return owner.fields[prop_id.id].is_static
    }
    public is_buitin(this, ty: Type, name: String): bool {
        if !is_object(ty) return false
        let class_obj = this.get_class_from_type(ty)
        return class_obj.name == name and class_obj.id.module_id == this.builtin_scope.module_id
    }
    public get_field_offset(this, prop_id: PropId): uint {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return 1
        }
        return owner.fields[prop_id.id].field_offset
    }
    public get_class_prop_definition_range(this, prop_id: PropId): TextRange {
        let owner = this.get_class_from_prop_id(prop_id)
        if prop_id.kind == PropIdKind.METHOD {
            return owner.methods[prop_id.id].definition_range
        }
        return owner.fields[prop_id.id].definition_range
    }
}
fnc is_bin_op_comp_eq_op(op: BinaryOp): bool {
    if op == BinaryOp.EEQ
        return true
    if op == BinaryOp.NEQ
        return true
    return false
}
fnc is_bin_op_comp_op(op: BinaryOp): bool {
    if op == BinaryOp.GT
        return true
    if op == BinaryOp.LT
        return true
    if op == BinaryOp.GTE
        return true
    if op == BinaryOp.LTE
        return true
    return is_bin_op_comp_eq_op(op)
}
fnc is_operator_overload_name(name: String): bool {
    if name == "__eq__" return true
    if name == "__add__" return true
    if name == "__sub__" return true
    if name == "__mul__" return true
    if name == "__div__" return true
    if name == "__or__" return true
    if name == "__adda__" return true
    if name == "__suba__" return true
    if name == "__mula__" return true
    if name == "__diva__" return true
    if name == "__ora__" return true
    if name == "__anda__" return true
    if name == "__xora__" return true
    if name == "__getitem__" return true
    if name == "__setitem__" return true
    if name == "__sl__" return true
    if name == "__sr__" return true
    if name == "__sla__" return true
    if name == "__sra__" return true
    if name == "__in__" return true
    if name == "__lt__" return true
    if name == "__lg__" return true
    if name == "__ne__" return true
    if name == "__le__" return true
    if name == "__ge__" return true
    if name == "__pow__" return true
    if name == "__mod__" return true
    if name == "__powa__" return true
    if name == "__moda__" return true
    if name == "__iter__" return true
    if name == "__del__" return true
    return false
}
fnc bin_op_to_op_overload_name(op: BinaryOp): String {
    if op == BinaryOp.ADD return "__add__"
    if op == BinaryOp.SUB return "__sub__"
    if op == BinaryOp.MUL return "__mul__"
    if op == BinaryOp.DIV return "__div__"
    if op == BinaryOp.MOD return "__mod__"
    if op == BinaryOp.POW return "__pow__"
    if op == BinaryOp.ADD_ASSIGN return "__adda__"
    if op == BinaryOp.SUB_ASSIGN return "__suba__"
    if op == BinaryOp.MUL_ASSIGN return "__mula__"
    if op == BinaryOp.DIV_ASSIGN return "__diva__"
    if op == BinaryOp.MOD_ASSIGN return "__moda__"
    if op == BinaryOp.POW_ASSIGN return "__powa__"
    if op == BinaryOp.GT return "__gt__"
    if op == BinaryOp.GTE return "__ge__"
    if op == BinaryOp.LT return "__lt__"
    if op == BinaryOp.LTE return "__le__"
    if op == BinaryOp.EEQ return "__eq__"
    if op == BinaryOp.NEQ return "__ne__"
    if op == BinaryOp.SL return "__sl__"
    if op == BinaryOp.SR return "__sr__"
    if op == BinaryOp.SL_ASSIGN return "__sla__"
    if op == BinaryOp.SR_ASSIGN return "__sra__"
    if op == BinaryOp.OR return "__or__"
    if op == BinaryOp.AND return "__and__"
    if op == BinaryOp.XOR return "__xor__"
    if op == BinaryOp.AND_ASSIGN return "__anda__"
    if op == BinaryOp.XOR_ASSIGN return "__xora__"
    if op == BinaryOp.IN return "__in__"
    return null
}
fnc evaluate_const_int_expression(program: Program, exp: Expression): int {
    if exp.expr_kind == ExpressionKind.INT {
        return (exp as IntExpression).value as int
    }
    if exp.expr_kind == ExpressionKind.FLOAT
        return (exp as FloatExpression).value as int
    if exp.expr_kind == ExpressionKind.BIN {
        let bin_exp = exp as BinaryExpression
        if bin_exp.op == BinaryOp.ADD
            return evaluate_const_int_expression(program, bin_exp.lhs) + evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SUB
            return evaluate_const_int_expression(program, bin_exp.lhs) - evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MUL
            return evaluate_const_int_expression(program, bin_exp.lhs) * evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.DIV
            return evaluate_const_int_expression(program, bin_exp.lhs) / evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MOD
            return evaluate_const_int_expression(program, bin_exp.lhs) % evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SL
            return evaluate_const_int_expression(program, bin_exp.lhs) << evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SR
            return evaluate_const_int_expression(program, bin_exp.lhs) >> evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.OR
            return evaluate_const_int_expression(program, bin_exp.lhs) or evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.AND
            return evaluate_const_int_expression(program, bin_exp.lhs) and evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.XOR
            return evaluate_const_int_expression(program, bin_exp.lhs) ^ evaluate_const_int_expression(program, bin_exp.rhs)
    }
    if exp.expr_kind == ExpressionKind.UNARY {
        let unary_exp = exp as UnaryExpression
        if unary_exp.op == UnaryOp.NEG
            return -evaluate_const_int_expression(program, unary_exp.expression)
        if unary_exp.op == UnaryOp.NOT
            return !evaluate_const_int_expression(program, unary_exp.expression)
    }
    if exp.expr_kind == ExpressionKind.ACCESS {
        let var_exp = exp as VarAccessExpression
        return evaluate_const_int_expression(program, program.get_var(var_exp.value_id as VarId).value)
    }
    return -99999999
}
class Generic {
    module_id: uint
    template: ClassDeclarationNode
    constructor(this, module_id: uint, template: ClassDeclarationNode){
        this.module_id = module_id
        this.template = template
    }
}
let GENERIC_MODULE_ID = 0
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    private program: Program
    private current_class: ClassId
    private current_function: VarId
    private current_method: PropId
    private current_scope: ScopeId
    private compiler: Compiler
    private in_loop: bool
    private module_contains_generics: bool
    private generic_templates: [String: Generic]
    constructor(this, compiler: Compiler){
        this.compiler = compiler
        this.in_loop = false
        this.program = new Program()
        this.generic_templates = new [String: Generic]()
        PrimitiveTypes.init()
    }
    public check(module_ast: ModuleAST, compiler: Compiler, filename: String): Program {
        let typechecker: TypeChecker(compiler)
        typechecker.load_generic_module()
        typechecker.load_builtins_module()
        if typechecker.has_errored() return typechecker.program
        typechecker.switch_to_generic_module()
        typechecker.import_all_from_module(typechecker.get_module(typechecker.program.builtin_scope.module_id))
        if typechecker.has_errored() return typechecker.program
        typechecker.check_module(module_ast, filename)
        return typechecker.program
    }
    private get_module(this, id: uint): Module {
        return this.program.modules[id]
    }
    private get_current_module(this): Module {
        return this.get_module(this.current_scope.module_id)
    }
    private get_current_scope(this): Scope {
        return this.program.get_scope(this.current_scope)
    }
    private get_current_module_global_scope(this): Scope {
        return this.program.get_scope(this.get_current_module().scope)
    }
    private get_current_function(this): Function {
        return this.get_current_module().functions[this.current_function.id]
    }
    private get_current_function_type(this): FunctionType {
        if this.current_method != null
            return this.program.get_class_prop_type(this.current_method) as FunctionType
        return this.get_current_function().fnc_type
    }
    private get_class_from_var_id(this, var_id: VarId): Class {
        return this.get_module(var_id.module_id).classes[var_id.id]
    }
    private get_enum_from_var_id(this, var_id: VarId): Enum {
        return this.get_module(var_id.module_id).enums[var_id.id]
    }
    private types_are_eq(this, t1: Type, t2: Type): bool {
        if t1.kind != t2.kind return false
        if is_function(t1) {
            let t1_fnc_type = t1 as FunctionType
            let t2_fnc_type = t2 as FunctionType
            if t1_fnc_type.arg_types.length != t2_fnc_type.arg_types.length return false
            if !this.types_are_eq(t2_fnc_type.return_type, t1_fnc_type.return_type) return false
            for let i = 0; i < t1_fnc_type.arg_types.length; i++ {
                if !this.types_are_eq(t1_fnc_type.arg_types[i], t2_fnc_type.arg_types[i]) return false
            }
        }
        if t1.kind == TypeKind.ARRAY {
            let t1_arr_type = t1 as ArrayType
            let t2_arr_type = t2 as ArrayType
            return t1_arr_type.length == t2_arr_type.length and this.types_are_eq(t1_arr_type.element_type, t2_arr_type.element_type)
        }
        if t1.kind == TypeKind.TUPLE {
            let t1_tup_type = t1 as TupleType
            let t2_tup_type = t2 as TupleType
            let t1_element_types_length =  t1_tup_type.element_types.length
            if t1_element_types_length != t2_tup_type.element_types.length 
                return false
            for let i = 0; i < t1_element_types_length; i++ {
                if !this.types_are_eq(t1_tup_type.element_types[i], t2_tup_type.element_types[i])
                    return false
            }
        }
        if t1.kind == TypeKind.PTR {
            let t1_ptr_type = t1 as PointerType
            let t2_ptr_type = t2 as PointerType
            return this.types_are_eq(t1_ptr_type.pointee_type, t2_ptr_type.pointee_type)
        }
        if t1.kind == TypeKind.OBJECT {
            let t1_obj_type = t1 as ObjectType
            let t2_obj_type = t2 as ObjectType
            let t1_obj_typeid = t1_obj_type.class_id as TypeId
            let t2_obj_typeid = t2_obj_type.class_id as TypeId
            if t1_obj_typeid.kind == t2_obj_typeid.kind and t1_obj_typeid.module_id == t2_obj_typeid.module_id and t1_obj_typeid.id == t2_obj_typeid.id  {
                return true
            }
            let t2_class = this.program.get_class(t2_obj_typeid as ClassId)
            if t2_class.parent != null {
                return this.types_are_eq(t1_obj_type, t2_class.parent)
            }
            return false
        }
        if t1.kind == TypeKind.ENUM {
            let t1_enum_type = t1 as EnumType
            let t2_enum_type = t2 as EnumType
            let t1_enum_typeid = t1_enum_type.enum_id as TypeId
            let t2_enum_typeid = t2_enum_type.enum_id as TypeId
            return t1_enum_typeid == t2_enum_typeid
        }
        if t1.kind == TypeKind.RESOLVED_GENERIC {
            let t1_gen_type = t1 as GenericType
            let t2_gen_type = t2 as GenericType
            if t1_gen_type.name != t2_gen_type.name return false
            if t1_gen_type.arg_types.length != t2_gen_type.arg_types.length return false
            for let i = 0; i < t1_gen_type.arg_types.length; i++ {
                if (!this.types_are_eq(t1_gen_type.arg_types[i], t2_gen_type.arg_types[i])) return false
            }
        }
        if is_int(t1){
            if (t1 as IntType).is_signed != (t2 as IntType).is_signed return false
        }
        return true
    }
    private dump_type(this, ty: Type): String {
        if is_function(ty) {
            let fnc_ty = ty as FunctionType
            let args_tys_str = ""
            for arg_type in fnc_ty.arg_types {
                args_tys_str += "$(this.dump_type(arg_type)), "
            }
            return "($args_tys_str) => $(this.dump_type(fnc_ty.return_type))"
        }
        if ty.kind == TypeKind.PTR
            return "$(this.dump_type((ty as PointerType).pointee_type))*"
        if ty.kind == TypeKind.OBJECT {
            return this.program.get_class_from_type(ty).name
        }
        if ty.kind == TypeKind.ENUM {
            return this.program.get_enum((ty as EnumType).enum_id).name
        }
        if ty.kind == TypeKind.ARRAY {
            let arr_ty = ty as ArrayType
            return "$(this.dump_type(arr_ty.element_type))[$(arr_ty.length)]"
        }
        if ty.kind == TypeKind.TUPLE {
            let tup_ty = ty as TupleType
            let tup_str = ""
            for elem_ty in tup_ty.element_types {
                tup_str += "$(this.dump_type(elem_ty)), "
            }
            return "($tup_str)"
        }
        if ty.kind == TypeKind.RESOLVED_GENERIC {
            let gen_ty = ty as GenericType
            let s = gen_ty.name + "<"
            for arg_type in gen_ty.arg_types {
                s +=  this.dump_type(arg_type)
            }
            return s + ">"
        }
        if ty.kind == TypeKind.MODULE {
            return "Namespace"
        }
        if ty.kind == TypeKind.RECORD {
            return "Record"
        }
        return dump_type(ty, false)
    }
    private create_scope(this, module_id: uint): Scope {
        let module = this.get_module(module_id)
        let scope = new Scope(module_id, module.scopes.length)
        module.scopes << scope
        return scope
    }
    private create_child_scope_within_current_scope(this): Scope {
        let new_scope = this.create_scope(this.current_scope.module_id)
        new_scope.parent = this.current_scope
        this.get_current_scope().children << new_scope.id
        return new_scope
    } 
    private is_constant_in_scope(this, name: String): bool {
        let is_constant = false
        let var_id = this.get_var_from_current_scope(name)
        if var_id != null { 
            is_constant = var_id.kind == VarIdKind.CONST
        }
        return is_constant
    }
    private get_var_from_current_scope(this, name: String): VarId {
        let current_scope = this.get_current_scope()
        let value: VarId = null
        while value == null {
            value = current_scope.vars[name]
            if value == null
                value = current_scope.functions[name]
            if current_scope.parent == null or value != null
                break
            current_scope = this.program.get_scope(current_scope.parent)
        }
        return value
    }
    private get_type_from_current_scope(this, name: String): Type {
        let current_scope = this.get_current_scope()
        while true {
            let aliased_ty = current_scope.type_aliases[name]
            if aliased_ty != null {
                return aliased_ty
            }
            let class_id = current_scope.classes[name]
            if class_id != null {
                return new ObjectType(class_id)
            }
            let enum_id = current_scope.enums[name]
            if enum_id != null {
                return new EnumType(enum_id)
            }
            if (current_scope.parent == null) break
            current_scope = this.program.get_scope(current_scope.parent)
        }
        return PrimitiveTypes.unknown
    }
    private error(this, kind: ErrorKind, message: String, range: TextRange){
        this.compiler.errors << new FloError(kind, message, range)
    }
    private has_errored(this): bool {
        return this.compiler.errors.length > 0
    }
    private load_builtins_module(this){
        let module = this.lex_and_parse_typecheck_file(this.compiler.builtin_path, null)
        if (this.has_errored()) return
        let module_scope = this.program.get_scope(module.scope)
        module_scope.vars["true"] = null
        module_scope.vars["false"] = null
        module_scope.vars["null"] = null
        this.program.builtin_scope = module.scope
    }
    private load_generic_module(this){
        this.compiler.register_file("__generics__")
        let module = this.check_module(new ModuleAST(), "__generics__")
        GENERIC_MODULE_ID = module.scope.module_id
    }
    private switch_to_generic_module(this){
        this.current_scope = this.get_module(GENERIC_MODULE_ID).scope
    }
    private check_module(this, module_ast: ModuleAST, filename: String): Module {
        this.module_contains_generics = false
        let prev_scope = this.current_scope
        let module = new Module(filename)
        let current_module_id = this.program.modules.length
        this.program.modules << module
        let module_scope = this.create_scope(current_module_id)
        module_scope.parent = this.program.builtin_scope
        module.scope = module_scope.id
        this.current_scope = module_scope.id
        this.current_method = null
        this.current_class = null
        this.current_function = null
        for module_import in module_ast.imports {
            this.check_module_import(module_import)
            if (this.has_errored()) return module
        }
        // We declare module structures
        for enum_ in module_ast.enums {
            this.declare_enum_within_module(enum_)
        }
        for class_ in module_ast.classes {
            this.declare_class_within_module(class_)
        }
        if this.has_errored() return module
        for type_alias_node in module_ast.type_aliases {
            let ty = this.check_type(type_alias_node.parsed_type)
            let identifer_tok = type_alias_node.name
            let alias_name = identifer_tok.value
            if this.get_type_from_current_scope(alias_name).kind != TypeKind.UNKNOWN {
                this.error(ErrorKind.NAME, "Name '$alias_name' has already been used for another type. consider renaming", type_alias_node.name.range)
                return module
            }
            module_scope.type_aliases[alias_name] = ty
        }
        for global_var in module_ast.vars {
            this.declare_global_var(global_var)
        }
        for function in module_ast.functions {
            this.declare_function_within_module(function)
        }
        if this.has_errored() return module
        // We Now check bodies
        for let i = 0; i < module_ast.enums.length; i++ {
            this.check_enum_body(module.enums[i], module_ast.enums[i])
        }
        for class_ in module_ast.classes {
            this.check_class_body(class_)
        }
        for let i = 0; i < module_ast.functions.length; i++ {
           this.check_function_body(module.functions[i], module_ast.functions[i])
        }
        if this.module_contains_generics and this.current_scope.module_id != 0 {
            this.switch_to_generic_module()
            this.import_all_from_module(module)
        }
        this.current_scope = prev_scope
        return module
    }
    private create_generic_instance_in_module(this, name: String, types: Type[]): GenericType {
        let generic = this.generic_templates[name]
        if generic == null return null
        let generic_params = generic.template.generic_parameters
        if generic_params.length != types.length {
            this.error(ErrorKind.TYPE, "Generic expects $(generic_params.length) parameters but got $(types.length)", null)
            return null
        }
        let scope_id = this.current_scope
        this.switch_to_generic_module()
        let generic_scope = this.create_child_scope_within_current_scope()
        let param_strings = ""
        for let i = 0; i < generic_params.length; i++ {
            let param_name = generic_params[i].name.value
            let param_type: Type = types[i].kind == TypeKind.RESOLVED_GENERIC ? (types[i] as GenericType).instantiated_type : types[i]
            param_strings += "$(this.dump_type(param_type))_"
            generic_scope.type_aliases[param_name] = types[i]
        }
        let instantiated_generic_name = "$(name)_$param_strings"
        let possible_type = this.get_type_from_current_scope(instantiated_generic_name)
        if possible_type.kind == TypeKind.UNKNOWN {
            // TODO: Find a better way to create this initialization.
            let new_identok: IdentifierToken(instantiated_generic_name, generic.template.name.range)
            let instantiated_generic_class: ClassDeclarationNode(new_identok)
            instantiated_generic_class.parent = generic.template.parent
            instantiated_generic_class.fields = generic.template.fields
            instantiated_generic_class.methods = generic.template.methods
            this.current_scope = generic_scope.id
            this.declare_class_within_module(instantiated_generic_class)
            this.check_class_body(instantiated_generic_class)
            possible_type = this.get_type_from_current_scope(instantiated_generic_name)
        }
        this.current_scope = scope_id
        del generic_scope
        return new GenericType(name, types, possible_type)
    }
    private declare_var_within_current_scope(this, name: String, value: Expression, value_type: Type, is_const: bool): Var {
        let var = new Var(value, value_type)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let var_kind = is_const ? VarIdKind.CONST : VarIdKind.VAR
        let id = new VarId(var_kind, this.current_scope.module_id, current_module.vars.length)
        var.var_id = id
        current_module.vars << var
        current_scope.vars[name] = id
        return var
    }
    private declare_global_var(this, var_decl_node: VarDeclarationStatement){
        let var_stmt = this.check_var_declaration(var_decl_node)
        if this.has_errored() return
        let value = this.program.get_var(var_stmt.var_id).value
        if value != null {
            if !value.is_constant {
                this.error(ErrorKind.GEN, "Initilializer for global variable has to be a constant", var_decl_node.value.range)
                return
            }
        }
        var_stmt.is_static = true
        this.get_current_module().global_vars << var_stmt
    }
    private add_imported_typealias_to_module(this, alias_name: String, type_: Type){
        let scope = this.get_current_module_global_scope()
        scope.type_aliases[alias_name] = type_
    }
    private add_imported_var_to_module(this, var_name: String, var_id: VarId){
        let scope = this.get_current_module_global_scope()
        scope.vars[var_name] = var_id
    }
    private add_imported_fnc_to_module(this, fnc_name: String, fnc_id: VarId){
        let scope = this.get_current_module_global_scope()
        scope.functions[fnc_name] = fnc_id
    }
    private add_imported_class_to_module(this, class_name: String, class_id: ClassId){
        let scope = this.get_current_module_global_scope()
        scope.classes[class_name] = class_id
        scope.vars[class_name] = new ClassVarId(class_id)
    }
    private add_imported_enum_to_module(this, enum_name: String, enum_id: EnumId){
        let scope = this.get_current_module_global_scope()
        scope.enums[enum_name] = enum_id
        scope.vars[enum_name] = new EnumVarId(enum_id)
    }
    private init_function_signature(this, arg_nodes: ArgNode[], return_type_node: TypeNode, args: FunctionArg[], implicit_this_arg: Type): FunctionType {
        let arg_types: Type[] = []
        let has_implicit_this = false
        for arg in arg_nodes {
            let fnc_arg_name = arg.name.value
            let fnc_arg_range = arg.name.range
            let fnc_arg_default: Expression = null
            let fnc_arg_type = PrimitiveTypes.unknown
            if arg.parsed_type != null {
                if (arg.parsed_type.kind == TypeKind.UNKNOWN) {
                    has_implicit_this = true
                    fnc_arg_type = implicit_this_arg
                } else {
                    fnc_arg_type = this.check_type(arg.parsed_type)
                    if this.has_errored() return null
                }
            }
            if arg.default != null {
                fnc_arg_default = this.check_expression(fnc_arg_type, arg.default)
                if this.has_errored() return null
                if fnc_arg_type.kind == TypeKind.UNKNOWN
                    fnc_arg_type = fnc_arg_default.value_type
                else if !this.types_are_eq(fnc_arg_type, fnc_arg_default.value_type){
                    this.error(ErrorKind.TYPE, "Expected type of '$(this.dump_type(fnc_arg_type))' but got type of '$(this.dump_type(fnc_arg_default.value_type))' on signature", fnc_arg_default.range)
                }
            }
            let fnc_arg = new FunctionArg(fnc_arg_name, fnc_arg_type, fnc_arg_range)
            fnc_arg.default = fnc_arg_default
            args << fnc_arg
            let var = this.declare_var_within_current_scope(fnc_arg_name, fnc_arg, fnc_arg_type, false)
            fnc_arg.id = var.var_id
            arg_types << fnc_arg_type
        }
        let ret_type = return_type_node == null ? PrimitiveTypes.void : this.check_type(return_type_node)
        return new FunctionType(has_implicit_this, arg_types, ret_type)
    }
    private import_all_from_module(this, module: Module){
        let global_module_scope = this.program.get_scope(module.scope)
        for imported_var in module.global_vars {
            this.add_imported_var_to_module(imported_var.name, imported_var.var_id)
        }
        for imported_func in module.functions {
            this.add_imported_fnc_to_module(imported_func.name, imported_func.id)
        }
        for imported_class in module.classes {
            this.add_imported_class_to_module(imported_class.name, imported_class.id)
        }
        for imported_enum in module.enums {
            this.add_imported_enum_to_module(imported_enum.name, imported_enum.id)
        }
        for type_alias_entry in global_module_scope.type_aliases {
            this.add_imported_typealias_to_module(type_alias_entry.key, type_alias_entry.value)
        }
    }
    private check_module_import(this, import_node: ImportNode){
        if import_node.module_path.args.length > 0 {
            this.error(ErrorKind.GEN, "Import statement path can't be a formatted string", import_node.module_path.range)
            return
        }
        let path = import_node.module_path.value
        let module = this.lex_and_parse_typecheck_file(path, import_node.module_path.range)
        if this.has_errored() return
        let global_module_scope = this.program.get_scope(module.scope)
        if import_node.import_list.length > 0 {
            for import_clause in import_node.import_list {
                let name_to_import = import_clause.original_identifer.value
                let renamed_name = import_clause.renamed_identifer ? import_clause.renamed_identifer.value : name_to_import
                if this.generic_templates[name_to_import] != null {
                    continue
                }
                let class_id = global_module_scope.classes[name_to_import]
                if class_id != null {
                    this.add_imported_class_to_module(renamed_name, class_id)
                    continue
                }
                let enum_id = global_module_scope.enums[name_to_import]
                if enum_id != null {
                    this.add_imported_enum_to_module(renamed_name, enum_id)
                    continue
                }
                let var_id = global_module_scope.vars[name_to_import]
                if var_id != null {
                    this.add_imported_var_to_module(renamed_name, var_id)
                    continue 
                }
                let func_id = global_module_scope.functions[name_to_import]
                if func_id != null {
                    this.add_imported_fnc_to_module(renamed_name, func_id)
                    continue
                }
                let type_alias = global_module_scope.type_aliases[name_to_import]
                if type_alias != null {
                    this.add_imported_typealias_to_module(renamed_name, type_alias)
                    continue
                } else {
                    this.error(ErrorKind.NAME, "'$name_to_import' not found in module '$path'", import_clause.original_identifer.range)
                    return
                }
            }
        } else if import_node.module_name {
            let name = import_node.module_name.value
            this.get_current_module_global_scope().vars[name] = new ModuleVarId(global_module_scope.id)
        } else {
            this.import_all_from_module(module)
        }
    }
    private lex_and_parse_typecheck_file(this, filename: String, range: TextRange): Module {
        // TODO: You need to properly handle the built-in case; don't use null as a reference point.
        let filepath = filename
        let prev_file_id = this.compiler.current_file
        if range != null and !filename.starts_with("@") {
            filepath = Path.join(Path.dirname(this.get_current_module().name), filename)
        }
        let file_id = this.compiler.register_file(filepath)
        if file_id.id < this.program.modules.length {
            return this.get_module(file_id.id)
        }
        if !this.compiler.set_current_file(file_id){ 
            this.error(ErrorKind.IO, "No such file or directory: '$filename'", range)
            return null
        }
        let tokens = Lexer.tokenize(this.compiler)
        if this.has_errored() return null
        let module_node = Parser.parse(tokens, this.compiler.errors)
        if this.has_errored() return null
        let module = this.check_module(module_node, filepath)
        if this.has_errored() return null
        this.compiler.set_current_file(prev_file_id)
        return module
    }
    private declare_enum_within_module(this, enum_node: EnumNode){
        let declared_enum = new Enum()
        let name = enum_node.name.value
        declared_enum.definition_range = enum_node.name.range
        let module_scope =  this.get_current_module_global_scope()
        declared_enum.name = name
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Name '$name' has already been used for another type. consider renaming", enum_node.name.range)
            return
        }
        declared_enum.id = new EnumId(this.current_scope.module_id, this.get_current_module().enums.length)
        this.get_current_module().enums << declared_enum
        module_scope.enums[declared_enum.name] = declared_enum.id
        module_scope.vars[declared_enum.name] = new EnumVarId(declared_enum.id)
    }
    private declare_class_within_module(this, class_decl_node: ClassDeclarationNode) {
        let name = class_decl_node.name.value
        if (this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN) or (this.generic_templates[name] != null) {
            this.error(ErrorKind.NAME, "Name '$name' has already been used for another type. consider renaming", class_decl_node.name.range)
            return
        }
        if class_decl_node.generic_parameters.length > 0 {
            this.module_contains_generics = true
            this.generic_templates[name] = new Generic(this.current_scope.module_id, class_decl_node)
            return
        }
        let declared_class = new Class()
        declared_class.definition_range = class_decl_node.name.range
        let module_scope = this.get_current_module_global_scope()
        if class_decl_node.parent != null {
            declared_class.parent = this.check_type(class_decl_node.parent)
            if this.has_errored() return
        } else {
            declared_class.parent = null
        }
        declared_class.name = name
        declared_class.id = new ClassId(this.current_scope.module_id, this.get_current_module().classes.length)
        this.get_current_module().classes << declared_class
        module_scope.classes[name] = declared_class.id
        module_scope.vars[name] = new ClassVarId(declared_class.id)
    }
    private declare_function_within_module(this, function_node: FunctionDeclarationNode) {
        let declared_function = new Function(function_node.name.range)
        declared_function.is_external = function_node.is_external
        let name = function_node.name.value
        declared_function.name = name
        if this.is_constant_in_scope(name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", function_node.name.range)
            return
        }
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Illegal re-declaration of type '$name' as function", function_node.name.range)
            return
        }
        let parent_scope = this.current_scope
        let fnc_scope = this.create_child_scope_within_current_scope()
        this.current_scope = fnc_scope.id 
        declared_function.args = []
        declared_function.fnc_type = this.init_function_signature(function_node.args, function_node.return_type, declared_function.args, null)
        if this.has_errored() return
        declared_function.id = new VarId(VarIdKind.FNC, this.current_scope.module_id, this.get_current_module().functions.length)
        this.current_scope = fnc_scope.parent
        declared_function.scope = fnc_scope.id
        let module_scope =  this.get_current_module_global_scope()
        this.get_current_module().functions << declared_function
        module_scope.functions[declared_function.name] = declared_function.id
    }
    private check_enum_body(this, declared_enum: Enum, enum_node: EnumNode){
        let enum_variant: Type = null
        if enum_node.variant == null {
            enum_variant = PrimitiveTypes.int
        } else {
            enum_variant = this.check_type(enum_node.variant)
            if !is_int(enum_variant){
                this.error(ErrorKind.TYPE, "Expected an int type for enum type but got type '$(this.dump_type(enum_variant))'", enum_node.variant.range)
            }
        }
        let next_enum_value: u64 = 0 // What about negatives?
        for let i = 0; i < enum_node.fields.length; i++ {
            let enum_node_field = enum_node.fields[i]
            let enum_name = enum_node_field.name.value
            let enum_field = new EnumField(enum_name)
            let enum_field_range = enum_node_field.name.range
            enum_field.id = new PropId(PropIdKind.FIELD, declared_enum.id, i)
            if enum_node_field.initializer != null {
                enum_field.initializer = this.check_expression(enum_variant, enum_node_field.initializer)
                if (this.has_errored()) return
                enum_field_range = TextRange.merge(enum_field_range, enum_field.initializer.range)
                if !enum_field.initializer.is_constant {
                    this.error(ErrorKind.TYPE, "Enum initializer has to be a constant", enum_node_field.initializer.range)
                    return
                }
                if !this.types_are_eq(enum_variant, enum_field.initializer.value_type){
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(enum_variant))' but got type '$(this.dump_type(enum_field.initializer.value_type))", enum_node_field.initializer.range)
                    return
                }
                // Not safe!
                next_enum_value = evaluate_const_int_expression(this.program, enum_field.initializer) + 1 as u64
            } else {
                enum_field.initializer = new IntExpression(next_enum_value as u64, enum_field_range)
                enum_field.initializer.value_type = enum_variant
                next_enum_value++
            }
            declared_enum.field_map[enum_name] = enum_field.id
            declared_enum.fields << enum_field
        }
        declared_enum.variant_type = enum_variant
    }
    private declare_class_fields(this, declared_class: Class, class_node: ClassDeclarationNode){
        let current_field_offset = declared_class.inherited_fields_num
        for let i = 0; i < class_node.fields.length; i++ {
            let field_node = class_node.fields[i]
            let field = new ClassField()
            field.name = field_node.name.value
            field.definition_range = field_node.name.range
            if is_operator_overload_name(field.name) {
                this.error(ErrorKind.NAME, field.name+" is reserved only for operator overloads and cannot be used as a field name", field_node.name.range)
            }
            field.visibility = field_node.access_modifier
            field.id = new PropId(PropIdKind.FIELD, declared_class.id, i)
            field.field_type = this.check_type(field_node.parsed_type)
            field.field_offset = current_field_offset
            if this.has_errored() return
            let possible_prop_id = declared_class.prop_map[field.name]
            if possible_prop_id != null {
                if possible_prop_id.type_id == declared_class.id {
                    this.error(ErrorKind.NAME, "Field $(field.name) in class $(declared_class.name) already exists", field_node.name.range)
                    return
                }
                let parent_prop_type = this.program.get_class_prop_type(possible_prop_id)
                let parent_prop_visibility = this.program.get_class_prop_visibility(possible_prop_id)
                if !this.types_are_eq(parent_prop_type, field.field_type) {
                    this.error(ErrorKind.TYPE, "Signature of inherited field $(field.name) in class $(declared_class.name) does not match expected parent signature '$(this.dump_type(parent_prop_type))", field_node.name.range)
                    return
                }
                if field.visibility != parent_prop_visibility {
                    this.error(ErrorKind.GEN, "Expected inherited field $(field.name) in class $(declared_class.name) to be $(dump_access(parent_prop_visibility))", field_node.name.range)
                    return
                }
            }
            if field_node.initializer != null {
                field.initializer = this.check_expression(field.field_type, field_node.initializer)
                if this.has_errored() return
                if !this.types_are_eq(field.field_type, field.initializer.value_type) {
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(field.field_type))' but got type '$(this.dump_type(field.initializer.value_type))' on static field initialization", field_node.initializer.range)
                }
                if !field.initializer.is_constant {
                    this.error(ErrorKind.GEN, "Static field initializer has to be a constant", field_node.initializer.range)
                    return
                }
                field.is_static = true
                declared_class.static_prop_map[field.name] = field.id
            } else {
                field.is_static = false
                declared_class.prop_map[field.name] = field.id
                current_field_offset++
            }
            declared_class.fields << field
        }
    }
    private is_iteratable(this, suspect_type: Type): bool {
        //TODO: Need to think about generics
        if !is_object(suspect_type) return false
        let class_ = this.program.get_class_from_type(suspect_type)
        let done_prop_id = class_.prop_map["done"]
        if (done_prop_id == null) return false
        let done_type = this.program.get_class_prop_type(done_prop_id)
        if (done_type.kind != TypeKind.BOOL) return false
        let next_prop_id = class_.prop_map["next"]
        if (next_prop_id == null) return false
        let next_type = this.program.get_class_prop_type(next_prop_id) as FunctionType
        if (next_type.kind != TypeKind.FNC) return false
        if (next_type.arg_types.length != 1) return false
        return true
    }
    private declare_class_methods(this, declared_class: Class, class_node: ClassDeclarationNode){
        //TODO: Need to refactor
        let object_type = new ObjectType(declared_class.id)
        for let i = 0; i < class_node.methods.length; i++ {
            let method_node = class_node.methods[i]
            let method = new ClassMethod(method_node.function.name.range)
            let name = method_node.function.name.value
            method.name = name
            let method_scope = this.create_child_scope_within_current_scope()
            this.current_scope = method_scope.id
            method.args = []
            method.is_abstract = method_node.function.is_external
            method.visibility = method_node.access_modifier
            method.method_type = this.init_function_signature(method_node.function.args, method_node.function.return_type, method.args, object_type)
            if this.has_errored() return
            method.is_static = !method.method_type.has_implicit_this
            let name_range = method_node.function.name.range
            if is_operator_overload_name(name) {
                let args_num = 2
                if name == "__iter__" or name == "__del__" {
                    args_num = 1
                } else if name =="__setitem__" {
                    args_num = 3
                }
                if method_node.function.args.length != args_num {
                    this.error(ErrorKind.GEN, "Expected $args_num parameters for binary operator overload $name but got $(method_node.function.args.length)", name_range)
                    return
                }
                if method.is_static {
                    this.error(ErrorKind.GEN, "Binary operator overload $name cannot be static", name_range)
                    return
                }
            }
            if name == "__iter__" {
                if !this.is_iteratable(method.method_type.return_type) {
                    this.error(ErrorKind.TYPE, "__iter__ method must return an iteratable object {done: bool, next(): any}", name_range)
                    return 
                }
            }
            let possible_prop_id = declared_class.prop_map[name]
            if possible_prop_id != null {
                if possible_prop_id.type_id == declared_class.id {
                    this.error(ErrorKind.NAME, "Method $name in class $(declared_class.name) already exists", name_range)
                    return
                }
                let parent_prop_type = this.program.get_class_prop_type(possible_prop_id)
                let parent_prop_visibility = this.program.get_class_prop_visibility(possible_prop_id)
                if !this.types_are_eq(parent_prop_type, method.method_type) {
                    this.error(ErrorKind.TYPE, "Signature of inherited method $name in class $(declared_class.name) does not match expected parent signature '$(this.dump_type(parent_prop_type))'", name_range)
                    return
                }
                if method.visibility != parent_prop_visibility {
                    this.error(ErrorKind.GEN, "Expected inherited method $name in class $(declared_class.name) to be $(dump_access(parent_prop_visibility))", name_range)
                    return
                }
            }
            method.id = new PropId(PropIdKind.METHOD, declared_class.id, i)
            if method.is_static {
                if method.is_abstract {
                    this.error(ErrorKind.GEN, "Static method can't be abstract", name_range)
                    return
                }
                if method.name == "constructor" {
                    this.error(ErrorKind.GEN, "Class constructor can't be static", name_range)
                    return
                }
                declared_class.static_prop_map[name] = method.id
            } else {
                if method.name == "constructor" {
                    if method.is_abstract {
                        this.error(ErrorKind.GEN, "Class constructor can't be abstract", name_range)
                        return
                    }
                    declared_class.constructor_id = method.id
                } else {
                    if method.is_abstract {
                        this.error(ErrorKind.GEN, "Can't have a abstract private method use protected instead", name_range)
                        return
                    }
                    declared_class.prop_map[name] = method.id
                }
                if declared_class.parent != null {
                    let constructor_method_id = this.program.get_class_from_type(declared_class.parent).constructor_id
                    declared_class.prop_map["super"] = constructor_method_id
                }
            }
            method.scope = method_scope.id
            declared_class.methods << method
            this.current_scope = method_scope.parent
        }
    }
    private add_inherited_props_to_class(this, declared_class: Class, class_node: ClassDeclarationNode){
        let parent_type = declared_class.parent
        if !is_object(parent_type) {
            this.error(ErrorKind.TYPE, "Can only inherit from class not type '$(this.dump_type(parent_type))'", class_node.parent.range)
        }
        let parent_class = this.program.get_class_from_type(parent_type)
        for parent_entry_prop in parent_class.prop_map {
            let parent_prop_name = parent_entry_prop.key
            let parent_prop_id = parent_entry_prop.value  
            let parent_prop_type = this.program.get_class_prop_type(parent_prop_id)
            let child_prop_id = declared_class.prop_map[parent_prop_name]
            let parent_prop_visibility = this.program.get_class_prop_visibility(parent_prop_id)
            let parent_prop_is_static = this.program.is_class_prop_static(parent_prop_id)
            if parent_prop_is_static
                continue
            if parent_prop_visibility == ACCESS_ATTR.PRIVATE and is_function(parent_prop_type)
                continue
            if child_prop_id == null {
                if parent_prop_id.kind == PropIdKind.FIELD
                    declared_class.inherited_fields_num++
                if parent_prop_id.kind == PropIdKind.METHOD
                    declared_class.inherited_methods_num++
                declared_class.prop_map[parent_prop_name] = parent_prop_id
            }
        }
    }
    private check_class_body(this, class_node: ClassDeclarationNode){
        let class_name = class_node.name.value
        let resolved_type = this.get_type_from_current_scope(class_name)
        if resolved_type.kind == TypeKind.UNKNOWN return
        let declared_class = this.program.get_class_from_type(resolved_type)
        let outer_class = this.current_class
        this.current_class = declared_class.id
        if declared_class.parent != null {
            this.add_inherited_props_to_class(declared_class, class_node)
        }
        // Fields
        this.declare_class_fields(declared_class, class_node)     
        if this.has_errored() return
        // Declare class methods
        this.declare_class_methods(declared_class, class_node)
        if this.has_errored() return
        // Checking if class is abstract.
        for prop_entry in declared_class.prop_map {
            let prop_id = prop_entry.value
            let prop_name = prop_entry.key
            if prop_id.kind == PropIdKind.METHOD {
                let prop_method = this.program.get_method(prop_id)
                if prop_method.is_abstract {
                    if declared_class.constructor_id != null {
                        this.error(ErrorKind.GEN, "Class with constructor must implement all it's methods missing $(prop_name) implementation", class_node.name.range)
                        return
                    }
                    declared_class.is_abstract = true
                    break
                }
            }
        }
        // Class Methods Body
        for let i = 0; i < declared_class.methods.length; i++ {
            let prev_method = this.current_method
            let method = declared_class.methods[i]
            this.current_method = method.id
            let method_node = class_node.methods[i]
            this.current_scope = method.scope
            if method.is_abstract {
                continue
            }
            method.block = this.check_block(method_node.function.block)
            if this.has_errored() {
                return
            }
            if !method.block.returns {
                if method.method_type.return_type.kind == TypeKind.VOID {
                    method.block.statements << (new ReturnStatement() as Statement)
                } else {
                    this.error(ErrorKind.GEN, "Method missing ending return statement", method_node.function.return_type.range)
                    return
                }
            }
            this.current_method = prev_method
            this.current_scope = this.program.get_scope(method.scope).parent
        }
        this.current_class = outer_class
    }
    private check_function_body(this, func: Function, func_node: FunctionDeclarationNode) {
        if func.is_external { 
            return
        }
        let prev_func = this.current_function
        this.current_function = func.id
        let prev_scope = this.current_scope 
        this.current_scope = func.scope
        func.block = this.check_block(func_node.block)
        if this.has_errored() return
        if !func.block.returns {
            if func.fnc_type.return_type.kind == TypeKind.VOID {
                func.block.statements << (new ReturnStatement() as Statement)
            } else {
                this.error(ErrorKind.GEN, "Function missing ending return statement", func_node.name.range)
                return
            }
        }
        this.current_scope = this.program.get_scope(func.scope).parent
    }
    private check_array_type(this, array_type_node: ArrayTypeNode): Type {
        let len_expr = this.check_expression(PrimitiveTypes.uint, array_type_node.length)
        if this.has_errored() return PrimitiveTypes.unknown
        if !is_int(len_expr.value_type) {
            this.error(ErrorKind.GEN, "length has to be an int", array_type_node.length.range)
            return null
        }
        let size_ty = len_expr.value_type as IntType
        if size_ty.is_signed or size_ty.kind != TypeKind.INT {
            this.error(ErrorKind.GEN, "length has to be a uint", array_type_node.length.range)
            return null
        }
        if !len_expr.is_constant {
            this.error(ErrorKind.GEN, "length is a non-constant value", array_type_node.length.range)
            return null
        }
        let length = evaluate_const_int_expression(this.program, len_expr)
        if length < 0 {
            this.error(ErrorKind.GEN, "length should be an unsigned", array_type_node.length.range)
            return null
        }
        let element_type = this.check_type(array_type_node.element_type)
        return new ArrayType(element_type, length as uint)
    }
    private check_function_type(this, function_type_node: FunctionTypeNode): Type {
        let arg_types: Type[] = []
        for arg in function_type_node.args 
            arg_types << this.check_type(arg)
        let return_type = this.check_type(function_type_node.return_type)
        return new FunctionType(false, arg_types, return_type)
    }
    private check_tuple_type(this, tuple_type_node: TupleTypeNode): Type {
        let tuple_type = new TupleType()
        for element_type in tuple_type_node.element_types {
            tuple_type.element_types << this.check_type(element_type)
        }
        return tuple_type
    }
    private check_record_type(this, record_type_node: RecordTypeNode): Type {
        let record_identifier = record_type_node.name
        let name = record_identifier.value

        if record_type_node.generic_args.length > 0 {
            let types: Type[] = []
            for arg in record_type_node.generic_args
                types << this.check_type(arg)
            if this.has_errored() return null
            let generic_type = this.create_generic_instance_in_module(name, types)
            if generic_type != null {
                return generic_type
            }
        }

        let found_type = this.get_type_from_current_scope(name)
        if found_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.TYPE, "Undefined type '$name'", record_identifier.range)
            return null
        }
        return found_type
    }
    private check_type(this, type_node: TypeNode): Type {
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY
            return this.check_array_type(type_node as ArrayTypeNode)
        if type_node.kind == TypeKind.FNC {
            return this.check_function_type(type_node as FunctionTypeNode)
        } else if type_node.kind == TypeKind.TUPLE {
            return this.check_tuple_type(type_node as TupleTypeNode)
        }
        if type_node.kind == TypeKind.RECORD {
            let record_type_node = type_node as RecordTypeNode
            let name_value = record_type_node.name.value

            if name_value == "bool" return PrimitiveTypes.bool
            if name_value == "u4" return PrimitiveTypes.u4
            if name_value == "u8" return PrimitiveTypes.u8
            if name_value == "u16" return PrimitiveTypes.u16
            if name_value == "u32" return PrimitiveTypes.u32
            if name_value == "u64" return PrimitiveTypes.u64
            if name_value == "u128" return PrimitiveTypes.u128
            if name_value == "uint" return PrimitiveTypes.uint
            if name_value == "i4" return PrimitiveTypes.i4
            if name_value == "i8" return PrimitiveTypes.i8
            if name_value == "i16" return PrimitiveTypes.i16
            if name_value == "i32" return PrimitiveTypes.i32
            if name_value == "i64" return PrimitiveTypes.i64
            if name_value == "i128" return PrimitiveTypes.i128
            if name_value == "int" return PrimitiveTypes.int
            if name_value == "f32" return PrimitiveTypes.f32
            if name_value == "f64" return PrimitiveTypes.f64
            if name_value == "void" return PrimitiveTypes.void
            else return this.check_record_type(record_type_node)
        }
        return PrimitiveTypes.unknown
    }
    private check_tuple_expression(this, expected_type: Type, tuple_node: TupleExpressionNode): TupleExpression {
        let expected_tuple_type: TupleType = null
        let elements: Expression[] = []
        let actual_tuple_type = new TupleType()
        let is_constant = true
        if expected_type.kind == TypeKind.TUPLE {
            expected_tuple_type = expected_type as TupleType
        }
        for let i = 0; i < tuple_node.elements.length; i++ {
            let expected_element_type = PrimitiveTypes.unknown
            if expected_tuple_type != null {
                if i < expected_tuple_type.element_types.length {
                    expected_element_type = expected_tuple_type.element_types[i]
                }
            }
            let expression = this.check_expression(expected_element_type, tuple_node.elements[i])
            if this.has_errored() return null
            is_constant and= expression.is_constant
            actual_tuple_type.element_types << expression.value_type
            elements << expression
        }
        let tuple_expression = new TupleExpression(elements, actual_tuple_type, tuple_node.range)
        tuple_expression.is_constant = is_constant
        return tuple_expression

    }
    private check_array_expression(this, expected_type: Type, array_node: ArrayExpressionNode): ArrayExpression {
        if this.has_errored() return null
        let elements: Expression[] = []
        let element_type = PrimitiveTypes.unknown
        let is_constant = true
        let array_type = expected_type
        if expected_type.kind == TypeKind.ARRAY {
            element_type = (expected_type as ArrayType).element_type
        } else if expected_type.kind == TypeKind.RESOLVED_GENERIC {
            is_constant = false
            let generic_ty =  expected_type as GenericType
            if is_object(generic_ty) and generic_ty.name == "Array"
                element_type = generic_ty.arg_types[0]
        }
        if array_node.elements.length > 0 {
            let i = 0
            for array_node_elements in array_node.elements {
                let element = this.check_expression(element_type, array_node_elements)
                if this.has_errored() return null
                if i == 0 and element_type.kind == TypeKind.UNKNOWN {
                    element_type = element.value_type
                }
                is_constant and= element.is_constant
                if this.types_are_eq(element_type, element.value_type) {
                    elements << element
                } else {
                    this.error(ErrorKind.TYPE, "Expected element type of '$(this.dump_type(element_type))' but got type '$(this.dump_type(element.value_type))'", array_node_elements.range)
                    return null
                }
                i++
            }
        }
        if array_type.kind != TypeKind.ARRAY {
            let generic_array_type = this.create_generic_instance_in_module("Array", [element_type])
            if (generic_array_type != null) {
                array_type = generic_array_type
                is_constant = false
            }
        } else {
            array_type = new ArrayType(element_type, elements.length)
        }
        let arr_exp = new ArrayExpression(elements, array_type, array_node.range)
        arr_exp.is_constant = is_constant
        return arr_exp
    }
    private check_var_access_expr(this, expected_type: Type, var_access_node: VarAccessExpressionNode): Expression {
        let name = var_access_node.name.value
        if name == "true" 
            return new BooleanExpression(true, var_access_node.range) 
        if name == "false" 
            return new BooleanExpression(false, var_access_node.range)
        if name == "null" {
            if (expected_type.kind == TypeKind.VOID) {
                this.error(ErrorKind.TYPE, "Const 'null' cannot be of type 'void'", var_access_node.name.range)
                return null
            }
            return new NullExpression(expected_type, var_access_node.range)
        }
        let current_scope = this.get_current_scope()
        let resolved = this.get_var_from_current_scope(name)
        let var_ty = PrimitiveTypes.unknown
        if resolved != null {
            let var_id = resolved
            if var_id.kind == VarIdKind.FNC
                var_ty = this.program.get_func(var_id).fnc_type
            else if var_id.kind == VarIdKind.VAR or var_id.kind == VarIdKind.CONST
                var_ty = this.program.get_var(var_id).value_type
            else if var_id.kind == VarIdKind.CLASS or var_id.kind == VarIdKind.ENUM
                var_ty = new Type(TypeKind.RECORD)
            else if var_id.kind == VarIdKind.MODULE
                var_ty = new Type(TypeKind.MODULE)
            return new VarAccessExpression(var_id, var_ty, var_access_node.range)
        }
        this.error(ErrorKind.NAME, "Undefined variable '$name'", var_access_node.range)
        return null
    }
    private check_assignment(this, left: Expression, right: Expression, binary_node: BinaryExpressionNode): Expression {
        let op = binary_node.op
        if op != BinaryOp.ASSIGN {
            if is_object(left.value_type){
                let exp = this.check_object_bin_assign(left, binary_node)
                if exp != null or this.has_errored() return exp
            }
            right = this.check_bin_expr(left.value_type, lower_bin_assign_node(binary_node))
            if this.has_errored() return null
        }
        if !check_is_var(left) {
            this.error(ErrorKind.TYPE, "Assigment target is not a mutable", binary_node.lhs.range)
            return null
        }
        if !this.types_are_eq(left.value_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Illegal assignment of variable of type '$(this.dump_type(right.value_type))' to '$(this.dump_type(left.value_type))'", binary_node.range)
            return null
        }
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type, binary_node.range)
    }
    private check_object_bin_assign(this, left: Expression, binary_node: BinaryExpressionNode): Expression {
        let op = binary_node.op
        let method_name = bin_op_to_op_overload_name(op)
        let owner_class = this.program.get_class_from_type(left.value_type as ObjectType)
        let prop_id = owner_class.prop_map[method_name]
        if prop_id == null {
            return null
        }
        let method_type = this.program.get_class_prop_type(prop_id) as FunctionType
        let arg_type = method_type.arg_types[1]
        let right = this.check_expression(arg_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(arg_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_exp = new MemberExpression(left, prop_id, method_type, binary_node.range)
        let args: Expression[] = [right]
        return new CallExpression(member_exp, args, method_type.return_type, binary_node.range)
    }
    private check_object_binary_expr(this, left: Expression, binary_node: BinaryExpressionNode, right: Expression): Expression {
        let op = binary_node.op
        let method_name = bin_op_to_op_overload_name(op)
        if method_name == null {
            this.error(ErrorKind.GEN, "Unsupported binary operator overload for operator '$(dump_bin_op(op))'", binary_node.range)
            return null
        }
        let owner_class = this.program.get_class_from_type(left.value_type)
        let prop_id = owner_class.prop_map[method_name]
        if prop_id == null {
            if op == BinaryOp.EEQ or op == BinaryOp.NEQ {
                return new BinaryExpression(left, op, this.check_expression(left.value_type, binary_node.rhs), PrimitiveTypes.bool, binary_node.range)
            }
            this.error(ErrorKind.NAME, "No binary operator overload for '$(dump_bin_op(op))' in object of class '$(owner_class.name)' please implement the method $method_name to support this", binary_node.range)
            return null
        }
        let method_type = this.program.get_class_prop_type(prop_id) as FunctionType
        let arg_type = method_type.arg_types[1]
        if right == null 
            right = this.check_expression(arg_type, binary_node.rhs)
        if this.has_errored() return null
        if is_null_expression(right) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            return new BinaryExpression(left, op, right, PrimitiveTypes.bool, binary_node.range)
        }
        if op == BinaryOp.IN { //FIXME: Just For Ranges. Will not be required once we have ranges are generics. 
            if is_int(right.value_type) and is_int(arg_type){
                right = cast_exp_to_type(right, max_type(right.value_type, arg_type))
            }
        }
        if !this.types_are_eq(arg_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_exp = new MemberExpression(left, prop_id, method_type, binary_node.range)
        let args: Expression[] = [right]
        return new CallExpression(member_exp, args, method_type.return_type, binary_node.range)
    }
    private check_object_setitem_expr(this, object: Expression, binary_node: BinaryExpressionNode): Expression {
        let index_expr_node = binary_node.lhs as ExpressionIndexNode
        let owner_class = this.program.get_class_from_type(object.value_type)
        let prop_id = owner_class.prop_map["__setitem__"]
        if prop_id == null {
            this.error(ErrorKind.GEN, "No operator overload for index set operator on $(owner_class.name) object please implement method __setitem__ to use in this class", index_expr_node.range)
            return null
        }
        let method_type = this.program.get_class_prop_type(prop_id) as FunctionType
        let arg1_type = method_type.arg_types[1]
        let arg2_type = method_type.arg_types[2]
        if this.has_errored() return null
        let index = this.check_expression(arg1_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(arg1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg1_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let value = this.check_expression(arg2_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(arg1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg2_type))' but got type '$(this.dump_type(value.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_expr = new MemberExpression(object, prop_id, method_type, binary_node.range)
        let args: Expression[] = [index, value]
        return new CallExpression(member_expr, args, method_type.return_type, binary_node.range)
    }

    private check_bin_expr(this, expected_type: Type, binary_node: BinaryExpressionNode): BinaryExpression {
        let op = binary_node.op
        let is_assign_op = op >= BinaryOp.ASSIGN and op <= BinaryOp.SR_ASSIGN
        if op == BinaryOp.ASSIGN and binary_node.lhs.expr_kind == ExpressionKind.INDEX {
            let possible_obj = this.check_expression(PrimitiveTypes.unknown, (binary_node.lhs as ExpressionIndexNode).expression)
            if this.has_errored() return null
            if is_object(possible_obj.value_type)
                return this.check_object_setitem_expr(possible_obj, binary_node) as BinaryExpression
        }
        let left = this.check_expression(expected_type, binary_node.lhs)
        if this.has_errored() return null
        if is_object(left.value_type) and !is_assign_op and op != BinaryOp.IN
            return this.check_object_binary_expr(left, binary_node, null) as BinaryExpression
        let right = this.check_expression(left.value_type, binary_node.rhs)
        if this.has_errored() return null
        if is_object(right.value_type) and op == BinaryOp.IN {
            return this.check_object_binary_expr(right, binary_node, left) as BinaryExpression
        }
        if this.has_errored() return null
        if is_assign_op {
            return this.check_assignment(left, right, binary_node) as BinaryExpression
        }
        let is_const = left.is_constant and right.is_constant
        if left.value_type.kind == TypeKind.UNKNOWN and right.value_type.kind != TypeKind.UNKNOWN
            left.value_type = right.value_type
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, PrimitiveTypes.f64) // Might need to cast it to the biggest available
                if is_int(right.value_type)
                    right = cast_exp_to_type(right, PrimitiveTypes.f64) // Might need to cast it to the biggest available
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                check_cast_lower_bits(&left, &right)
                let exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = PrimitiveTypes.bool
                
                return new BinaryExpression(left, op, right, exp_type, binary_node.range, is_const)
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, PrimitiveTypes.int) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, PrimitiveTypes.int) // Might need to cast it to the biggest available
                }
                check_cast_lower_bits(&left, &right)
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range, is_const)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range, is_const)
        }
        if op >= BinaryOp.GT and op <= BinaryOp.NEQ {
            if is_numeric(left.value_type) and is_numeric(right.value_type){
                check_cast_lower_bits(&left, &right)
            }
            let boolean_type = PrimitiveTypes.bool
            return new BinaryExpression(left, op, right, boolean_type, binary_node.range, is_const)
        }
        if op == BinaryOp.ADD or op == BinaryOp.SUB and is_pointer(left.value_type) and right.value_type.kind == TypeKind.INT {
            return new BinaryExpression(left, op, right, left.value_type, binary_node.range, false)
        }
        this.error(ErrorKind.TYPE, "Illegal binary operation '$(dump_bin_op(op))' between types '$(this.dump_type(left.value_type))' and '$(this.dump_type(right.value_type))'", binary_node.range)
        return null
    }
    private check_unary_expr(this, expected_type: Type, unary_node: UnaryExpressionNode): UnaryExpression {
        let op = unary_node.op
        let expression = this.check_expression(expected_type, unary_node.expression)
        if this.has_errored() return null
        let ty = expression.value_type
        let is_const = expression.is_constant
        if op == UnaryOp.NEG {
            if is_numeric(ty){
                if is_int(ty){
                    ty = get_signed_int_variant(ty)
                }
                return new UnaryExpression(op, expression, ty, unary_node.range, is_const)
            }
        }
        if op == UnaryOp.NOT {
            if is_bool(ty) or is_numeric(ty)
                return new UnaryExpression(op, expression, ty, unary_node.range, is_const)
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR {
            if is_numeric(ty) or is_pointer(ty) {
                if !check_is_var(expression) {
                    this.error(ErrorKind.GEN, "Illegal unary operation $(dump_unary_op(op)) on constant", unary_node.expression.range)
                    return null
                }
                return new UnaryExpression(op, expression, ty, unary_node.range)
            }
        }
        if op == UnaryOp.ADDROF {
            if check_is_var(expression)
                return new UnaryExpression(op, expression, new PointerType(expression.value_type), unary_node.range)
        }
        if op == UnaryOp.DEL {
            if is_object(ty) or is_pointer(ty)
                return new UnaryExpression(op, expression, PrimitiveTypes.void, unary_node.range)
        }
        this.error(ErrorKind.TYPE, "Illegal unary operation $(dump_unary_op(op)) on type '$(this.dump_type(ty))'", unary_node.range)
        return null
    }
    private check_typecast_expr(this, type_expr_node: TypeCastExpressionNode): Expression {
        let dest_ty = this.check_type(type_expr_node.bound_type)
        let exp = this.check_expression(dest_ty, type_expr_node.expression)
        if this.has_errored() return null
        let val_ty = exp.value_type
        /* TODO:
            int to pointer.
            boolean to int/float.
        */
        if this.program.is_buitin(dest_ty, "String") {
            return new StringExpression("", [0], [exp], dest_ty, type_expr_node.range)
        }
        let is_valid_cast = false
        if is_numeric(dest_ty) and is_numeric(val_ty) {
            is_valid_cast = true    
        }
        if is_int(dest_ty) and val_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        // TODO: Re-think this, this is a temporary fix
        if is_int(val_ty) and dest_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        if is_numeric(dest_ty) and this.program.is_buitin(val_ty, "String") {
            let call: IntrinsicCall = null
            if is_float(dest_ty) {
                call = new IntrinsicCall(Intrinsics.STR_TO_F, PrimitiveTypes.unknown, type_expr_node.range)
            } else if dest_ty.kind < TypeKind.I64 or (ARCH_WORD_SIZE < 64 and dest_ty.kind == TypeKind.INT) {
                call = new IntrinsicCall(Intrinsics.STR_TO_I, PrimitiveTypes.unknown, type_expr_node.range)
            } else {
                //TODO: I need to implement string to i128
                call = new IntrinsicCall(Intrinsics.STR_TO_L, PrimitiveTypes.unknown, type_expr_node.range)
            }
            call.args << exp
            exp = call
            is_valid_cast = true
        }
        if is_object(dest_ty) and is_object(val_ty) {
            is_valid_cast = true
        }
        if is_pointer(dest_ty) and is_pointer(val_ty) {
            is_valid_cast = true
        }
        if is_bool(dest_ty) {
            is_valid_cast = true
        }
        if !is_valid_cast {
            this.error(ErrorKind.TYPE, "Cannot cast type '$(this.dump_type(val_ty))' to '$(this.dump_type(dest_ty))'", type_expr_node.range)
            return null
        }
        return new TypeCastExpression(exp, dest_ty, type_expr_node.range)
    }
    private check_constructor_call(this, class_id: ClassId, args: ExpressionNode[], argsp: Expression[]*): String { 
        let obj_class = this.program.get_class(class_id)
        let field_id = obj_class.constructor_id
        if field_id == null {
            return "Cannot construct an object of abstract class"
        }
        let constructor = obj_class.methods[field_id.id] 
        let construct_type = constructor.method_type
        let checked_args = this.fill_in_default_call_args(construct_type, constructor.args, args)
        if this.has_errored() return null
        let index = this.check_function_call_args_match(construct_type, checked_args)
        if index >= -1 {
            if index == -1 {
                return "Expected $(construct_type.arg_types.length) argument(s) on constructor call but got $(args.length)"
            } else {
                return "Expected type '$(this.dump_type(construct_type.arg_types[index as uint]))' but got type '$(this.dump_type(checked_args[index as uint].value_type))' as constructor call argument ($index)"
            }
        }
        argsp[0] = checked_args
        return null
    }
    private check_new_expr(this, new_expr_node: NewExpressionNode): NewExpression {
        let expression_type = this.check_type(new_expr_node.parsed_type)
        if this.has_errored() return null
        let memory_type = expression_type
        if (memory_type.kind == TypeKind.RESOLVED_GENERIC) memory_type = (memory_type as GenericType).instantiated_type
        let args: Expression[] = []
        if is_object(memory_type) {
            let msg = this.check_constructor_call(this.program.get_class_from_type(memory_type).id, new_expr_node.args, &args)
            if msg != null {
                this.error(ErrorKind.GEN, msg, new_expr_node.range)
                return null
            }
        } else if memory_type.kind == TypeKind.PTR {
            memory_type = (memory_type as PointerType).pointee_type
            let argno = new_expr_node.args.length
            if argno != 1 {
                this.error(ErrorKind.GEN, "New operator expects 1 argument for pointers but got $argno argument(s)", new_expr_node.range)
                return null
            }
            let int_ty = PrimitiveTypes.uint
            let arg = this.check_expression(int_ty, new_expr_node.args[0])
            if this.has_errored() return null
            if !this.types_are_eq(int_ty, arg.value_type) {
                this.error(ErrorKind.GEN, "New operator for pointers expects argument of type '$(this.dump_type(int_ty))' but got type '$(this.dump_type(arg.value_type))'", new_expr_node.args[0].range)
                del int_ty
                return null
            }
            args << arg
        } else {
            this.error(ErrorKind.TYPE, "New operator expects either an a pointer or an object not a(n) '$(this.dump_type(memory_type))'", new_expr_node.range)
            return null
        }
        return new NewExpression(new_expr_node.onheap, memory_type, args, expression_type, new_expr_node.range)
    }   
    private check_member_access(this, accessor: PropId): String {
        let visibility = ACCESS_ATTR.PUBLIC
        let accessee = this.program.get_class_from_prop_id(accessor)
        let member_name = ""
        if accessor.kind == PropIdKind.METHOD {
            let method = accessee.methods[accessor.id]
            visibility = method.visibility
            member_name = method.name
        } else {
            let field = accessee.fields[accessor.id]
            visibility = field.visibility
            member_name = field.name
        }
        if this.current_class != null {
            if this.current_class.module_id != accessee.id.module_id or accessee.id.id != this.current_class.id {
                if visibility == ACCESS_ATTR.PRIVATE {
                    return "Property '$member_name' is defined as private and only accessible within the class $(accessee.name)"
                }
            }
        } else if visibility != ACCESS_ATTR.PUBLIC {
            return "Property '$member_name' is defined as $(dump_access(visibility)) and only accessible within the class $(accessee.name)"
        }
        return null
    }
    private check_member_expr(this, expected_type: Type, member_expr_node: MemberExpressionNode): Expression {
        let prop_owner = this.check_expression(PrimitiveTypes.unknown, member_expr_node.expression)
        if this.has_errored() return null
        let prop_owner_type = prop_owner.value_type
        let prop_name = member_expr_node.member.value
        let prop_ty = PrimitiveTypes.unknown
        let parent_class: Class = null
        let prop_id: PropId = null
        let err_msg: String = null
        if is_object(prop_owner_type) {
            while prop_owner_type.kind == TypeKind.RESOLVED_GENERIC {
                prop_owner_type = (prop_owner_type as GenericType).instantiated_type
            }
            parent_class = this.program.get_class_from_type(prop_owner_type)
            prop_id = parent_class.prop_map[prop_name]
            if (prop_id == null){   
                this.error(ErrorKind.NAME, "Property '$prop_name' doesn't exist in object of class '$(parent_class.name)'", member_expr_node.member.range)
                return null
            }
            err_msg = this.check_member_access(prop_id)
            if (err_msg != null){
                this.error(ErrorKind.GEN, err_msg, member_expr_node.member.range)
                return null
            }
            prop_ty = this.program.get_class_prop_type(prop_id)
        } else if prop_owner_type.kind == TypeKind.RECORD {
            let var_id = (prop_owner as VarAccessExpression).value_id
            if var_id.kind == VarIdKind.CLASS {
                parent_class = this.get_class_from_var_id(var_id)
                prop_id = parent_class.static_prop_map[prop_name]
                if (prop_id == null) {   
                    this.error(ErrorKind.NAME, "Property '$prop_name' is not a static member in class '$(parent_class.name)'", member_expr_node.member.range)
                    return null
                }
                err_msg = this.check_member_access(prop_id)
                if (err_msg != null){
                    this.error(ErrorKind.GEN, err_msg, member_expr_node.member.range)
                    return null
                }
                prop_ty = this.program.get_class_prop_type(prop_id)
            } else {
                let parent_enum = this.get_enum_from_var_id(var_id)
                prop_id = parent_enum.field_map[prop_name]
                if (prop_id == null) {   
                    this.error(ErrorKind.NAME, "'$prop_name' is not an element of enum the '$(parent_enum.name)'", member_expr_node.member.range)
                    return null
                }
                prop_ty = new EnumType(parent_enum.id)
            }
        } else if is_pointer(prop_owner_type){
            // FIXME: Better way to express this.
            let mem_intrinsic = Intrinsics.MEMCPY 
            if prop_name == "copy_from" {
                mem_intrinsic = Intrinsics.MEMCPY 
            } else if prop_name == "move_from" {
               mem_intrinsic = Intrinsics.MEMMOVE
            } else if prop_name == "fill_with" {
                mem_intrinsic = Intrinsics.MEMSET
            } else if prop_name == "resize" {
                mem_intrinsic = Intrinsics.MEMRESIZE
            } else if prop_name == "compare" {
                mem_intrinsic = Intrinsics.MEMCMP
            } else {
                this.error(ErrorKind.NAME, "intrinsic $prop_name is not defined", member_expr_node.member.range)
                return null
            }
            let intrinsic_call = new IntrinsicCall(mem_intrinsic, PrimitiveTypes.unknown, member_expr_node.range) 
            intrinsic_call.args << prop_owner
            return intrinsic_call
        } else if prop_owner_type.kind == TypeKind.ARRAY {
            if prop_name == "size" {
                return new IntExpression((prop_owner_type as ArrayType).length as u64, member_expr_node.range)
            }
        } else if prop_owner_type.kind == TypeKind.MODULE {
            let scope_id = ((prop_owner as VarAccessExpression).value_id as ModuleVarId).scope_id
            let current_scope = this.current_scope
            this.current_scope = scope_id
            let var_access_node: VarAccessExpressionNode(member_expr_node.member)
            let value = this.check_var_access_expr(PrimitiveTypes.unknown, var_access_node)
            this.current_scope = current_scope
            return value
        } else {
            this.error(ErrorKind.GEN, "Cannot get property '$prop_name' of type '$(this.dump_type(prop_owner.value_type))'", member_expr_node.expression.range)
            return null
        }
        return new MemberExpression(prop_owner, prop_id, prop_ty, member_expr_node.range)
    }
    private check_ternary_expr(this, expected_type: Type, ternary_expr_node: TernaryExpressionNode): TernaryExpression {
        let cond = this.check_condition(ternary_expr_node.cond)
        if this.has_errored() return null
        let is_true = this.check_expression(expected_type, ternary_expr_node.is_true)
        if this.has_errored() return null
        let is_true_ty = is_true.value_type
        let is_false = this.check_expression(is_true_ty, ternary_expr_node.is_false)
        if this.has_errored() return null
        let is_false_ty = is_false.value_type
        if !this.types_are_eq(is_true_ty, is_false_ty) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(is_true_ty))' from first case but got type '$(this.dump_type(is_false_ty))'", ternary_expr_node.range)
            return null
        }
        return new TernaryExpression(cond, is_true, is_false)
    }
    private check_object_index_expr(this, object: Expression, index_expr_node: ExpressionIndexNode): Expression {
        let owner_class = this.program.get_class_from_type(object.value_type)
        let prop_id = owner_class.prop_map["__getitem__"]
        if prop_id == null {
            this.error(ErrorKind.GEN, "No operator overload for indexing operator on $(owner_class.name) object please implement method __getitem__ to use indexing in this class", index_expr_node.range)
            return null
        }
        let method_type = this.program.get_class_prop_type(prop_id) as FunctionType
        let arg_type = method_type.arg_types[1]
        let index = this.check_expression(arg_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(arg_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let member_expr = new MemberExpression(object, prop_id, method_type, index_expr_node.range)
        return new CallExpression(member_expr, [index], method_type.return_type, index_expr_node.range)
    }
    private check_tuple_index_expr(this, root_expression: Expression, index_expr_node: ExpressionIndexNode): Expression {
        let index = this.check_expression(PrimitiveTypes.uint, index_expr_node.index)
        if !is_int(index.value_type) {
            this.error(ErrorKind.TYPE, "Expected an integer type for index", index_expr_node.index.range)
            return null
        }
        if (index.value_type as IntType).is_signed {
            this.error(ErrorKind.TYPE, "Expected an unsigned integer for tuple index but index value is '$(this.dump_type(index.value_type))' (which is signed)", index_expr_node.index.range)
            return null
        }
        if !(index.is_constant) {
            this.error(ErrorKind.TYPE, "Expected an constant int for tuple index", index_expr_node.index.range)
            return null   
        }
        let index_value = evaluate_const_int_expression(this.program, index)
        let tuple_type = root_expression.value_type as TupleType
        if index_value < 0 or index_value >= tuple_type.element_types.length {
            this.error(ErrorKind.TYPE, "Index out of range for tuple type $(this.dump_type(tuple_type))", index_expr_node.index.range)
            return null
        }
        let value_type = tuple_type.element_types[index_value as uint]
        del index
        return new IndexExpression(root_expression, new IntExpression(index_value as u64, index_expr_node.index.range), value_type, index_expr_node.range)
    }
    private check_index_expr(this, index_expr_node: ExpressionIndexNode): Expression {
        let root_expression = this.check_expression(PrimitiveTypes.unknown, index_expr_node.expression)
        if this.has_errored() return null
        if is_object(root_expression.value_type)
            return this.check_object_index_expr(root_expression, index_expr_node)
        if root_expression.value_type.kind == TypeKind.TUPLE
            return this.check_tuple_index_expr(root_expression, index_expr_node)
        let index = this.check_expression(PrimitiveTypes.uint, index_expr_node.index)
        if this.has_errored() return null
        if !is_int(index.value_type) {
            this.error(ErrorKind.TYPE, "Expected an integer type for index", index_expr_node.index.range)
            return null
        }
        let value_type = PrimitiveTypes.unknown
        let root_type = root_expression.value_type
        if root_type.kind == TypeKind.PTR {
            value_type = (root_type as PointerType).pointee_type
        } else if root_type.kind == TypeKind.ARRAY {
            value_type = (root_type as ArrayType).element_type
        } else {
            this.error(ErrorKind.TYPE, "Cannot index into a value of type '$(this.dump_type(root_type))'", index_expr_node.range)
            return null
        }
        return new IndexExpression(root_expression, index, value_type, index_expr_node.range)
    }
    private get_func_args_from_expression(this, called: Expression): FunctionArg[]{
        if called.expr_kind == ExpressionKind.ACCESS {
            let var_id = (called as VarAccessExpression).value_id
            if var_id.kind == VarIdKind.FNC {
                return this.program.get_func(var_id).args
            }
        } else if called.expr_kind == ExpressionKind.MEMBER {
            let prop_id = (called as MemberExpression).member_id
            return this.program.get_method(prop_id).args
        }
        return null
    }
    private fill_in_default_call_args(this, fnc_ty: FunctionType, func_args: FunctionArg[], args: ExpressionNode[]): Expression[] {
        let called_args: Expression[] = []
        let offset = fnc_ty.has_implicit_this ? 1 : 0
        for let i = 0; i < args.length; i++ {
            let fnc_arg_idx = i + offset
            let expected_type = fnc_ty.arg_types.length > fnc_arg_idx ? fnc_ty.arg_types[fnc_arg_idx] : PrimitiveTypes.unknown
            called_args << this.check_expression(expected_type, args[i])
        }
        if this.has_errored() or func_args == null return called_args
        if (func_args.length - offset) > args.length {
            for arg in func_args {
                if arg.default != null
                    called_args << arg.default
            }
        }
        return called_args
    }
    private check_function_call_args_match(this, func_ty: FunctionType, args: Expression[]): int {
        let fnc_arg_types_len = func_ty.arg_types.length
        let check_start_offset = 0
        if func_ty.has_implicit_this {
            fnc_arg_types_len--
            check_start_offset = 1
        }
        if fnc_arg_types_len != args.length {
            return -1
        }
        for let i = 0; i < args.length; i++ {
            if !this.types_are_eq(func_ty.arg_types[i + check_start_offset], args[i].value_type) {
                return i as int
            }
        }
        return -2
    } 
    private position_args_by_name(this, func_ty: FunctionType, func_args: FunctionArg[], args: CallExpressionArg[]): ExpressionNode[] {
        let call_args: ExpressionNode[] = []
        let non_labeled_args: ExpressionNode[] = []
        let start = func_ty.has_implicit_this ? 1 : 0
        for let i = start; i < func_args.length; i++ {
            call_args << null
        }
        for arg in args {
            if (arg.name == null) {
                non_labeled_args << arg.value
                continue
            }

            let arg_name_found = false
            for let i = start; i < func_args.length; i++ {
                if (func_args[i].name == arg.name.value) {
                    arg_name_found = true
                    if (call_args[i] == null){
                        call_args[i] = arg.value
                    } else {
                        this.error(ErrorKind.NAME, "Repeated named argument '$(arg.name.value)' on function call", arg.name.range)
                        return call_args
                    }
                    break
                }
            }
            if (!arg_name_found){
                this.error(ErrorKind.NAME, "Unknown named argument '$(arg.name.value)' on function call", arg.name.range)
                return call_args
            }
        }
        let last_index = 0
        for non_labeled_arg in non_labeled_args {
            for last_index; last_index < call_args.length; last_index++ {
                if (call_args[last_index] == null) {
                    call_args[last_index] = non_labeled_arg
                    break
                }
            }
        }
        del non_labeled_args
        return call_args
    }
    private get_call_expression_node_list(this, args: CallExpressionArg[]): ExpressionNode[] {
        let call_args: ExpressionNode[] = []
        for arg in args {
            if (arg.name != null){
                this.error(ErrorKind.NAME, "Function doesn't have a named parameter", arg.name.range)
                return call_args
            }
            call_args << arg.value
        }
        return call_args
    }
    private check_and_fill_default_args(this, func_ty: FunctionType, func_args: FunctionArg[], call_args: ExpressionNode[]): Expression[] {
        let checked_call_args: Expression[] = []
        let offset = func_ty.has_implicit_this ? 1 : 0
        for let i = 0; i < call_args.length; i++ {
            let fnc_arg_idx = i + offset
            let expected_type = func_ty.arg_types.length > fnc_arg_idx ? func_ty.arg_types[fnc_arg_idx] : PrimitiveTypes.unknown
            if (call_args[i] == null){
                if (func_args != null) {
                    if (fnc_arg_idx < func_args.length) {
                        if (func_args[fnc_arg_idx].default != null) {
                            checked_call_args << func_args[fnc_arg_idx].default
                            continue
                        }
                    }
                }
            } else {
                checked_call_args << this.check_expression(expected_type, call_args[i])
            }
            if this.has_errored() return checked_call_args
        }
        return checked_call_args
    }
    private check_call_expr(this, expected_type: Type, call_expr_node: CallExpressionNode): CallExpression {
        let called = this.check_expression(PrimitiveTypes.unknown, call_expr_node.callee)
        if this.has_errored() return null
        if called.expr_kind == ExpressionKind.INTRINSIC and called.value_type.kind == TypeKind.UNKNOWN {
            return this.check_intrinsic_call(called as IntrinsicCall, call_expr_node) as CallExpression
        }
        if called.value_type.kind != TypeKind.FNC {
            this.error(ErrorKind.TYPE, "Expected a function type for call but got '$(this.dump_type(called.value_type))'", call_expr_node.callee.range)
            return null
        }
        //TODO: Check for generic functions.
        let func_ty = called.value_type as FunctionType
        let func_args = this.get_func_args_from_expression(called)
        let call_args = func_args == null ? this.get_call_expression_node_list(call_expr_node.args) : this.position_args_by_name(func_ty, func_args, call_expr_node.args)
        if this.has_errored() return null
        let adjusted_args = this.check_and_fill_default_args(func_ty, func_args, call_args)
        if this.has_errored() return null
        let index = this.check_function_call_args_match(func_ty, adjusted_args)
        if index >= -1 {
            if index == -1 {
                this.error(ErrorKind.GEN, "Expected $(func_ty.arg_types.length) argument(s) on function call but got $(adjusted_args.length)", call_expr_node.range)
            } else {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(func_ty.arg_types[index as uint]))' but got type '$(this.dump_type(adjusted_args[index as uint].value_type))' as function call argument", call_expr_node.args[index as uint].value.range)
            }
            return null
        }
        return new CallExpression(called, adjusted_args, func_ty.return_type, call_expr_node.range)
    }
    private check_intrinsic_call(this, intrinsic_call: IntrinsicCall, call_expr_node: CallExpressionNode): IntrinsicCall {
        //Note: This assumes that intrisics always have alteast 1 arg and that call_expr_node.args has the rest of the args
        let args = call_expr_node.args
        let intrinsic_func = intrinsic_call.intrinsic
        intrinsic_call.range = call_expr_node.range
        let is_mem_grp1 = intrinsic_func == Intrinsics.MEMCPY or intrinsic_func == Intrinsics.MEMMOVE or intrinsic_func == Intrinsics.MEMCMP
        
        let uint_ty = PrimitiveTypes.uint
        let unknown_ty = PrimitiveTypes.unknown
        
        for let i = 0; i < args.length; i++ {
            if args[i].name != null {
                this.error(ErrorKind.NAME, "Intrinsic doesn't have a named parameter", args[i].name.range)
                return intrinsic_call
            }
            let expected_type = is_mem_grp1 and i == 1 ? unknown_ty : intrinsic_call.args[0].value_type
            if (intrinsic_func == Intrinsics.MEMCPY or intrinsic_func == Intrinsics.MEMMOVE) and (i == 1) {
                expected_type = uint_ty
            }
            if (intrinsic_func == Intrinsics.MEMRESIZE) and (i == 0) {
                expected_type = uint_ty
            }
            if (intrinsic_func == Intrinsics.MEMSET){
                expected_type = uint_ty
            }
            let arg_value = this.check_expression(expected_type, args[i].value)
            if this.has_errored() return null
            if expected_type.kind != TypeKind.UNKNOWN {
                if !this.types_are_eq(expected_type, arg_value.value_type) {
                    this.error(ErrorKind.TYPE, "Expected argument $i to be of type '$(this.dump_type(expected_type))' but got type '$(this.dump_type(arg_value.value_type))'", args[i].value.range)
                    return null
                }
            }
            intrinsic_call.args << arg_value
        }
        // Mem intrinsics
        if !is_pointer(intrinsic_call.args[0].value_type) {
            this.error(ErrorKind.TYPE, "Expected argument 1 to be of type to be of a pointer but got '$(this.dump_type(intrinsic_call.args[0].value_type))'", call_expr_node.callee.range)
            return null
        }
        if intrinsic_func == Intrinsics.MEMRESIZE {
            if intrinsic_call.args.length != 2 {
                this.error(ErrorKind.GEN, "Expected 2 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            intrinsic_call.value_type = intrinsic_call.args[0].value_type
        } else if is_mem_grp1 or intrinsic_func == Intrinsics.MEMSET {
            if intrinsic_call.args.length != 3 {
                this.error(ErrorKind.GEN, "Expected 3 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            let exp_arg2_type = intrinsic_call.args[0].value_type
            intrinsic_call.value_type = exp_arg2_type
            if intrinsic_func == Intrinsics.MEMCMP {
                intrinsic_call.value_type = PrimitiveTypes.int
            }
        }
        return intrinsic_call
    }
    private check_int_expression(this, expected_type: Type, int_node: IntExpressionNode): IntExpression{
        let int_value = int_node.value.value
        let expr_value = new IntExpression(int_value, int_node.range)
        if is_int(expected_type){
            expr_value.value_type = expected_type
        }
        if int_value < -8 or int_value > 7 and expr_value.value_type.kind == TypeKind.I4
            expr_value.value_type = PrimitiveTypes.i8
        if int_value < -128 or int_value > 127 and expr_value.value_type.kind == TypeKind.I8
            expr_value.value_type = PrimitiveTypes.i16
        if int_value < -32768 or int_value > 32767 and expr_value.value_type.kind == TypeKind.I16
            expr_value.value_type = PrimitiveTypes.i32
        if int_value < -2147483648 or int_value > 2147483647 and (expr_value.value_type.kind == TypeKind.I32 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 32))
            expr_value.value_type = PrimitiveTypes.i64
        if int_value < -9223372036854775808 or int_value > 9223372036854775807 and (expr_value.value_type.kind == TypeKind.I64 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 64))
            expr_value.value_type = PrimitiveTypes.i128
        return expr_value
    }
    private check_float_expression(this, expected_type: Type, float_node: FloatExpressionNode): FloatExpression {
        let float_value = float_node.value.value
        let expr_value = new FloatExpression(float_value, float_node.range)
        let max_f32 = "3.4E38" as f64
        if is_float(expected_type)
            expr_value.value_type = expected_type
        if float_value < -max_f32 or float_value > max_f32 and expr_value.value_type.kind == TypeKind.F32
            expr_value.value_type = PrimitiveTypes.f64

        return expr_value
    }
    private check_char_expression(this, char_node: CharExpressionNode): IntExpression {
        let expr_value = new IntExpression(char_node.value.value as u64, char_node.range)
        expr_value.value_type = PrimitiveTypes.u8
        return expr_value
    }
    private check_string_expression(this, expected_type: Type, str_node: StringExpressionNode): StringExpression{
        let template_args: Expression[] = []
        let is_const = true
        for arg in str_node.template_args {
            template_args << this.check_expression(PrimitiveTypes.unknown, arg)
            is_const = false
        }
        if !is_u8_ptr(expected_type) {
            expected_type = this.get_type_from_current_scope("String")
            is_const = false
        }
        let str_exp = new StringExpression(str_node.value.value, str_node.value.fmt_indices, template_args, expected_type, str_node.range)
        str_exp.is_constant = is_const
        return str_exp
    }
    private check_range_expr(this, expected_type: Type, range_node: RangeExpressionNode): Expression {
        let unknown = PrimitiveTypes.unknown
        let left = this.check_expression(unknown, range_node.left)
        let right = this.check_expression(unknown, range_node.right)
        if left.value_type.kind == TypeKind.INT and right.value_type.kind == TypeKind.INT {
            // TODO: Check Range is an object type
            return new RangeExpression(left, right, this.get_type_from_current_scope("Range"))
        }
        this.error(ErrorKind.TYPE, "Cannot create a range between types '$(this.dump_type(left.value_type))' and '$(this.dump_type(right.value_type))'", TextRange.merge(range_node.left.range, range_node.right.range))
        return left
    }
    private check_expression(this, expected_type: Type, expr_node: ExpressionNode): Expression {
        if expr_node.expr_kind == ExpressionKind.INT 
            return this.check_int_expression(expected_type, expr_node as IntExpressionNode)
        if expr_node.expr_kind == ExpressionKind.FLOAT
            return this.check_float_expression(expected_type, expr_node as FloatExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CHAR
            return this.check_char_expression(expr_node as CharExpressionNode)
        if expr_node.expr_kind == ExpressionKind.STRING 
            return this.check_string_expression(expected_type, expr_node as StringExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expected_type, expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TUPLE
            return this.check_tuple_expression(expected_type, expr_node as TupleExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ACCESS
            return this.check_var_access_expr(expected_type, expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expected_type, expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expected_type, expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TERNARY
            return this.check_ternary_expr(expected_type, expr_node as TernaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CAST
            return this.check_typecast_expr(expr_node as TypeCastExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MEMBER
            return this.check_member_expr(expected_type, expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expr_node as ExpressionIndexNode)
        if expr_node.expr_kind == ExpressionKind.CALL
            return this.check_call_expr(expected_type, expr_node as CallExpressionNode)
        if expr_node.expr_kind == ExpressionKind.RANGE
            return this.check_range_expr(expected_type, expr_node as RangeExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MATCH
            return this.check_match_expr(expected_type, expr_node as MatchExpressionNode)
        return null
    }
    private check_condition(this, cond_node: ExpressionNode): Expression {
       let condition = this.check_expression(PrimitiveTypes.unknown, cond_node)
       if this.has_errored() return null
       return !is_bool(condition.value_type) ? cast_exp_to_type(condition, PrimitiveTypes.bool) : condition
    }
    private check_match_expr(this, expected_type: Type, match_node: MatchExpressionNode): MatchExpression {
        let subject = this.check_expression(PrimitiveTypes.unknown, match_node.subject)
        if this.has_errored() return null
        if is_null_expression(subject){
            this.error(ErrorKind.TYPE, "Cannot match on constant 'null'", match_node.subject.range)
            return null
        }
        let use_ifs = is_object(subject.value_type)
        let match_expression = new MatchExpression(subject, use_ifs)
        let result_type = PrimitiveTypes.unknown
        for case in match_node.cases {
            let expression: Expression = null
            let match_case_kind = MatchCaseKind.EEQ
            if (use_ifs) {
                let bin_exp: BinaryExpressionNode(match_node.subject, BinaryOp.EEQ, case.condition)
                expression = this.check_object_binary_expr(subject, bin_exp, null)
                if this.has_errored() return null
                match_case_kind = MatchCaseKind.VAL
                if !is_bool(expression.value_type) {
                    this.error(ErrorKind.TYPE, "Operator overload == for '$(this.dump_type(subject.value_type))' should return a boolean to be used in match expression", case.condition.range)
                    return null
                }
            } else {
                expression = this.check_expression(subject.value_type, case.condition)
                if this.has_errored() return null
                if !this.types_are_eq(subject.value_type, expression.value_type){
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(subject.value_type))' from match expression subject but got type '$(this.dump_type(expression.value_type))'", case.condition.range)
                    return null
                }
            }
            let block = this.check_block(case.block, null, true)
            if this.has_errored() return null
            let case_type = block.yields != null ? block.yields.value_type : PrimitiveTypes.void
            if result_type.kind == TypeKind.UNKNOWN {
                result_type = case_type
            } else if !this.types_are_eq(result_type, case_type){
                this.error(ErrorKind.TYPE, "Expected match case block to yield '$(this.dump_type(result_type))' but yielded '$(this.dump_type(case_type))'", case.condition.range)
                return null
            }
            match_expression.cases << new MatchExpressionCase(match_case_kind, expression, block)
        }
        if match_node.else_block == null {
            this.error(ErrorKind.GEN, "Non-exhaustable match expression, expected an else-case", match_node.range)
            return null
        } else {
            let block = this.check_block(match_node.else_block, null, true)
            let case_type = block.yields != null ? block.yields.value_type : PrimitiveTypes.void
            if !this.types_are_eq(result_type, case_type){
                this.error(ErrorKind.TYPE, "Expected match else-case block to yield '$(this.dump_type(result_type))' but yielded '$(this.dump_type(case_type))'", match_node.range)
                return null
            }
            match_expression.else_block = block
        }
        match_expression.value_type = result_type
        return match_expression
    }
    private check_if_stamement(this, if_stmt_node: IfStatementNode): IfStatement {
        let condition = this.check_condition(if_stmt_node.condition)
        let block = this.check_block(if_stmt_node.block)
        let else_block = if_stmt_node.else_block != null ? this.check_block(if_stmt_node.else_block) : null
        return new IfStatement(condition, block, else_block)
    }
    private check_var_declaration(this, var_decl_node: VarDeclarationStatement): VarDeclaration {
        let name = var_decl_node.var_name.value
        if this.is_constant_in_scope(name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", var_decl_node.var_name.range)
            return null
        }
        let current_scope = this.get_current_scope()
        let var_type = var_decl_node.var_type != null ? this.check_type(var_decl_node.var_type) : PrimitiveTypes.unknown
        if this.has_errored() return null
        if var_decl_node.value == null and var_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.GEN, "Variable '$name' has no type", var_decl_node.var_name.range)
            return null
        }
        let value = var_decl_node.value != null ? this.check_expression(var_type, var_decl_node.value) : null
        if this.has_errored() return null
        if value != null {
            if is_null_expression(value) and value.value_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", var_decl_node.range)
                return null
            }
            if var_type.kind != TypeKind.UNKNOWN and !this.types_are_eq(var_type, value.value_type) {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(var_type))' but got type '$(this.dump_type(value.value_type))' on variable declaration", var_decl_node.range)
                return null
            }
            if var_type.kind == TypeKind.UNKNOWN {
                var_type = value.value_type
            }
            if var_type.kind == TypeKind.VOID {
                this.error(ErrorKind.TYPE, "Cannot declare a variable of type void", var_decl_node.range)
                return null
            }
        }
        if current_scope.vars[name] != null {
            let var_type  = var_decl_node.is_const ? "constant" : "variable"
            this.error(ErrorKind.NAME, "Illegal re-declaration of already declared $var_type '$name'", var_decl_node.var_name.range)
            return null
        }
        let var = this.declare_var_within_current_scope(name, value, var_type, var_decl_node.is_const)
        return new VarDeclaration(var_decl_node.var_name.range, name, var.var_id)
    }
    private check_for_in_statement(this, for_in_stmt_node: ForInStatementNode): ForInStatement {
        let for_scope = this.create_child_scope_within_current_scope()
        this.current_scope = for_scope.id
        let prev_in_loop = this.in_loop
        let iterator = this.check_expression(PrimitiveTypes.unknown, for_in_stmt_node.iterator)
        if this.has_errored() return null
        if !is_object(iterator.value_type) {
            this.error(ErrorKind.TYPE, "Iterator has to be an object", for_in_stmt_node.iterator.range)
            return null
        }
        let iterator_class = this.program.get_class_from_type(iterator.value_type)
        let iter_prop_id = iterator_class.prop_map["__iter__"]
        if iter_prop_id == null {
            this.error(ErrorKind.TYPE, "Iterator type has to have __iter__ as property", for_in_stmt_node.iterator.range)
            return null
        }
        let iter_item_name =  for_in_stmt_node.it_name.value
        if this.has_errored() return null
        let iteratable_ty = (this.program.get_class_prop_type(iter_prop_id) as FunctionType).return_type
        let iteratable_class = this.program.get_class_from_type(iteratable_ty)
        let next_it_prop_id = iteratable_class.prop_map["next"]
        let iter_item_type = (this.program.get_class_prop_type(next_it_prop_id) as FunctionType).return_type
        this.in_loop = true
        let var = this.declare_var_within_current_scope(iter_item_name, null, iter_item_type, false)
        let for_block = this.check_block(for_in_stmt_node.block, for_scope, false)
        let for_in_stmt = new ForInStatement(new VarDeclaration(for_in_stmt_node.it_name.range, iter_item_name, var.var_id), iterator, for_block)
        this.in_loop = prev_in_loop
        return for_in_stmt
    }
    private check_for_statement(this, for_stmt_node: ForStatementNode): ForStatement {
        let for_stmt = new ForStatement()
        let for_scope = this.create_child_scope_within_current_scope()
        this.current_scope = for_scope.id
        let prev_in_loop = this.in_loop
        this.in_loop = true
        if for_stmt_node.initialization != null
            for_stmt.initialization = this.check_statement(for_stmt_node.initialization)
        if for_stmt_node.condition != null
            for_stmt.condition = this.check_condition(for_stmt_node.condition)
        if for_stmt_node.update != null
            for_stmt.update = this.check_expression(PrimitiveTypes.unknown, for_stmt_node.update)
        
        for_stmt.block = this.check_block(for_stmt_node.block, for_scope, false)
        this.in_loop = prev_in_loop
        return for_stmt
    }
    private check_while_statment(this, while_stmt_node: WhileStatementNode): WhileStatement {
        let condition = this.check_condition(while_stmt_node.condition)
        let prev_in_loop = this.in_loop
        this.in_loop = true
        let block = this.check_block(while_stmt_node.block)
        this.in_loop = prev_in_loop
        return new WhileStatement(condition, block)
    }
    private check_can_break(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal break outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.BREAK)
    }
    private check_can_continue(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal continue outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.CONTINUE)
    }
    private check_can_return(this, return_stmt: ReturnStatementNode): ReturnStatement {
        let expr = return_stmt.value
        let current_function_return_type = this.get_current_function_type().return_type
        let rt_stmt = new ReturnStatement()
        if expr != null {
            let rt_value = this.check_expression(current_function_return_type, expr)
            if this.has_errored() return null   
            if !this.types_are_eq(current_function_return_type, rt_value.value_type) {
                this.error(ErrorKind.TYPE, "Expected return type of '$(this.dump_type(current_function_return_type))' but got return type of '$(this.dump_type(rt_value.value_type))'", expr.range)
                return null
            }
            rt_stmt.return_value = rt_value
        } else {
            if current_function_return_type.kind != TypeKind.VOID {
                this.error(ErrorKind.TYPE, "Function return type is not void", return_stmt.range)
                return null
            }
        }
        return rt_stmt
    }
    private check_statement(this, stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.FOR_IN
            return this.check_for_in_statement(stmt_node as ForInStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue(stmt_node)
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break(stmt_node)
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode))
        if stmt_node.kind == StatementKind.EXPRESSION
            return this.check_expression(PrimitiveTypes.unknown, stmt_node as ExpressionNode)
        panic("Unknown statement kind")
        return null
    }
    private check_block(this, block_node: BlockNode, block_scope: Scope = null, yields: bool = false): Block {
        let block = new Block(block_node.range)
        block_scope = block_scope != null ? block_scope : this.create_child_scope_within_current_scope() //TODO: Use ?? in the future
        this.current_scope = block_scope.id
        let stmt: Statement = null
        for stmt_node in block_node.statements {
            stmt = this.check_statement(stmt_node)
            if this.has_errored() return null
            block.statements << stmt
            if stmt.kind == StatementKind.RETURN {
                block.returns = true
                break
            }
            if stmt.kind == StatementKind.IF {
                let if_stmt = stmt as IfStatement
                if if_stmt.else_block != null {
                    if if_stmt.block.returns and if_stmt.else_block.returns {
                        block.returns = true
                        break
                    }
                }
            }
            if stmt.kind == StatementKind.CONTINUE {
                block.continues = true
                break
            }
            if stmt.kind == StatementKind.BREAK {
                block.breaks = true
                break
            }
        }
        if stmt != null {
            if yields and (stmt.kind == StatementKind.EXPRESSION) {
                block.yields = stmt as Expression
                block.statements.pop()
            }
        }
        this.current_scope = block_scope.parent
        return block
    }
}