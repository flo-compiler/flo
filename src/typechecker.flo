import ARCH_WORD_SIZE in "@sys/lib"
import "@path/path"
import "types"
import Compiler in "compiler"
import FloRange in "utils"
import FloError, ErrorKind in "error"
import Lexer, IdentifierToken in "lexer"
import "parser"
class Type {
    kind: TypeKind
    constructor(this, kind: TypeKind){
        this.kind = kind
    }
    unknown(): Type {
        return new Type(TypeKind.UNKNOWN)
    }
}
class BooleanType (Type) {
    constructor(this){
        super(TypeKind.BOOL)
    }
}
class PointerType (Type) {
    pointee_type: Type
    constructor(this, pointee_type: Type){
        super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType (Type) {
    arg_types: Type[]
    return_type: Type
    has_this: bool //TODO: Need to eliminate this at some point.
    constructor(this, arg_types: Type[], return_type: Type){
        super(TypeKind.FNC)
        this.arg_types = arg_types
        this.return_type = return_type
    }
}
class Value {
    value_type: Type
}
class Statement {
    kind: StatementKind
    constructor(this, kind: StatementKind){
        this.kind = kind
    }
}
class TypeId {
    module_id: int
    kind: TypeIdKind
    id: int
    constructor(this, module_id: int, kind: TypeIdKind, id: int){
        this.module_id = module_id
        this.kind = kind
        this.id =  id
    }
}
class ClassId(TypeId) {
    constructor(this, module_id: int, id: int){
        super(module_id, TypeIdKind.CLASS, id)
    }
}
class EnumId(TypeId) {
    constructor(this, module_id: int, id: int){
        super(module_id, TypeIdKind.ENUM, id)
    }
}
class Expression (Statement) {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    constructor(this, expr_kind: ExpressionKind){
        super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.is_constant = false
    }
}
class ArrayType (Type) {
    element_type: Type
    length: int
    constructor(this, element_type: Type, length: int){
        super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
}
class GenericType(Type) {
    name: string
    arg_types: Type[]
    instantiated_type: Type
    constructor(this, name: string, arg_types: Type[], instantiated_type: Type){
        super(TypeKind.RESOLVED_GENERIC)
        this.name = name
        this.arg_types = arg_types
        this.instantiated_type = instantiated_type
    }
}
class ObjectType (Type) {
    class_id: ClassId
    constructor(this, class_id: ClassId){
        super(TypeKind.OBJECT)
        this.class_id = class_id
    }
}
class EnumType (Type) {
    enum_id: EnumId
    constructor(this, enum_id: EnumId){
        super(TypeKind.ENUM)
        this.enum_id = enum_id
    }
}
class IntExpression (Expression) {
    value: i64
    constructor(this, value: i64){
        super(ExpressionKind.INT)
        this.value_type = new Type(TypeKind.INT)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression (Expression) {
    value: bool 
    constructor(this, value: bool){
        super(ExpressionKind.BOOL)
        let bool_type = new BooleanType()
        this.value_type = bool_type
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression (Expression) {
    value: f64
    constructor(this, value: f64){
        super(ExpressionKind.FLOAT)
        this.value_type = new Type(TypeKind.F64)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression (Expression) {
    value: string
    fmt_indices: int[]
    template_args: Expression[]
    constructor(this, value: string, fmt_indices: int[], template_args: Expression[], value_type: Type){
        super(ExpressionKind.STRING)
        this.template_args = template_args
        this.fmt_indices = fmt_indices
        this.value_type = value_type
        this.value = value
        this.is_constant = true
    }
}
class NullExpression (Expression) {
    constructor(this, value_type: Type){
        super(ExpressionKind.NULL)
        this.value_type = value_type 
        this.is_constant = true
    }
}
class ArrayExpression (Expression) {
    elements: Expression[]
    constructor(this, elements: Expression[]){
        super(ExpressionKind.ARRAY)
        this.elements = elements
    }
}
class BinaryExpression (Expression) {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(this, lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type, is_constant = false){
        super(ExpressionKind.BIN)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.value_type = value_type
        this.is_constant = is_constant
    }
}
class UnaryExpression (Expression) {
    op: UnaryOp
    expression: Expression
    constructor(this, op: UnaryOp, expression: Expression, value_type: Type, is_constant = false){
        super(ExpressionKind.UNARY)
        this.op = op
        this.expression = expression
        this.value_type = value_type
        this.is_constant = is_constant
    }
}
class TernaryExpression (Expression) {
    cond: Expression
    is_true: Expression
    is_false: Expression
    constructor(this, cond: Expression, is_true: Expression, is_false: Expression){
        super(ExpressionKind.TERNARY)
        this.cond = cond
        this.is_true = is_true
        this.is_false = is_false
        this.value_type = is_true.value_type
    }
}
class TypeCastExpression (Expression) {
    expr: Expression
    constructor(this, expr: Expression, value_type: Type){
        super(ExpressionKind.CAST)
        this.expr = expr
        this.value_type = value_type
        this.is_constant = expr.is_constant
    }
}
class NewExpression (Expression) {
    args: Expression[]
    onheap: bool
    memory_type: Type
    constructor(this, memory_type: Type, value_type: Type, args: Expression[], onheap: bool){
        super(ExpressionKind.NEW)
        this.memory_type = memory_type
        this.onheap = onheap
        this.args = args
        this.value_type = value_type
    }
}
class IndexExpression (Expression) {
    expression: Expression
    index: Expression
    constructor(this, expression: Expression, index: Expression, value_type: Type){
        super(ExpressionKind.INDEX)
        this.expression = expression
        this.index = index
        this.value_type = value_type
    }
}
class CallExpression (Expression) {
    callee: Expression
    args: Expression[]
    constructor(this, callee: Expression, args: Expression[], value_type: Type){
        super(ExpressionKind.CALL)
        this.callee = callee
        this.args = args
        this.value_type = value_type
    }
}
class IntrinsicCall (Expression) {
    intrinsic: Intrinsics
    args: Expression[]
    constructor(this, intrinsic: Intrinsics){
        super(ExpressionKind.INTRINSIC)
        this.intrinsic = intrinsic
        this.args = []
        this.value_type = Type.unknown()
    }
}
class VarId {
    kind: VarIdKind
    module_id: int
    id: int
    constructor(this, kind: VarIdKind, module_id: int, id: int){
        this.kind = kind
        this.module_id = module_id
        this.id = id
    }
}
class ClassVarId(VarId){
    constructor(this, class_id: ClassId){
        super(VarIdKind.CLASS, class_id.module_id, class_id.id)
    }
    public to_classId(var_id: VarId): ClassId {
        return new ClassId(var_id.module_id, var_id.id)
    }
}
class EnumVarId(VarId){
    constructor(this, enum_id: EnumId){
        super(VarIdKind.ENUM, enum_id.module_id, enum_id.id)
    }
    public to_enumId(var_id: VarId): EnumId {
        return new EnumId(var_id.module_id, var_id.id)
    }
}
class ConstId(VarId) {
    constructor(this, module_id: int, id: int){
       super(VarIdKind.CONST, module_id, id)
    }
}
class PropId {
    kind: PropIdKind
    type_id: TypeId
    id: int
    constructor(this, kind: PropIdKind, type_id: TypeId, id: int){
        this.kind = kind
        this.type_id = type_id
        this.id = id
    }
}
class MemberExpression (Expression) {
    expression: Expression
    member_id: PropId
    constructor(this, expression: Expression, member_id: PropId, value_type: Type){
        super(ExpressionKind.MEMBER)
        this.expression = expression
        this.member_id = member_id
        this.value_type = value_type
    }
}
class VarAccessExpression (Expression) {
    value_id: VarId
    constructor(this, value_id: VarId, value_type: Type){
        super(ExpressionKind.ACCESS)
        this.value_id = value_id
        this.value_type = value_type
        this.is_constant = value_id.kind == VarIdKind.CONST
    }
}
class Block {
    statements: Statement[]
    returns: bool /* Block contains a return */
    continues: bool /* Block contains a continue */
    breaks: bool /* Block contains a break */
    constructor(this){
        this.statements = []
        this.returns = false
        this.continues = false
        this.breaks = false
    }
}
class IfStatement (Statement) {
    condition: Expression
    block: Block
    else_block: Block
    constructor(this, condition: Expression, block: Block, else_block: Block){
        super(StatementKind.IF)
        this.condition = condition
        this.block = block
        this.else_block = else_block
    }
}
class VarDeclaration (Statement) {
    name: string
    var_id: VarId
    is_static: bool
    constructor(this, name: string, var_id: VarId){
        super(StatementKind.VAR)
        this.var_id = var_id
        this.name = name
        this.is_static = false
    }
}
class ConstDeclaration (Statement) {
    name: string
    const_id: ConstId
    is_static: bool
    constructor(this, name: string, const_id: ConstId){
        super(StatementKind.CONST)
        this.const_id = const_id
        this.name = name
        this.is_static = false
    }
}
class ForStatement (Statement) {
    for_in_setup: Statement
    initialization: Statement
    condition: Expression
    incr_decr: Statement
    block: Block
    constructor(this){
        super(StatementKind.FOR)
        this.for_in_setup = null
        this.initialization = null
        this.condition = null
        this.incr_decr = null
    }
}
class WhileStatement (Statement) {
    condition: Expression
    block: Block
    constructor(this, condition: Expression, block: Block){
        super(StatementKind.WHILE)
        this.condition = condition
        this.block = block
    }
}
class ReturnStatement (Statement) {
    return_value: Expression
    constructor(this){
        super(StatementKind.RETURN)
        this.return_value = null
    }
}
fnc is_numeric(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.F64
}
fnc is_float(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.F32 and val_ty.kind <= TypeKind.F64
}
fnc is_int(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.I128
}
fnc is_bool(val_ty: Type): bool {
    return val_ty.kind == TypeKind.BOOL
}
fnc is_i8_ptr(val_ty: Type): bool {
    if val_ty.kind == TypeKind.PTR
        return (val_ty as PointerType).pointee_type.kind == TypeKind.I8
    return false
}
fnc is_object(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.RESOLVED_GENERIC)
        return is_object((val_ty as GenericType).instantiated_type)
    return val_ty.kind == TypeKind.OBJECT
}
fnc is_function(val_ty: Type): bool {
    return val_ty.kind == TypeKind.FNC
}
fnc is_pointer(val_ty: Type): bool {
    return val_ty.kind == TypeKind.PTR
}
fnc is_null(exp: Expression): bool {
    return exp.expr_kind == ExpressionKind.NULL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    return new TypeCastExpression(exp, val_ty)
}
fnc max_type(t1: Type, t2: Type): Type {
    return t1.kind > t2.kind ? t1 : t2
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    let ty1 = p1[0].value_type
    let ty2 = p2[0].value_type
    if ty1.kind != ty2.kind {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc check_is_var(expr: Expression): bool{
    if expr.expr_kind == ExpressionKind.ACCESS {
        return (expr as VarAccessExpression).value_id.kind == VarIdKind.VAR
    }
    if expr.expr_kind == ExpressionKind.MEMBER {
        let prop_id = (expr as MemberExpression).member_id
        return prop_id.kind == PropIdKind.FIELD
    }
    return expr.expr_kind == ExpressionKind.INDEX
}
fnc dump_type(ty: Type, force_bit_size = false): string {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if ty.kind == TypeKind.I4
        return "i4" 
    if ty.kind == TypeKind.I8
        return "i8"
    if ty.kind == TypeKind.I16
        return "i16"
    if ty.kind == TypeKind.I32
        return "i32"
    if ty.kind == TypeKind.I64
        return "i64"
    if ty.kind == TypeKind.I128
        return "i128"
    if ty.kind == TypeKind.INT
        return force_bit_size ? "i$ARCH_WORD_SIZE" : "int"
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.VOID
        return "void"
    if ty.kind == TypeKind.RECORD
        return "record"
    return "unknown"
}
fnc dump_bin_op(op: BinaryOp): string {
    if op == BinaryOp.ADD
        return "+"
    if op == BinaryOp.SUB
        return "-"
    if op == BinaryOp.MUL
        return "*"
    if op == BinaryOp.DIV
        return "/"
    if op == BinaryOp.MOD
        return "**"
    if op == BinaryOp.POW
        return "^"
    if op == BinaryOp.GT
        return ">"
    if op == BinaryOp.GTE
        return ">="
    if op == BinaryOp.LT
        return "<"
    if op == BinaryOp.LTE
        return "<="
    if op == BinaryOp.EEQ
        return "=="
    if op == BinaryOp.NEQ
        return "!="
    if op == BinaryOp.SL
        return "<<"
    if op == BinaryOp.SR
        return ">>"
    if op == BinaryOp.OR
        return "or"
    if op == BinaryOp.AND
        return "and"
    if op == BinaryOp.XOR
        return "^"
    if op == BinaryOp.IN
        return "in"
    if op == BinaryOp.ASSIGN
        return "="
    return ".."
}
fnc dump_unary_op(op: UnaryOp): string{
    if op == UnaryOp.PREINCR
        return "++(pre)"
    if op == UnaryOp.PREDECR
        return "--(pre)"
    if op == UnaryOp.POSTINCR
        return "(post)++"
    if op == UnaryOp.POSTDECR
        return "(post)--"
    if op == UnaryOp.NEG
        return "-"
    if op == UnaryOp.NOT
        return "!"
    return "&"
}
fnc dump_access(visibility: ACCESS_ATTR): string {
    if visibility == ACCESS_ATTR.PRIVATE
        return "private"
    if visibility == ACCESS_ATTR.PUBLIC
        return "public"
    return "protected"
}
fnc lower_bin_assign_node(binary_node: BinaryExpressionNode): BinaryExpressionNode {
    let op = binary_node.op
    if op == BinaryOp.ADD_ASSIGN
        op = BinaryOp.ADD
    if op == BinaryOp.SUB_ASSIGN
        op = BinaryOp.SUB
    if op == BinaryOp.MUL_ASSIGN
        op = BinaryOp.MUL
    if op == BinaryOp.DIV_ASSIGN
        op = BinaryOp.DIV
    if op == BinaryOp.MOD_ASSIGN
        op = BinaryOp.MOD
    if op == BinaryOp.POW_ASSIGN
        op = BinaryOp.POW
    if op == BinaryOp.AND_ASSIGN
        op = BinaryOp.AND
    if op == BinaryOp.OR_ASSIGN
        op = BinaryOp.OR
    if op == BinaryOp.SL_ASSIGN
        op = BinaryOp.SL
    if op == BinaryOp.SR_ASSIGN
        op = BinaryOp.SR
    return new BinaryExpressionNode(binary_node.lhs, op, binary_node.rhs)
}
class ScopeId {
    module_id: int
    id: int
    constructor(this, module_id: int, id: int){
        this.module_id = module_id
        this.id = id
    }
}
class ModuleVarId(VarId){
    scope_id: ScopeId
    constructor(this, scope_id: ScopeId){
        super(VarIdKind.MODULE, scope_id.module_id, scope_id.id)
        this.scope_id = scope_id
    }
}
class Scope {
    public id: ScopeId
    public vars: [string: VarId]
    public classes: [string: ClassId]
    public functions: [string: VarId]
    public enums: [string: EnumId]
    public parent: ScopeId
    public type_aliases: [string: Type]
    constructor(this, module_id: int, id: int){
        this.id = new ScopeId(module_id, id)
        this.vars = new Map<string, VarId>()
        this.classes = new Map<string, ClassId>()
        this.functions = new Map<string, VarId>()
        this.enums = new Map<string, EnumId>()
        this.type_aliases = new Map<string, Type>()
        this.parent = null 
    }
    private __del__(this){
        del this.id
        del this.vars
        del this.classes
        del this.functions
        del this.enums
        del this.type_aliases
    }
}
class FunctionArg(Expression) {
    id: VarId
    name: string
    default: Expression
    constructor(this){
        super(ExpressionKind.ACCESS)
    }
}
class Function {
    id: VarId
    name: string
    args: FunctionArg[]
    block: Block
    fnc_type: FunctionType
    scope: ScopeId
    is_external: bool
    constructor(this){
        this.is_external = false
    }
}
class Var (Value) {
    var_id: VarId
    value: Expression
    constructor(this, value: Expression, value_type: Type){
        this.value = value
        this.value_type = value_type
    }
}
class Const (Value) {
    const_id: ConstId
    value: Expression
    constructor(this, value: Expression, value_type: Type){
        this.value = value
        this.value_type = value_type
    }
}

class ClassField {
    id: PropId
    is_static: bool
    visibility: ACCESS_ATTR
    name: string
    field_type: Type
    initializer: Expression
    vtable_index: int
    constructor(this){
        this.is_static = false
    }
}
class ClassMethod {
    id: PropId
    is_static: bool
    visibility: ACCESS_ATTR
    name: string
    method_type: FunctionType
    block: Block
    args: FunctionArg []
    is_abstract: bool
    scope: ScopeId
    vtable_index: int
    constructor(this){
        this.is_abstract = false
    }
}
class Class {
    id: ClassId
    name: string
    parent: Type
    construct: PropId
    fields: ClassField[]
    methods: ClassMethod[]
    prop_map: [string: PropId]
    static_prop_map: [string: PropId]
    inherited_methods_num: int
    inherited_fields_num: int
    is_abstract: bool
    constructor(this){
        this.construct = null
        this.inherited_fields_num = 0
        this.inherited_methods_num = 0
        this.fields = []
        this.methods = []
        this.prop_map = new Map<string, PropId>()
        this.static_prop_map = new Map<string, PropId>()
        this.is_abstract = false
    }
    private __del__(this){
        del this.id
        del this.name
        if this.parent del this.parent
        for field in this.fields {
            del field
        }
        for method in this.methods {
            del method
        }
        del this.prop_map
        del this.static_prop_map
    }
}
class EnumField {
    id: PropId
    name: string
    initializer: Expression
    constructor(this, name: string){
        this.name = name
    }
    private __del__(this){
        del this.id
        del this.name
        del this.initializer
    }
}
class Enum {
    id: EnumId
    name: string
    fields: EnumField[]
    field_map: [string: PropId]
    constructor(this){
        this.fields = []
        this.field_map = new Map<string, PropId>()
    }
    private __del__(this){
        del this.id
        del this.name
        for field in this.fields {
            del field
        }
        del this.fields
        del this.field_map
    }
}
class Module {
    id: int
    name: string
    vars: Var[]
    consts: Const[]
    classes: Class[]
    functions: Function[]
    scope: ScopeId
    enums: Enum[]
    scopes: Scope[]
    global_consts: ConstDeclaration[]
    global_vars: VarDeclaration[]
    constructor(this, name: string){
        this.name = name
        this.functions = []
        this.vars = []
        this.classes = []
        this.enums = []
        this.scopes = []
        this.global_consts = []
        this.global_vars = []
        this.consts = []
    }
    private __del__(this){
        for func in this.functions {
            del func
        }
        for var in this.vars {
            del var
        }
        for mod_class in this.classes {
            del mod_class
        }
        for mod_enum in this.enums {
            del mod_enum
        }
        for global_const in this.global_consts {
            del global_const
        }
        for global_var in this.global_vars {
            del global_var
        }
        del this.scopes[this.scope.id]
        del this.name
        del this.functions
        del this.vars
        del this.classes
        del this.enums
        del this.scopes
        del this.global_consts
        del this.global_vars
        del this.consts
    }
}
class Program {
    uses_builtins: bool
    modules: Module[]
    constructor(this){
        this.uses_builtins = false
        this.modules = []
    }
    private __del__(this){
        for module in this.modules {
            del module
        }
        del this.modules
    }
}
fnc get_var(program: Program, var_id: VarId): Var {
    return program.modules[var_id.module_id].vars[var_id.id]
}
fnc get_const(program: Program, const_id: ConstId): Const {
    return program.modules[const_id.module_id].consts[const_id.id]
}
fnc get_func(program: Program, func_id: VarId): Function {
    return program.modules[func_id.module_id].functions[func_id.id]
}
fnc get_scope(program: Program, scope_id: ScopeId): Scope {
    return program.modules[scope_id.module_id].scopes[scope_id.id]
}
fnc get_class(program: Program, type_id: ClassId): Class {
    return program.modules[type_id.module_id].classes[type_id.id]   
}
fnc get_class_from_type(program: Program, type_: Type): Class {
    if type_.kind == TypeKind.RESOLVED_GENERIC
        return get_class_from_type(program, (type_ as GenericType).instantiated_type)
    if type_.kind == TypeKind.OBJECT
        return get_class(program, (type_ as ObjectType).class_id)
    return null
}
fnc get_enum(program: Program, enum_id: EnumId): Enum {
    return program.modules[enum_id.module_id].enums[enum_id.id]
}
fnc get_enum_from_type(program: Program, type_: Type): Enum {
    return get_enum(program, (type_ as EnumType).enum_id)
}
fnc get_class_from_prop_id(program: Program, prop_id: PropId): Class {
    return get_class(program, prop_id.type_id as ClassId)
}
fnc get_method(program: Program, prop_id: PropId): ClassMethod {
    return get_class_from_prop_id(program, prop_id).methods[prop_id.id]
}
fnc get_class_prop_type(program: Program, prop_id: PropId): Type {
    let owner = get_class_from_prop_id(program, prop_id)
    if prop_id.kind == PropIdKind.METHOD {
        return owner.methods[prop_id.id].method_type
    }
    return owner.fields[prop_id.id].field_type
}
fnc get_class_prop_type_with_name(program: Program, obj_ty: ObjectType, name: string): Type {
    let obj_class = get_class_from_type(program, obj_ty)
    if (obj_class == null) return null 
    let prop_id = obj_class.prop_map[name]
    if (prop_id == null) return null 
    return get_class_prop_type(program, prop_id)
}
fnc get_class_prop_visibility(program: Program, prop_id: PropId): ACCESS_ATTR {
    let owner = get_class_from_prop_id(program, prop_id)
    if prop_id.kind == PropIdKind.METHOD {
        return owner.methods[prop_id.id].visibility
    }
    return owner.fields[prop_id.id].visibility
}
fnc get_vtable_index(program: Program, prop_id: PropId): int {
    let owner = get_class_from_prop_id(program, prop_id)
    if prop_id.kind == PropIdKind.METHOD {
        return owner.methods[prop_id.id].vtable_index
    }
    return owner.fields[prop_id.id].vtable_index
}
fnc is_class_prop_static(program: Program, prop_id: PropId): bool {
    let owner = get_class_from_prop_id(program, prop_id)
    if prop_id.kind == PropIdKind.METHOD {
        return owner.methods[prop_id.id].is_static
    }
    return owner.fields[prop_id.id].is_static
}
fnc is_buitin(program: Program, ty: Type, name: string): bool {
    if !is_object(ty) return false
    let class_obj = get_class_from_type(program, ty)
    return class_obj.name == name and class_obj.id.module_id == 1
}
fnc is_operator_overload_name(name: string): bool {
    if name == "__eq__" return true
    if name == "__add__" return true
    if name == "__sub__" return true
    if name == "__mul__" return true
    if name == "__div__" return true
    if name == "__or__" return true
    if name == "__adda__" return true
    if name == "__suba__" return true
    if name == "__mula__" return true
    if name == "__diva__" return true
    if name == "__ora__" return true
    if name == "__anda__" return true
    if name == "__xora__" return true
    if name == "__getitem__" return true
    if name == "__setitem__" return true
    if name == "__sl__" return true
    if name == "__sr__" return true
    if name == "__sla__" return true
    if name == "__sra__" return true
    if name == "__in__" return true
    if name == "__lt__" return true
    if name == "__lg__" return true
    if name == "__ne__" return true
    if name == "__le__" return true
    if name == "__ge__" return true
    if name == "__pow__" return true
    if name == "__mod__" return true
    if name == "__powa__" return true
    if name == "__moda__" return true
    if name == "__iter__" return true
    if name == "__del__" return true
    return false
}
fnc bin_op_to_op_overload_name(op: BinaryOp): string {
    if op == BinaryOp.ADD return "__add__"
    if op == BinaryOp.SUB return "__sub__"
    if op == BinaryOp.MUL return "__mul__"
    if op == BinaryOp.DIV return "__div__"
    if op == BinaryOp.MOD return "__mod__"
    if op == BinaryOp.POW return "__pow__"
    if op == BinaryOp.ADD_ASSIGN return "__adda__"
    if op == BinaryOp.SUB_ASSIGN return "__suba__"
    if op == BinaryOp.MUL_ASSIGN return "__mula__"
    if op == BinaryOp.DIV_ASSIGN return "__diva__"
    if op == BinaryOp.MOD_ASSIGN return "__moda__"
    if op == BinaryOp.POW_ASSIGN return "__powa__"
    if op == BinaryOp.GT return "__gt__"
    if op == BinaryOp.GTE return "__ge__"
    if op == BinaryOp.LT return "__lt__"
    if op == BinaryOp.LTE return "__le__"
    if op == BinaryOp.EEQ return "__eq__"
    if op == BinaryOp.NEQ return "__ne__"
    if op == BinaryOp.SL return "__sl__"
    if op == BinaryOp.SR return "__sr__"
    if op == BinaryOp.SL_ASSIGN return "__sla__"
    if op == BinaryOp.SR_ASSIGN return "__sra__"
    if op == BinaryOp.OR return "__or__"
    if op == BinaryOp.AND return "__and__"
    if op == BinaryOp.XOR return "__xor__"
    if op == BinaryOp.AND_ASSIGN return "__anda__"
    if op == BinaryOp.XOR_ASSIGN return "__xora__"
    if op == BinaryOp.IN return "__in__"
    return null
}
fnc evaluate_const_int_expression(program: Program, exp: Expression): i64 {
    if exp.expr_kind == ExpressionKind.INT {
        return (exp as IntExpression).value
    }
    if exp.expr_kind == ExpressionKind.FLOAT
        return (exp as FloatExpression).value as i64
    if exp.expr_kind == ExpressionKind.BIN {
        let bin_exp = exp as BinaryExpression
        if bin_exp.op == BinaryOp.ADD
            return evaluate_const_int_expression(program, bin_exp.lhs) + evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SUB
            return evaluate_const_int_expression(program, bin_exp.lhs) - evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MUL
            return evaluate_const_int_expression(program, bin_exp.lhs) * evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.DIV
            return evaluate_const_int_expression(program, bin_exp.lhs) / evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MOD
            return evaluate_const_int_expression(program, bin_exp.lhs) % evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SL
            return evaluate_const_int_expression(program, bin_exp.lhs) << evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SR
            return evaluate_const_int_expression(program, bin_exp.lhs) >> evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.OR
            return evaluate_const_int_expression(program, bin_exp.lhs) or evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.AND
            return evaluate_const_int_expression(program, bin_exp.lhs) and evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.XOR
            return evaluate_const_int_expression(program, bin_exp.lhs) ^ evaluate_const_int_expression(program, bin_exp.rhs)
    }
    if exp.expr_kind == ExpressionKind.UNARY {
        let unary_exp = exp as UnaryExpression
        if unary_exp.op == UnaryOp.NEG
            return -evaluate_const_int_expression(program, unary_exp.expression)
        if unary_exp.op == UnaryOp.NOT
            return !evaluate_const_int_expression(program, unary_exp.expression)
    }
    if exp.expr_kind == ExpressionKind.ACCESS {
        let var_exp = exp as VarAccessExpression
        return evaluate_const_int_expression(program, get_const(program, var_exp.value_id as ConstId).value)
    }
    return -99999999
}
class Generic {
    module_id: int
    template: ClassDeclarationNode
    constructor(this, module_id: int, template: ClassDeclarationNode){
        this.module_id = module_id
        this.template = template
    }
}
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    private program: Program
    private current_module: int
    private current_class: ClassId
    private current_function: VarId
    private current_method: PropId
    private current_scope: ScopeId
    private compiler: Compiler
    private in_loop: bool
    private module_contains_generics: bool
    private generic_templates: [string: Generic]
    constructor(this, compiler: Compiler){
        this.compiler = compiler
        this.current_module = -1
        this.in_loop = false
        this.program = new Program()
        this.generic_templates = new Map<string, Generic>()
    }
    public check(module_ast: ModuleAST, compiler: Compiler, filename: string): Program {
        let typechecker: TypeChecker(compiler)
        typechecker.load_generic_module()
        typechecker.load_builtins_module()
        typechecker.switch_to_generic_module()
        typechecker.import_all_from_module(typechecker.get_module(1))
        if typechecker.has_errored() return null
        typechecker.check_module(module_ast, filename)
        return typechecker.program
    }
    private get_module(this, id: int): Module {
        return this.program.modules[id]
    }
    private get_current_module(this): Module {
        return this.get_module(this.current_module)
    }
    private get_current_scope(this): Scope {
        return get_scope(this.program, this.current_scope)
    }
    private get_current_module_global_scope(this): Scope {
        return get_scope(this.program, this.get_current_module().scope)
    }
    private get_current_function(this): Function {
        return this.get_current_module().functions[this.current_function.id]
    }
    private get_current_function_type(this): FunctionType {
        if this.current_method != null
            return get_class_prop_type(this.program, this.current_method) as FunctionType
        return this.get_current_function().fnc_type
    }
    private get_current_class(this): Class {
        return get_class(this.program, this.current_class)
    }
    private get_class_from_var_id(this, var_id: VarId): Class {
        return this.get_module(var_id.module_id).classes[var_id.id]
    }
    private get_enum_from_var_id(this, var_id: VarId): Enum {
        return this.get_module(var_id.module_id).enums[var_id.id]
    }
    private types_are_eq(this, t1: Type, t2: Type): bool {
        if t1.kind != t2.kind return false
        if is_function(t1) {
            let t1_fnc_type = t1 as FunctionType
            let t2_fnc_type = t2 as FunctionType
            if t1_fnc_type.arg_types.length != t2_fnc_type.arg_types.length return false
            if !this.types_are_eq(t2_fnc_type.return_type, t1_fnc_type.return_type) return false
            for let i = 0; i < t1_fnc_type.arg_types.length; i++ {
                if !this.types_are_eq(t1_fnc_type.arg_types[i], t2_fnc_type.arg_types[i]) return false
            }
        }
        if t1.kind == TypeKind.ARRAY {
            let t1_arr_type = t1 as ArrayType
            let t2_arr_type = t2 as ArrayType
            return t1_arr_type.length == t2_arr_type.length and this.types_are_eq(t1_arr_type.element_type, t2_arr_type.element_type)
        }
        if t1.kind == TypeKind.PTR {
            let t1_ptr_type = t1 as PointerType
            let t2_ptr_type = t2 as PointerType
            return this.types_are_eq(t1_ptr_type.pointee_type, t2_ptr_type.pointee_type)
        }
        if t1.kind == TypeKind.OBJECT {
            let t1_obj_type = t1 as ObjectType
            let t2_obj_type = t2 as ObjectType
            let t1_obj_typeid = t1_obj_type.class_id as TypeId
            let t2_obj_typeid = t2_obj_type.class_id as TypeId
            if t1_obj_typeid.kind == t2_obj_typeid.kind and t1_obj_typeid.module_id == t2_obj_typeid.module_id and t1_obj_typeid.id == t2_obj_typeid.id  {
                return true
            }
            let t2_class = get_class(this.program, t2_obj_typeid as ClassId)
            if t2_class.parent != null {
                return this.types_are_eq(t1_obj_type, t2_class.parent)
            }
            return false
        }
        if t1.kind == TypeKind.ENUM {
            let t1_enum_type = t1 as EnumType
            let t2_enum_type = t2 as EnumType
            let t1_enum_typeid = t1_enum_type.enum_id as TypeId
            let t2_enum_typeid = t2_enum_type.enum_id as TypeId
            return t1_enum_typeid == t2_enum_typeid
        }
        if t1.kind == TypeKind.RESOLVED_GENERIC {
            let t1_gen_type = t1 as GenericType
            let t2_gen_type = t2 as GenericType
            if t1_gen_type.name != t2_gen_type.name return false
            if t1_gen_type.arg_types.length != t2_gen_type.arg_types.length return false
            for let i = 0; i < t1_gen_type.arg_types.length; i++ {
                if (!this.types_are_eq(t1_gen_type.arg_types[i], t2_gen_type.arg_types[i])) return false
            }
        }
        return true
    }
    private dump_type(this, ty: Type): string {
        if is_function(ty) {
            let fnc_ty = ty as FunctionType
            let args_tys_str = ""
            for let i = 0; i < fnc_ty.arg_types.length; i++ {
                args_tys_str += this.dump_type(fnc_ty.arg_types[i])
                if i < fnc_ty.arg_types.length - 1 {
                    args_tys_str += ", "
                }
            }
            return "($args_tys_str) => $(this.dump_type(fnc_ty.return_type))"
        }
        if ty.kind == TypeKind.PTR
            return "$(this.dump_type((ty as PointerType).pointee_type))*"
        if ty.kind == TypeKind.OBJECT {
            return get_class_from_type(this.program, ty).name
        }
        if ty.kind == TypeKind.ENUM {
            return get_enum(this.program, (ty as EnumType).enum_id).name
        }
        if ty.kind == TypeKind.ARRAY {
            let arr_ty = ty as ArrayType
            return "$(this.dump_type(arr_ty.element_type))[$(arr_ty.length)]"
        }
        if ty.kind == TypeKind.RESOLVED_GENERIC {
            let gen_ty = ty as GenericType
            let s = gen_ty.name + "<"
            for let x = 0; x < gen_ty.arg_types.length; x++ {
                s +=  this.dump_type(gen_ty.arg_types[x])
            }
            return s + ">"
        }
        if ty.kind == TypeKind.MODULE {
            return "Namespace"
        }
        if ty.kind == TypeKind.RECORD {
            return "Record"
        }
        return dump_type(ty, false)
    }
    private create_scope(this): Scope {
        let module = this.get_current_module()
        let scope = new Scope(this.current_module, module.scopes.length)
        module.scopes << scope
        return scope
    }
    private is_constant_in_scope(this, name: string): bool {
        let is_constant = false
        let var_id = this.get_var_from_current_scope(name)
        if var_id != null { 
            is_constant = var_id.kind == VarIdKind.CONST
        }
        return is_constant
    }
    private get_var_from_current_scope(this, name: string): VarId {
        let current_scope = this.get_current_scope()
        let value: VarId = null
        while value == null {
            value = current_scope.vars[name]
            if value == null
                value = current_scope.functions[name]
            if current_scope.parent == null or value != null
                break
            current_scope = get_scope(this.program, current_scope.parent)
        }
        // Get Var from builtins
        if value == null and this.current_scope.module_id != 0 {
            let previous_scope = this.current_scope
            this.current_scope = this.program.modules[0].scope
            value = this.get_var_from_current_scope(name)
            this.current_scope = previous_scope
            if value != null {
                this.program.uses_builtins = true
                if value.kind == VarIdKind.FNC
                    this.add_imported_fnc_to_module(name, value)
                if value.kind == VarIdKind.VAR or value.kind == VarIdKind.CONST
                    this.add_imported_var_to_module(name, value)
                if value.kind == VarIdKind.CLASS
                    this.add_imported_class_to_module(name, ClassVarId.to_classId(value))
                if value.kind == VarIdKind.ENUM
                    this.add_imported_enum_to_module(name, EnumVarId.to_enumId(value))
            }
        }
        return value
    }
    private get_type_from_current_scope(this, name: string): Type {
        let current_scope = this.get_current_scope()
        while true {
            let aliased_ty = current_scope.type_aliases[name]
            if aliased_ty != null {
                return aliased_ty
            }
            let class_id = current_scope.classes[name]
            if class_id != null {
                return new ObjectType(class_id)
            }
            let enum_id = current_scope.enums[name]
            if enum_id != null {
                return new EnumType(enum_id)
            }
            if (current_scope.parent == null) break
            current_scope = get_scope(this.program, current_scope.parent)
        }
        // Get type from builtins
        if this.current_scope.module_id != 0 {
            let previous_scope = this.current_scope
            this.current_scope = this.program.modules[0].scope
            let builtin_type = this.get_type_from_current_scope(name)
            if builtin_type.kind != TypeKind.UNKNOWN {
                this.program.uses_builtins = true
                if builtin_type.kind == TypeKind.OBJECT {
                    this.add_imported_class_to_module(name, (builtin_type as ObjectType).class_id)
                } else {
                    this.add_imported_enum_to_module(name, (builtin_type as EnumType).enum_id)
                }
            }
            this.current_scope = previous_scope
            return builtin_type
        }
        return Type.unknown()
    }
    private create_child_scope_within_current_scope(this): Scope {
        let new_scope = this.create_scope()
        new_scope.parent = this.current_scope
        return new_scope
    } 
    private error(this, kind: ErrorKind, message: string, range: FloRange){
        this.compiler.errors << new FloError(kind, message, range)
    }
    private has_errored(this): bool {
        return this.compiler.errors.length > 0
    }
    private load_builtins_module(this){
        this.lex_and_parse_typecheck_file(this.compiler.builtin_path, null)
    }
    private load_generic_module(this){
        this.compiler.register_file("__generics__")
        this.check_module(new ModuleAST(), "__generics__")
    }
    private switch_to_generic_module(this){
        let generic_module_id = 0
        this.current_module = generic_module_id
        this.current_scope = this.get_module(generic_module_id).scope
    }
    private check_module(this, module_ast: ModuleAST, filename: string): Module {
        this.module_contains_generics = false
        let prev_module = this.current_module
        let prev_scope = this.current_scope
        let module = new Module(filename)
        this.current_module = this.program.modules.length
        this.program.modules << module
        let module_scope = this.create_scope()
        module.scope = module_scope.id
        module_scope.vars["true"] = null
        module_scope.vars["false"] = null
        module_scope.vars["null"] = null
        this.current_scope = module_scope.id
        this.current_method = null
        this.current_class = null
        this.current_function = null
        for module_import in module_ast.imports {
            this.check_module_import(module_import)
            if (this.has_errored()) return null
        }
        // We declare module structures
        for enum_ in module_ast.enums {
            this.declare_enum_within_module(enum_)
        }
        for class_ in module_ast.classes {
            this.declare_class_within_module(class_)
        }
        if this.has_errored() return null
        for type_alias_node in module_ast.type_aliases {
            let ty = this.check_type(type_alias_node.parsed_type)
            let identifer_tok = type_alias_node.name
            let alias_name = identifer_tok.value
            if this.get_type_from_current_scope(alias_name).kind != TypeKind.UNKNOWN {
                this.error(ErrorKind.NAME, "Name '$alias_name' has already been used for another type. consider renaming", type_alias_node.name.range)
                return null
            }
            module_scope.type_aliases[alias_name] = ty
        }
        for global_const in module_ast.consts {
            this.declare_global_const(global_const)
        }
        for global_var in module_ast.vars {
            this.declare_global_var(global_var)
        }
        for function in module_ast.functions {
            this.declare_function_within_module(function)
        }
        if this.has_errored() return null
        // We Now check bodies
        for let i = 0; i < module_ast.enums.length; i++ {
            this.check_enum_body(module.enums[i], module_ast.enums[i])
        }
        for class_ in module_ast.classes {
            this.check_class_body(class_)
        }
        for let i = 0; i < module_ast.functions.length; i++ {
           this.check_function_body(module.functions[i], module_ast.functions[i])
        }
        if this.module_contains_generics and this.current_module != 0 {
            this.switch_to_generic_module()
            this.import_all_from_module(module)
        }
        this.current_scope = prev_scope
        this.current_module = prev_module
        if this.has_errored() return null
        return module
    }
    private create_generic_instance_in_module(this, name: string, types: Type[]): GenericType {
        let generic = this.generic_templates[name]
        if generic == null return null
        let generic_params = generic.template.generic_parameters
        if generic_params.length != types.length {
            this.error(ErrorKind.TYPE, "Generic expects $(generic_params.length) parameters but got $(types.length)", null)
            return null
        }
        let module_id = this.current_module
        let scope_id = this.current_scope
        this.switch_to_generic_module()
        let generic_scope = this.create_child_scope_within_current_scope()
        let param_strings = ""
        for let i = 0; i < generic_params.length; i++ {
            let param_name = generic_params[i].name.value
            let param_type: Type = types[i].kind == TypeKind.RESOLVED_GENERIC ? (types[i] as GenericType).instantiated_type : types[i]
            param_strings += "$(this.dump_type(param_type))_"
            generic_scope.type_aliases[param_name] = types[i]
        }
        let instantiated_generic_name = "$(name)_$param_strings"
        let possible_type = this.get_type_from_current_scope(instantiated_generic_name)
        if possible_type.kind == TypeKind.UNKNOWN {
            // TODO: Find a better way to create this initialization.
            let new_identok: IdentifierToken(instantiated_generic_name, generic.template.name.range)
            let instantiated_generic_class: ClassDeclarationNode(new_identok)
            instantiated_generic_class.parent = generic.template.parent
            instantiated_generic_class.fields = generic.template.fields
            instantiated_generic_class.methods = generic.template.methods
            this.current_scope = generic_scope.id
            this.declare_class_within_module(instantiated_generic_class)
            this.check_class_body(instantiated_generic_class)
            possible_type = this.get_type_from_current_scope(instantiated_generic_name)
        }
        this.current_module = module_id
        this.current_scope = scope_id
        del generic_scope
        return new GenericType(name, types, possible_type)
    }
    private declare_var_within_current_scope(this, name: string, value: Expression, value_type: Type): Var {
        let var = new Var(value, value_type)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let id = new VarId(VarIdKind.VAR, this.current_module, current_module.vars.length)
        var.var_id = id
        current_module.vars << var
        current_scope.vars[name] = id
        return var
    }
    private declare_const_within_current_scope(this, name: string, value: Expression, value_type: Type): Const {
        let constant = new Const(value, value_type)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let id = new ConstId(this.current_module, current_module.consts.length)
        constant.const_id = id
        current_module.consts << constant
        current_scope.vars[name] = id
        return constant
    }
    private declare_global_const(this, const_decl_node: ConstDeclarationStatement){
        let const_stmt = this.check_const_declaration(const_decl_node)
        if this.has_errored() return
        const_stmt.is_static = true
        this.get_current_module().global_consts << const_stmt
    }
    private declare_global_var(this, var_decl_node: VarDeclarationStatement){
        let var_stmt = this.check_var_declaration(var_decl_node)
        if this.has_errored() return
        if !get_var(this.program, var_stmt.var_id).value.is_constant {
            this.error(ErrorKind.GEN, "Initilializer for global variable has to be a constant", var_decl_node.value.range)
            return
        }
        var_stmt.is_static = true
        this.get_current_module().global_vars << var_stmt
    }
    private add_imported_typealias_to_module(this, alias_name: string, type_: Type){
        let scope = this.get_current_module_global_scope()
        scope.type_aliases[alias_name] = type_
    }
    private add_imported_var_to_module(this, var_name: string, var_id: VarId){
        let scope = this.get_current_module_global_scope()
        scope.vars[var_name] = var_id
    }
    private add_imported_fnc_to_module(this, fnc_name: string, fnc_id: VarId){
        let scope = this.get_current_module_global_scope()
        scope.functions[fnc_name] = fnc_id
    }
    private add_imported_class_to_module(this, class_name: string, class_id: ClassId){
        let scope = this.get_current_module_global_scope()
        scope.classes[class_name] = class_id
        scope.vars[class_name] = new ClassVarId(class_id)
    }
    private add_imported_enum_to_module(this, enum_name: string, enum_id: EnumId){
        let scope = this.get_current_module_global_scope()
        scope.enums[enum_name] = enum_id
        scope.vars[enum_name] = new EnumVarId(enum_id)
    }
    private init_function_signature(this, arg_nodes: ArgNode[], return_type_node: TypeNode, args: FunctionArg[]): FunctionType {
        let arg_types: Type[] = []
        for arg in arg_nodes {
            let fnc_arg = new FunctionArg()
            fnc_arg.name = arg.name.value
            fnc_arg.default = null
            let arg_type = Type.unknown()
            if arg.parsed_type != null {
                arg_type = this.check_type(arg.parsed_type)
                if this.has_errored() return null
            }
            if arg.default != null {
                fnc_arg.default = this.check_expression(arg_type, arg.default)
                if this.has_errored() return null
                if arg_type.kind == TypeKind.UNKNOWN
                    arg_type = fnc_arg.default.value_type
                else if !this.types_are_eq(arg_type, fnc_arg.default.value_type){
                    this.error(ErrorKind.TYPE, "Expected type of '$(this.dump_type(arg_type))' but got type of '$(this.dump_type(fnc_arg.default.value_type))' on signature", arg.default.range)
                }
            }
            args << fnc_arg
            fnc_arg.value_type = arg_type
            let var = this.declare_var_within_current_scope(fnc_arg.name, fnc_arg, arg_type)
            fnc_arg.id = var.var_id
            arg_types << arg_type
        }
        let ret_type = this.check_type(return_type_node)
        return new FunctionType(arg_types, ret_type)
    }
    private import_all_from_module(this, module: Module){
        let global_module_scope = get_scope(this.program, module.scope)
        for imported_var in module.global_vars {
            this.add_imported_var_to_module(imported_var.name, imported_var.var_id)
        }
        for imported_const in module.global_consts {
            this.add_imported_var_to_module(imported_const.name, imported_const.const_id)
        }
        for imported_func in module.functions {
            this.add_imported_fnc_to_module(imported_func.name, imported_func.id)
        }
        for imported_class in module.classes {
            this.add_imported_class_to_module(imported_class.name, imported_class.id)
        }
        for imported_enum in module.enums {
            this.add_imported_enum_to_module(imported_enum.name, imported_enum.id)
        }
        for type_alias_entry in global_module_scope.type_aliases {
            this.add_imported_typealias_to_module(type_alias_entry.key, type_alias_entry.value)
        }
    }
    private check_module_import(this, import_node: ImportNode){
        if import_node.module_path.args.length > 0 {
            this.error(ErrorKind.GEN, "Import statement path can't be a a formatted string", import_node.module_path.range)
            return
        }
        let path = import_node.module_path.value
        let module = this.lex_and_parse_typecheck_file(path, import_node.module_path.range)
        if this.has_errored() return
        let global_module_scope = get_scope(this.program, module.scope)
        if import_node.import_list.length > 0 {
            for import_clause in import_node.import_list {
                let name_to_import = import_clause.original_identifer.value
                let renamed_name = import_clause.renamed_identifer ? import_clause.renamed_identifer.value : name_to_import
                if this.generic_templates[name_to_import] != null {
                    continue
                }
                let class_id = global_module_scope.classes[name_to_import]
                if class_id != null {
                    this.add_imported_class_to_module(renamed_name, class_id)
                    continue
                }
                let enum_id = global_module_scope.enums[name_to_import]
                if enum_id != null {
                    this.add_imported_enum_to_module(renamed_name, enum_id)
                    continue
                }
                let var_id = global_module_scope.vars[name_to_import]
                if var_id != null {
                    this.add_imported_var_to_module(renamed_name, var_id)
                    continue 
                }
                let func_id = global_module_scope.functions[name_to_import]
                if func_id != null {
                    this.add_imported_fnc_to_module(renamed_name, func_id)
                    continue
                }
                let type_alias = global_module_scope.type_aliases[name_to_import]
                if type_alias != null {
                    this.add_imported_typealias_to_module(renamed_name, type_alias)
                    continue
                } else {
                    this.error(ErrorKind.NAME, "$name_to_import not found in module \"$path\"", import_clause.original_identifer.range)
                    return
                }
            }
        } else if import_node.module_name {
            let name = import_node.module_name.value
            this.get_current_module_global_scope().vars[name] = new ModuleVarId(global_module_scope.id)
        } else {
            this.import_all_from_module(module)
        }
    }
    private lex_and_parse_typecheck_file(this, filename: string, range: FloRange): Module {
        // TODO: You need to properly handle the built-in case; don't use null as a reference point.
        let filepath = filename
        let prev_file_id = this.compiler.current_file
        if range != null and !filename.starts_with("@") {
            filepath = Path.join(Path.dirname(this.get_current_module().name), filename)
        }
        let file_id = this.compiler.register_file(filepath)
        if file_id.id < this.program.modules.length {
            return this.get_module(file_id.id)
        }
        if !this.compiler.set_current_file(file_id){ 
            this.error(ErrorKind.IO, "No such file or directory: '$filename'", range)
            return null
        }
        let tokens = Lexer.tokenize(this.compiler.current_file_contents, this.compiler.errors)
        if this.has_errored() return null
        let module_node = Parser.parse(tokens, this.compiler.errors)
        if this.has_errored() return null
        let module = this.check_module(module_node, filepath)
        if this.has_errored() return null
        this.compiler.set_current_file(prev_file_id)
        return module
    }
    private declare_enum_within_module(this, enum_node: EnumNode){
        let declared_enum = new Enum()
        let name = enum_node.name.value
        let module_scope =  this.get_current_module_global_scope()
        declared_enum.name = name
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Name '$name' has already been used for another type. consider renaming", enum_node.name.range)
            return
        }
        declared_enum.id = new EnumId(this.current_module, this.get_current_module().enums.length)
        this.get_current_module().enums << declared_enum
        module_scope.enums[declared_enum.name] = declared_enum.id
        module_scope.vars[declared_enum.name] = new EnumVarId(declared_enum.id)
    }
    private declare_class_within_module(this, class_decl_node: ClassDeclarationNode) {
        let name = class_decl_node.name.value
        if (this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN) or (this.generic_templates[name] != null) {
            this.error(ErrorKind.NAME, "Name '$name' has already been used for another type. consider renaming", class_decl_node.name.range)
            return
        }
        if class_decl_node.generic_parameters.length > 0 {
            this.module_contains_generics = true
            this.generic_templates[name] = new Generic(this.current_module, class_decl_node)
            return
        }
        let declared_class = new Class()
        let module_scope = this.get_current_module_global_scope()
        if class_decl_node.parent != null {
            declared_class.parent = this.check_type(class_decl_node.parent)
            if this.has_errored() return
        } else {
            declared_class.parent = null
        }
        declared_class.name = name
        declared_class.id = new ClassId(this.current_module, this.get_current_module().classes.length)
        this.get_current_module().classes << declared_class
        module_scope.classes[name] = declared_class.id
        module_scope.vars[name] = new ClassVarId(declared_class.id)
    }
    private declare_function_within_module(this, function_node: FunctionDeclarationNode) {
        let declared_function = new Function()
        declared_function.is_external = function_node.is_external
        let name = function_node.name.value
        declared_function.name = name
        if this.is_constant_in_scope(name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", function_node.name.range)
            return
        }
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Illegal re-declaration of type '$name' as function", function_node.name.range)
            return
        }
        let parent_scope = this.current_scope
        let fnc_scope = this.create_child_scope_within_current_scope()
        this.current_scope = fnc_scope.id 
        declared_function.args = []
        declared_function.fnc_type = this.init_function_signature(function_node.args, function_node.return_type, declared_function.args)
        if this.has_errored() return
        declared_function.id = new VarId(VarIdKind.FNC, this.current_module, this.get_current_module().functions.length)
        this.current_scope = fnc_scope.parent
        declared_function.scope = fnc_scope.id
        let module_scope =  this.get_current_module_global_scope()
        this.get_current_module().functions << declared_function
        module_scope.functions[declared_function.name] = declared_function.id
    }
    private check_enum_body(this, declared_enum: Enum, enum_node: EnumNode){
        let enum_variant: Type = null
        if enum_node.variant == null {
            enum_variant = new Type(TypeKind.INT)
        } else {
            enum_variant = this.check_type(enum_node.variant)
            if !is_int(enum_variant){
                this.error(ErrorKind.TYPE, "Expected an int type for enum type but got type '$(this.dump_type(enum_variant))'", enum_node.variant.range)
            }
        }
        let next_enum_value: i64 = 0
        for let i = 0; i < enum_node.fields.length; ++i {
            let enum_node_field = enum_node.fields[i]
            let enum_name = enum_node_field.name.value
            let enum_field = new EnumField(enum_name)
            enum_field.id = new PropId(PropIdKind.FIELD, declared_enum.id, i)
            if enum_node_field.initializer != null {
                enum_field.initializer = this.check_expression(enum_variant, enum_node_field.initializer)
                if !enum_field.initializer.is_constant {
                    this.error(ErrorKind.TYPE, "Enum initializer has to be a constant", enum_node_field.initializer.range)
                    return
                }
                if !this.types_are_eq(enum_variant, enum_field.initializer.value_type){
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(enum_variant))' but got type '$(this.dump_type(enum_field.initializer.value_type))", enum_node_field.initializer.range)
                    return
                }
                // Not safe!
                next_enum_value = evaluate_const_int_expression(this.program, enum_field.initializer) + 1
            } else {
                enum_field.initializer = new IntExpression(next_enum_value)
                enum_field.initializer.value_type = enum_variant
                next_enum_value++
            }
            declared_enum.field_map[enum_name] = enum_field.id
            declared_enum.fields << enum_field
        }
    }
    private declare_class_fields(this, declared_class: Class, class_node: ClassDeclarationNode){
        let current_vtable_index = declared_class.inherited_fields_num
        for let i = 0; i < class_node.fields.length; i++ {
            let field_node = class_node.fields[i]
            let field = new ClassField()
            field.name = field_node.name.value
            if is_operator_overload_name(field.name) {
                this.error(ErrorKind.NAME, field.name+" is reserved only for operator overloads and cannot be used as a field name", field_node.name.range)
            }
            field.visibility = field_node.access_modifier
            field.id = new PropId(PropIdKind.FIELD, declared_class.id, i)
            field.field_type = this.check_type(field_node.parsed_type)
            field.vtable_index = current_vtable_index
            if this.has_errored() return
            let possible_prop_id = declared_class.prop_map[field.name]
            if possible_prop_id != null {
                if possible_prop_id.type_id == declared_class.id {
                    this.error(ErrorKind.NAME, "Field $(field.name) in class $(declared_class.name) already exists", field_node.name.range)
                    return
                }
                let parent_prop_type = get_class_prop_type(this.program, possible_prop_id)
                let parent_prop_visibility = get_class_prop_visibility(this.program, possible_prop_id)
                if !this.types_are_eq(parent_prop_type, field.field_type) {
                    this.error(ErrorKind.TYPE, "Signature of inherited field $(field.name) in class $(declared_class.name) does not match expected parent signature '$(this.dump_type(parent_prop_type))", field_node.name.range)
                    return
                }
                if field.visibility != parent_prop_visibility {
                    this.error(ErrorKind.GEN, "Expected inherited field $(field.name) in class $(declared_class.name) to be $(dump_access(parent_prop_visibility))", field_node.name.range)
                    return
                }
            }
            if field_node.initializer != null {
                field.initializer = this.check_expression(field.field_type, field_node.initializer)
                if this.has_errored() return
                if !this.types_are_eq(field.field_type, field.initializer.value_type) {
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(field.field_type))' but got type '$(this.dump_type(field.initializer.value_type))' on static field initialization", field_node.initializer.range)
                }
                if !field.initializer.is_constant {
                    this.error(ErrorKind.GEN, "Static field initializer has to be a constant", field_node.initializer.range)
                    return
                }
                field.is_static = true
                declared_class.static_prop_map[field.name] = field.id
            } else {
                field.is_static = false
                declared_class.prop_map[field.name] = field.id
                current_vtable_index++
            }
            declared_class.fields << field
        }
    }
    private is_iteratable(this, suspect_type: Type): bool {
        //TODO: Need to think about generics
        if !is_object(suspect_type) return false
        let class_ = get_class_from_type(this.program, suspect_type)
        let done_prop_id = class_.prop_map["done"]
        if (done_prop_id == null) return false
        let done_type = get_class_prop_type(this.program, done_prop_id)
        if (done_type.kind != TypeKind.BOOL) return false
        let next_prop_id = class_.prop_map["next"]
        if (next_prop_id == null) return false
        let next_type = get_class_prop_type(this.program, next_prop_id) as FunctionType
        if (next_type.kind != TypeKind.FNC) return false
        if (next_type.arg_types.length != 0) return false
        return true
    }
    private declare_class_methods(this, declared_class: Class, class_node: ClassDeclarationNode){
        let current_vtable_index = declared_class.inherited_methods_num
          for let i = 0; i < class_node.methods.length; i++ {
            let method_node = class_node.methods[i]
            let method = new ClassMethod()
            let name = method_node.name.value
            method.name = name
            let method_scope = this.create_child_scope_within_current_scope()
            this.current_scope = method_scope.id
            method.args = []
            if is_operator_overload_name(name) {
                let args_num = 1
                if name == "__iter__" or name == "__del__" {
                    args_num = 0
                } else if name =="__setitem__" {
                    args_num = 2
                }
                if method_node.args.length != args_num {
                    this.error(ErrorKind.GEN, "Expected $args_num arguments for binary operator overload $name but got $(method_node.args.length)", method_node.name.range)
                    return
                }
                if method_node.is_static {
                    this.error(ErrorKind.GEN, "Binary operator overload $name cannot be static", method_node.name.range)
                    return
                }
            }
            method.is_abstract = method_node.is_abstract
            method.is_static = method_node.is_static
            method.visibility = method_node.access_modifier
            method.method_type = this.init_function_signature(method_node.args, method_node.return_type, method.args)
            if name == "__iter__" {
                if !this.is_iteratable(method.method_type.return_type) {
                    this.error(ErrorKind.TYPE, "__iter__ method must return an iteratable object {done: bool, next(): any}", method_node.name.range)
                    return 
                }
            }
            let possible_prop_id = declared_class.prop_map[name]
            if possible_prop_id != null {
                if possible_prop_id.type_id == declared_class.id {
                    this.error(ErrorKind.NAME, "Method $name in class $(declared_class.name) already exists", method_node.name.range)
                    return
                }
                let parent_prop_type = get_class_prop_type(this.program, possible_prop_id)
                let parent_prop_visibility = get_class_prop_visibility(this.program, possible_prop_id)
                if !this.types_are_eq(parent_prop_type, method.method_type) {
                    this.error(ErrorKind.TYPE, "Signature of inherited method $name in class $(declared_class.name) does not match expected parent signature '$(this.dump_type(parent_prop_type))'", method_node.name.range)
                    return
                }
                if method.visibility != parent_prop_visibility {
                    this.error(ErrorKind.GEN, "Expected inherited method $name in class $(declared_class.name) to be $(dump_access(parent_prop_visibility))", method_node.name.range)
                    return
                }
                method.vtable_index = get_vtable_index(this.program, possible_prop_id)
            } else {
                method.vtable_index = current_vtable_index
            }
            method.id = new PropId(PropIdKind.METHOD, declared_class.id, i)
            if method_node.is_static {
                if method_node.is_abstract {
                    this.error(ErrorKind.GEN, "Static method can't be abstract", method_node.name.range)
                    return
                }
                if method.name == "constructor" {
                    this.error(ErrorKind.GEN, "Class constructor can't be static", method_node.name.range)
                    return
                }
                declared_class.static_prop_map[name] = method.id
            } else {
                if method.name == "constructor" {
                    if method_node.is_abstract {
                        this.error(ErrorKind.GEN, "Class constructor can't be abstract", method_node.name.range)
                        return
                    }
                    declared_class.construct = method.id
                } else {
                    if method.visibility != ACCESS_ATTR.PRIVATE
                        current_vtable_index++
                    else if method_node.is_abstract {
                        this.error(ErrorKind.GEN, "Can't have a abstract private method use protected instead", method_node.name.range)
                        return
                    }
                    declared_class.prop_map[name] = method.id
                }
                let object_type = new ObjectType(declared_class.id)
                let this_const = this.declare_const_within_current_scope("this", null, object_type)
                if declared_class.parent != null {
                    let constructor_method = get_class_from_type(this.program, declared_class.parent).construct
                    if constructor_method != null {
                        let constructor_type = get_class_prop_type(this.program, constructor_method)
                        this.declare_const_within_current_scope("super", null, constructor_type)
                    }
                }
            }
            method.scope = method_scope.id
            declared_class.methods << method
            this.current_scope = method_scope.parent
        }
    }
    private add_inherited_props_to_class(this, declared_class: Class, class_node: ClassDeclarationNode){
        let parent_type = declared_class.parent
        if !is_object(parent_type) {
            this.error(ErrorKind.TYPE, "Can only inherit from class not type '$(this.dump_type(parent_type))'", class_node.parent.range)
        }
        let parent_class = get_class_from_type(this.program, parent_type)
        for parent_entry_prop in parent_class.prop_map {
            let parent_prop_name = parent_entry_prop.key
            let parent_prop_id = parent_entry_prop.value  
            let parent_prop_type = get_class_prop_type(this.program, parent_prop_id)
            let child_prop_id = declared_class.prop_map[parent_prop_name]
            let parent_prop_visibility = get_class_prop_visibility(this.program, parent_prop_id)
            let parent_prop_is_static = is_class_prop_static(this.program, parent_prop_id)
            if parent_prop_is_static
                continue
            if parent_prop_visibility == ACCESS_ATTR.PRIVATE and is_function(parent_prop_type)
                continue
            if child_prop_id == null {
                if parent_prop_id.kind == PropIdKind.FIELD
                    declared_class.inherited_fields_num++
                if parent_prop_id.kind == PropIdKind.METHOD
                    declared_class.inherited_methods_num++
                declared_class.prop_map[parent_prop_name] = parent_prop_id
            }
        }
    }
    private check_class_body(this, class_node: ClassDeclarationNode){
        let class_name = class_node.name.value
        let resolved_type = this.get_type_from_current_scope(class_name)
        if resolved_type.kind == TypeKind.UNKNOWN return
        let declared_class = get_class_from_type(this.program, resolved_type)
        let outer_class = this.current_class
        this.current_class = declared_class.id
        if declared_class.parent != null {
            this.add_inherited_props_to_class(declared_class, class_node)
        }
        // Fields
        this.declare_class_fields(declared_class, class_node)     
        if this.has_errored() return
        // Declare class methods
        this.declare_class_methods(declared_class, class_node)
        if this.has_errored() return
        // Checking if class is abstract.
        for prop_entry in declared_class.prop_map {
            let prop_id = prop_entry.value
            let prop_name = prop_entry.key
            if prop_id.kind == PropIdKind.METHOD {
                let prop_method = get_method(this.program, prop_id)
                if prop_method.is_abstract {
                    if declared_class.construct != null {
                        this.error(ErrorKind.GEN, "Class with constructor must implement all it's methods missing $(prop_name) implementation", class_node.name.range)
                        return
                    }
                    declared_class.is_abstract = true
                    break
                }
            }
        }
        // Class Methods Body
        for let i = 0; i < declared_class.methods.length; i++ {
            let method = declared_class.methods[i]
            this.current_method = method.id
            let method_node = class_node.methods[i]
            this.current_scope = method.scope
            if method.is_abstract {
                continue
            }
            method.block = this.check_block(method_node.block)
            if this.has_errored() {
                return
            }
            if !method.block.returns {
                if method.method_type.return_type.kind == TypeKind.VOID {
                    method.block.statements << (new ReturnStatement() as Statement)
                } else {
                    this.error(ErrorKind.GEN, "Method missing ending return statement", method_node.return_type.range)
                    return
                }
            }
            this.current_method = null
            this.current_scope = get_scope(this.program, method.scope).parent
        }
        this.current_class = outer_class
    }
    private check_function_body(this, func: Function, func_node: FunctionDeclarationNode) {
        if func.is_external { 
            return
        }
        let prev_func = this.current_function
        this.current_function = func.id
        let prev_scope = this.current_scope 
        this.current_scope = func.scope
        func.block = this.check_block(func_node.block)
        if this.has_errored() return
        if !func.block.returns {
            if func.fnc_type.return_type.kind == TypeKind.VOID {
                func.block.statements << (new ReturnStatement() as Statement)
            } else {
                this.error(ErrorKind.GEN, "Function missing ending return statement", func_node.return_type.range)
                return
            }
        }
        this.current_scope = get_scope(this.program, func.scope).parent
    }
    private check_type(this, type_node: TypeNode): Type {
        if type_node.kind == TypeKind.BOOL
            return new Type(TypeKind.BOOL)
        if type_node.kind >= TypeKind.I4 and type_node.kind <= TypeKind.F64
            return new Type(type_node.kind)
        if type_node.kind == TypeKind.VOID
            return new Type(TypeKind.VOID)
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY {
            let array_node = type_node as ArrayTypeNode
            let int_ty: Type(TypeKind.INT)
            let len_expr = this.check_expression(int_ty, array_node.length)
            if this.has_errored() return Type.unknown()
            if !is_int(len_expr.value_type) {
                this.error(ErrorKind.GEN, "length has to be an int", array_node.length.range)
                return null
            }
            if !len_expr.is_constant {
                this.error(ErrorKind.GEN, "length is a non-constant value", array_node.length.range)
                return null
            }
            let length = evaluate_const_int_expression(this.program, len_expr)
            if length < 0 {
                this.error(ErrorKind.GEN, "length should be an unsigned", array_node.length.range)
                return null
            }
            let element_type = this.check_type(array_node.element_type)
            return new ArrayType(element_type, length as int)
        }
        if type_node.kind == TypeKind.FNC {
            let fnc_node = type_node as FunctionTypeNode
            let arg_types: Type[] = []
            for arg in fnc_node.args 
                arg_types << this.check_type(arg)
            let return_type = this.check_type(fnc_node.return_type)
            return new FunctionType(arg_types, return_type)
        }
        if type_node.kind == TypeKind.RECORD {
            let record_type = type_node as RecordTypeNode
            let types: Type[] = []
            let identifer_tok = record_type.name
            if record_type.generic_args.length > 0 {
                for arg in record_type.generic_args
                    types << this.check_type(arg)
                if this.has_errored() return null
                let generic_type = this.create_generic_instance_in_module(identifer_tok.value, types)
                if this.has_errored() this.compiler.errors[0].range = type_node.range
                if generic_type != null {
                    return generic_type
                }
            }
            let found_type = this.get_type_from_current_scope(identifer_tok.value)
            if found_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Undefined type '$(identifer_tok.value)'", identifer_tok.range)
                return null
            }
            return found_type
        }
        return Type.unknown()
    }
    private check_array_expression(this, expected_type: Type, array_node: ArrayExpressionNode): ArrayExpression {
        if this.has_errored() return null
        let elements: Expression[] = []
        let element_type = Type.unknown()
        let is_constant = true
        let array_type = expected_type
        if expected_type.kind == TypeKind.ARRAY {
            element_type = (expected_type as ArrayType).element_type
        } else if expected_type.kind == TypeKind.RESOLVED_GENERIC {
            is_constant = false
            let generic_ty =  expected_type as GenericType
            if is_object(generic_ty) and generic_ty.name == "Array"
                element_type = generic_ty.arg_types[0]
        } 
        if array_node.elements.length > 0 {
            for let i = 0; i < array_node.elements.length; ++i {
                let element = this.check_expression(element_type, array_node.elements[i])
                if this.has_errored() return null
                if i == 0 and element_type.kind == TypeKind.UNKNOWN {
                    element_type = element.value_type
                }
                is_constant and= element.is_constant
                if this.types_are_eq(element_type, element.value_type) {
                    elements << element
                } else {
                    this.error(ErrorKind.TYPE, "Expected element type of '$(this.dump_type(element_type))' but got type '$(this.dump_type(element.value_type))'", array_node.elements[i].range)
                    return null
                }
            }
        }
        if array_type.kind != TypeKind.ARRAY {
            let generic_array_type = this.create_generic_instance_in_module("Array", [element_type])
            if (generic_array_type != null) {
                array_type = generic_array_type
                is_constant = false
            }
        } else {
            array_type = new ArrayType(element_type, elements.length)
        }
        let arr_exp = new ArrayExpression(elements)
        arr_exp.is_constant = is_constant
        arr_exp.value_type = array_type
        return arr_exp
    }
    private check_var_access_expr(this, expected_type: Type, var_access_node: VarAccessExpressionNode): Expression {
        let name = var_access_node.name.value
        if name == "true" 
            return new BooleanExpression(true) 
        if name == "false" 
            return new BooleanExpression(false)
        if name == "null"
            return new NullExpression(expected_type)
        let current_scope = this.get_current_scope()
        let resolved = this.get_var_from_current_scope(name)
        let var_ty = Type.unknown()
        if resolved != null {
            let var_id = resolved
            if var_id.kind == VarIdKind.FNC
                var_ty = get_func(this.program, var_id).fnc_type
            else if var_id.kind == VarIdKind.VAR
                var_ty = get_var(this.program, var_id).value_type
            else if var_id.kind == VarIdKind.CONST
                var_ty = get_const(this.program, var_id as ConstId).value_type
            else if var_id.kind == VarIdKind.CLASS or var_id.kind == VarIdKind.ENUM
                var_ty = new Type(TypeKind.RECORD)
            else if var_id.kind == VarIdKind.MODULE
                var_ty = new Type(TypeKind.MODULE)
            return new VarAccessExpression(var_id, var_ty)
        }
        this.error(ErrorKind.NAME, "Undefined variable '$name'", var_access_node.range)
        return null
    }
    private check_assignment(this, left: Expression, right: Expression, binary_node: BinaryExpressionNode): Expression {
        let op = binary_node.op
        if op != BinaryOp.ASSIGN {
            if is_object(left.value_type){
                let exp = this.check_object_bin_assign(left, binary_node)
                if exp != null or this.has_errored() return exp
            }
            right = this.check_bin_expr(left.value_type, lower_bin_assign_node(binary_node))
        }
        if left.value_type.kind == TypeKind.RECORD {
            this.error(ErrorKind.TYPE, "Cannot assign a value to a record", binary_node.range)
            return null
        }
        if !check_is_var(left) {
            this.error(ErrorKind.TYPE, "Cannot assign a value to a constant", binary_node.range)
            return null
        }
        if !this.types_are_eq(left.value_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Illegal assignment of variable of type '$(this.dump_type(right.value_type))' to '$(this.dump_type(left.value_type))'", binary_node.range)
            return null
        }
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type)
    }
    private check_object_bin_assign(this, left: Expression, binary_node: BinaryExpressionNode): Expression {
        let op = binary_node.op
        let method_name = bin_op_to_op_overload_name(op)
        let owner_class = get_class_from_type(this.program, left.value_type as ObjectType)
        let prop_id = owner_class.prop_map[method_name]
        if prop_id == null {
            return null
        }
        let method_type = get_class_prop_type(this.program, prop_id) as FunctionType
        let arg_type = method_type.arg_types[0]
        let right = this.check_expression(arg_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(arg_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_exp = new MemberExpression(left, prop_id, method_type)
        let args: Expression[] = [right]
        return new CallExpression(member_exp, args, method_type.return_type)
    }
    private check_object_binary_expr(this, left: Expression, binary_node: BinaryExpressionNode, right: Expression): Expression {
        let op = binary_node.op
        let method_name = bin_op_to_op_overload_name(op)
        if method_name == null {
            this.error(ErrorKind.GEN, "Unsupported binary operator overload for operator '$(dump_bin_op(op))'", binary_node.range)
            return null
        }
        let owner_class = get_class_from_type(this.program, left.value_type)
        let prop_id = owner_class.prop_map[method_name]
        if prop_id == null {
            if op == BinaryOp.EEQ or op == BinaryOp.NEQ {
                return new BinaryExpression(left, op, this.check_expression(left.value_type, binary_node.rhs), new BooleanType())
            }
            this.error(ErrorKind.NAME, "No binary operator overload for '$(dump_bin_op(op))' in object of class '$(owner_class.name)' please implement the method $method_name to support this", binary_node.range)
            return null
        }
        let method_type = get_class_prop_type(this.program, prop_id) as FunctionType
        let arg_type = method_type.arg_types[0]
        if right == null 
            right = this.check_expression(arg_type, binary_node.rhs)
        if this.has_errored() return null
        if is_null(right) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            return new BinaryExpression(left, op, right, new BooleanType())
        }
        if !this.types_are_eq(arg_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_exp = new MemberExpression(left, prop_id, method_type)
        let args: Expression[] = [right]
        return new CallExpression(member_exp, args, method_type.return_type)
    }
    private check_object_setitem_expr(this, object: Expression, binary_node: BinaryExpressionNode): Expression {
        let index_expr_node = binary_node.lhs as ExpressionIndexNode
        let owner_class = get_class_from_type(this.program, object.value_type)
        let prop_id = owner_class.prop_map["__setitem__"]
        if prop_id == null {
            this.error(ErrorKind.GEN, "No operator overload for index set operator on $(owner_class.name) object please implement method __setitem__ to use in this class", index_expr_node.range)
            return null
        }
        let method_type = get_class_prop_type(this.program, prop_id) as FunctionType
        let arg1_type = method_type.arg_types[0]
        let arg2_type = method_type.arg_types[1]
        if this.has_errored() return null
        let index = this.check_expression(arg1_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(arg1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg1_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let value = this.check_expression(arg2_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(arg1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg2_type))' but got type '$(this.dump_type(value.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_expr = new MemberExpression(object, prop_id, method_type)
        let args: Expression[] = [index, value]
        return new CallExpression(member_expr, args, method_type.return_type)
    }

    private check_bin_expr(this, expected_type: Type, binary_node: BinaryExpressionNode): BinaryExpression {
        let op = binary_node.op
        let is_assign_op = op >= BinaryOp.ASSIGN and op <= BinaryOp.SR_ASSIGN
        if op == BinaryOp.ASSIGN and binary_node.lhs.expr_kind == ExpressionKind.INDEX {
            let possible_obj = this.check_expression(Type.unknown(), (binary_node.lhs as ExpressionIndexNode).expression)
            if this.has_errored() return null
            if is_object(possible_obj.value_type)
                return this.check_object_setitem_expr(possible_obj, binary_node) as BinaryExpression
        }
        let left = this.check_expression(expected_type, binary_node.lhs)
        if this.has_errored() return null
        if is_object(left.value_type) and !is_assign_op and op != BinaryOp.IN
            return this.check_object_binary_expr(left, binary_node, null) as BinaryExpression
        let right = this.check_expression(left.value_type, binary_node.rhs)
        if this.has_errored() return null
        if is_object(right.value_type) and op == BinaryOp.IN {
            return this.check_object_binary_expr(right, binary_node, left) as BinaryExpression
        }
        if this.has_errored() return null
        let is_const = left.is_constant and right.is_constant
        if is_assign_op {
            return this.check_assignment(left, right, binary_node) as BinaryExpression
        }
        if left.value_type.kind == TypeKind.UNKNOWN and right.value_type.kind != TypeKind.UNKNOWN
            left.value_type = right.value_type
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.F64)) // Might need to cast it to the biggest available
                if is_int(right.value_type)
                    right = cast_exp_to_type(right, new Type(TypeKind.F64)) // Might need to cast it to the biggest available
                return new BinaryExpression(left, op, right, left.value_type)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                check_cast_lower_bits(&left, &right)
                let exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = new BooleanType()
                
                return new BinaryExpression(left, op, right, exp_type, is_const)
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                }
                check_cast_lower_bits(&left, &right)
                return new BinaryExpression(left, op, right, left.value_type, is_const)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type, is_const)
        }
        if op >= BinaryOp.GT and op <= BinaryOp.NEQ {
            if is_numeric(left.value_type) and is_numeric(right.value_type){
                check_cast_lower_bits(&left, &right)
            }
            let boolean_type = new BooleanType()
            return new BinaryExpression(left, op, right, boolean_type, is_const)
        }
        if op == BinaryOp.ADD or op == BinaryOp.SUB and is_pointer(left.value_type) and right.value_type.kind == TypeKind.INT {
            return new BinaryExpression(left, op, right, left.value_type, false)
        } if op == BinaryOp.RANGE and left.value_type.kind == TypeKind.INT and right.value_type.kind == TypeKind.INT {
            let range_type = this.get_type_from_current_scope("Range")
            return new NewExpression(range_type, range_type, [left, right], true) as BinaryExpression
        }
        this.error(ErrorKind.TYPE, "Illegal binary operation '$(dump_bin_op(op))' between types '$(this.dump_type(left.value_type))' and '$(this.dump_type(right.value_type))'", binary_node.range)
        return null
    }
    private check_unary_expr(this, expected_type: Type, unary_node: UnaryExpressionNode): UnaryExpression {
        let op = unary_node.op
        let expression = this.check_expression(expected_type, unary_node.expression)
        if this.has_errored() return null
        let ty = expression.value_type
        let is_const = expression.is_constant
        if op == UnaryOp.NEG {
            if is_numeric(ty) return new UnaryExpression(op, expression, ty, is_const)
        }
        if op == UnaryOp.NOT {
            if is_bool(ty) or is_numeric(ty)
                return new UnaryExpression(op, expression, ty, is_const)
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR {
            if is_numeric(ty) or is_pointer(ty) {
                if !check_is_var(expression) {
                    this.error(ErrorKind.GEN, "Illegal unary operation $(dump_unary_op(op)) on constant", unary_node.expression.range)
                    return null
                }
                return new UnaryExpression(op, expression, ty)
            }
        }
        if op == UnaryOp.ADDROF {
            if check_is_var(expression)
                return new UnaryExpression(op, expression, new PointerType(expression.value_type))
        }
        if op == UnaryOp.DEL {
            if is_object(ty) or is_pointer(ty)
                return new UnaryExpression(op, expression, new Type(TypeKind.VOID))
        }
        this.error(ErrorKind.TYPE, "Illegal unary operation $(dump_unary_op(op)) on type '$(this.dump_type(ty))'", unary_node.range)
        return null
    }
    private check_typecast_expr(this, type_expr_node: TypeCastExpressionNode): Expression {
        let exp = this.check_expression(Type.unknown(), type_expr_node.expression)
        let dest_ty = this.check_type(type_expr_node.bound_type)
        let val_ty = exp.value_type
        if this.has_errored() return null
        /* TODO:
            int to pointer.
            boolean to int/float.
        */
        if is_buitin(this.program, dest_ty, "string") {
            return new StringExpression("", [0], [exp], dest_ty)
        }
        let is_valid_cast = false
        if is_numeric(dest_ty) and is_numeric(val_ty) {
            is_valid_cast = true    
        }
        if is_int(dest_ty) and val_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        // TODO: Re-think this, this is a temporary fix
        if is_int(val_ty) and dest_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        if is_numeric(dest_ty) and is_buitin(this.program, val_ty, "string") {
            let call: IntrinsicCall = null
            if is_float(dest_ty) {
                call = new IntrinsicCall(Intrinsics.STR_TO_F)
            } else if dest_ty.kind < TypeKind.I64 or (ARCH_WORD_SIZE < 64 and dest_ty.kind == TypeKind.INT) {
                call = new IntrinsicCall(Intrinsics.STR_TO_I)
            } else {
                //TODO: I need to implement string to i128
                call = new IntrinsicCall(Intrinsics.STR_TO_L)
            }
            call.args << exp
            exp = call
            is_valid_cast = true
        }
        if is_object(dest_ty) and is_object(val_ty) {
            is_valid_cast = true
        }
        if is_pointer(dest_ty) and is_pointer(val_ty) {
            is_valid_cast = true
        }
        if is_bool(dest_ty) {
            is_valid_cast = true
        }
        if !is_valid_cast {
            this.error(ErrorKind.TYPE, "Cannot cast type '$(this.dump_type(val_ty))' to '$(this.dump_type(dest_ty))'", type_expr_node.range)
            return null
        }
        return new TypeCastExpression(exp, dest_ty)
    }
    private check_constructor_call(this, class_id: ClassId, args: ExpressionNode[], argsp: Expression[]*): string { 
        let obj_class = get_class(this.program, class_id)
        let field_id = obj_class.construct
        if field_id == null {
            return "Cannot construct an object of abstract class"
        }
        let constructor = obj_class.methods[field_id.id] 
        let construct_type = constructor.method_type
        let checked_args = this.fill_in_call_args(construct_type, constructor.args, args)
        if this.has_errored() return null
        let index = this.check_function_call_args_match(construct_type, checked_args)
        if index >= -1 {
            if index == -1 {
                return "Expected $(construct_type.arg_types.length) argument(s) on constructor call but got $(args.length)"
            } else {
                return "Expected type '$(this.dump_type(construct_type.arg_types[index]))' but got type '$(this.dump_type(checked_args[index].value_type))' as constructor call argument ($index)"
            }
        }
        argsp[0] = checked_args
        return null
    }
    private check_new_expr(this, new_expr_node: NewExpressionNode): NewExpression {
        let expression_type = this.check_type(new_expr_node.parsed_type)
        if this.has_errored() return null
        let memory_type = expression_type
        if (memory_type.kind == TypeKind.RESOLVED_GENERIC) memory_type = (memory_type as GenericType).instantiated_type
        let args: Expression[] = []
        if is_object(memory_type) {
            let msg = this.check_constructor_call(get_class_from_type(this.program, memory_type).id, new_expr_node.args, &args)
            if msg != null {
                this.error(ErrorKind.GEN, msg, new_expr_node.range)
                return null
            }
        } else if memory_type.kind == TypeKind.PTR {
            memory_type = (memory_type as PointerType).pointee_type
            let argno = new_expr_node.args.length
            if argno != 1 {
                this.error(ErrorKind.GEN, "New operator expects 1 argument for pointers but got $argno argument(s)", new_expr_node.range)
                return null
            }
            let int_ty = new Type(TypeKind.INT)
            let arg = this.check_expression(int_ty, new_expr_node.args[0])
            if this.has_errored() return null
            if !this.types_are_eq(int_ty, arg.value_type) {
                this.error(ErrorKind.GEN, "New operator for pointers expects argument of type '$(this.dump_type(int_ty))' but got type '$(this.dump_type(arg.value_type))'", new_expr_node.args[0].range)
                del int_ty
                return null
            }
            args << arg
        } else {
            this.error(ErrorKind.TYPE, "New operator expects either an a pointer or an object not a '$(this.dump_type(memory_type))'", new_expr_node.range)
            return null
        }
        return new NewExpression(memory_type, expression_type, args, new_expr_node.onheap)
    }   
    private check_member_access(this, accessor: PropId): string {
        let visibility = ACCESS_ATTR.PUBLIC
        let accessee = get_class_from_prop_id(this.program, accessor)
        let member_name = ""
        if accessor.kind == PropIdKind.METHOD {
            let method = accessee.methods[accessor.id]
            visibility = method.visibility
            member_name = method.name
        } else {
            let field = accessee.fields[accessor.id]
            visibility = field.visibility
            member_name = field.name
        }
        if this.current_class != null {
            if this.current_class.module_id != accessee.id.module_id or accessee.id.id != this.current_class.id {
                if visibility == ACCESS_ATTR.PRIVATE {
                    return "Property '$member_name' is defined as private and only accessible within the class $(accessee.name)"
                }
            }
        } else if visibility != ACCESS_ATTR.PUBLIC {
            return "Property '$member_name' is defined as $(dump_access(visibility)) and only accessible within the class $(accessee.name)"
        }
        return null
    }
    private check_member_expr(this, expected_type: Type, member_expr_node: MemberExpressionNode): MemberExpression {
        let prop_owner = this.check_expression(Type.unknown(), member_expr_node.expression)
        if this.has_errored() return null
        let prop_owner_type = prop_owner.value_type
        let prop_name = member_expr_node.member.value
        let prop_ty = Type.unknown()
        let parent_class: Class = null
        let prop_id: PropId = null
        let err_msg: string = null
        if is_object(prop_owner_type) {
            while prop_owner_type.kind == TypeKind.RESOLVED_GENERIC {
                prop_owner_type = (prop_owner_type as GenericType).instantiated_type
            }
            parent_class = get_class_from_type(this.program, prop_owner_type)
            prop_id = parent_class.prop_map[prop_name]
            if (prop_id == null){   
                this.error(ErrorKind.NAME, "Property '$prop_name' doesn't exist in object of class '$(parent_class.name)'", member_expr_node.member.range)
                return null
            }
            err_msg = this.check_member_access(prop_id)
            if (err_msg != null){
                this.error(ErrorKind.GEN, err_msg, member_expr_node.member.range)
                return null
            } 
            prop_ty = get_class_prop_type(this.program, prop_id)
        } else if prop_owner_type.kind == TypeKind.RECORD {
            let var_id = (prop_owner as VarAccessExpression).value_id
            if var_id.kind == VarIdKind.CLASS {
                parent_class = this.get_class_from_var_id(var_id)
                prop_id = parent_class.static_prop_map[prop_name]
                if (prop_id == null) {   
                    this.error(ErrorKind.NAME, "Property '$prop_name' is not a static member in class '$(parent_class.name)", member_expr_node.member.range)
                    return null
                }
                err_msg = this.check_member_access(prop_id)
                if (err_msg != null){
                    this.error(ErrorKind.GEN, err_msg, member_expr_node.member.range)
                    return null
                }
                prop_ty = get_class_prop_type(this.program, prop_id)
            } else {
                let parent_enum = this.get_enum_from_var_id(var_id)
                prop_id = parent_enum.field_map[prop_name]
                if (prop_id == null) {   
                    this.error(ErrorKind.NAME, "'$prop_name' is not an element of enum the '$(parent_enum.name)'", member_expr_node.member.range)
                    return null
                }
                prop_ty = new EnumType(parent_enum.id)
            }
        } else if is_pointer(prop_owner_type){
            // FIXME: Better way to express this.
            let mem_intrinsic = Intrinsics.MEMCPY 
            if prop_name == "copy_from" {
                mem_intrinsic = Intrinsics.MEMCPY 
            } else if prop_name == "move_from" {
               mem_intrinsic = Intrinsics.MEMMOVE
            } else if prop_name == "fill_with" {
                mem_intrinsic = Intrinsics.MEMSET
            } else if prop_name == "resize" {
                mem_intrinsic = Intrinsics.MEMRESIZE
            } else if prop_name == "compare" {
                mem_intrinsic = Intrinsics.MEMCMP
            } else {
                this.error(ErrorKind.NAME, "intrinsic $prop_name is not defined", member_expr_node.member.range)
                return null
            }
            let intrinsic_call = new IntrinsicCall(mem_intrinsic) 
            intrinsic_call.args << prop_owner
            return intrinsic_call as MemberExpression
        } else if prop_owner_type.kind == TypeKind.MODULE {
            let scope_id = ((prop_owner as VarAccessExpression).value_id as ModuleVarId).scope_id
            let current_scope = this.current_scope
            this.current_module = scope_id.module_id
            this.current_scope = scope_id
            let var_access_node: VarAccessExpressionNode(member_expr_node.member)
            let value = this.check_var_access_expr(Type.unknown(), var_access_node)
            this.current_module = current_scope.module_id
            this.current_scope = current_scope
            return value as MemberExpression
        } else {
            this.error(ErrorKind.GEN, "Cannot get property '$prop_name' of type '$(this.dump_type(prop_owner.value_type))'", member_expr_node.expression.range)
            return null
        }
        return new MemberExpression(prop_owner, prop_id, prop_ty)
    }
    private check_ternary_expr(this, expected_type: Type, ternary_expr_node: TernaryExpressionNode): TernaryExpression {
        let cond = this.check_condition(ternary_expr_node.cond)
        if this.has_errored() return null
        let is_true = this.check_expression(expected_type, ternary_expr_node.is_true)
        if this.has_errored() return null
        let is_true_ty = is_true.value_type
        let is_false = this.check_expression(is_true_ty, ternary_expr_node.is_false)
        if this.has_errored() return null
        let is_false_ty = is_false.value_type
        if !this.types_are_eq(is_true_ty, is_false_ty) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(is_true_ty))' from first case but got type '$(this.dump_type(is_false_ty))'", ternary_expr_node.range)
            return null
        }
        return new TernaryExpression(cond, is_true, is_false)
    }
    private check_object_index_expr(this, object: Expression, index_expr_node: ExpressionIndexNode): Expression {
        let owner_class = get_class_from_type(this.program, object.value_type)
        let prop_id = owner_class.prop_map["__getitem__"]
        if prop_id == null {
            this.error(ErrorKind.GEN, "No operator overload for indexing operator on $(owner_class.name) object please implement method __getitem__ to use indexing in this class", index_expr_node.range)
            return null
        }
        let method_type = get_class_prop_type(this.program, prop_id) as FunctionType
        let arg_type = method_type.arg_types[0]
        let index = this.check_expression(arg_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(arg_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(arg_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let member_expr = new MemberExpression(object, prop_id, method_type)
        return new CallExpression(member_expr, [index], method_type.return_type)
    }
    private check_index_expr(this, expected_type: Type, index_expr_node: ExpressionIndexNode): IndexExpression {
        let root_expression = this.check_expression(Type.unknown(), index_expr_node.expression)
        if this.has_errored() return null
        if is_object(root_expression.value_type)
            return this.check_object_index_expr(root_expression, index_expr_node) as IndexExpression
        let index = this.check_expression(new Type(TypeKind.INT), index_expr_node.index)
        if this.has_errored() return null
        if !is_int(index.value_type) {
            this.error(ErrorKind.TYPE, "Expected an integer type for index", index_expr_node.index.range)
            return null
        }
        let value_type = Type.unknown()
        let root_type = root_expression.value_type
        if root_type.kind == TypeKind.PTR {
            value_type = (root_type as PointerType).pointee_type
        } else if root_type.kind == TypeKind.ARRAY {
            value_type = (root_type as ArrayType).element_type
        } else {
            this.error(ErrorKind.TYPE, "Cannot index into a value of type '$(this.dump_type(root_type))'", index_expr_node.range)
            return null
        }
        return new IndexExpression(root_expression, index, value_type)
    }
    private get_func_args_from_expression(this, called: Expression): FunctionArg[]{
        if called.expr_kind == ExpressionKind.ACCESS {
            let var_id = (called as VarAccessExpression).value_id
            if var_id.kind == VarIdKind.FNC {
                return get_func(this.program, var_id).args
            }
        } else if called.expr_kind == ExpressionKind.MEMBER {
            let prop_id = (called as MemberExpression).member_id
            return get_method(this.program, prop_id).args
        }
        return null
    }
    private fill_in_call_args(this, fnc_ty: FunctionType, func_args: FunctionArg[], args: ExpressionNode[]): Expression[] {
        let called_args: Expression[] = []
        for let i = 0; i < args.length; i++ {
            let expected_type = fnc_ty.arg_types.length > i ? fnc_ty.arg_types[i] : Type.unknown()
            called_args << this.check_expression(expected_type, args[i])
        }
        if this.has_errored() or func_args == null return called_args
        if func_args.length > args.length {
            for let i = args.length; i < func_args.length; ++i {
                let arg = func_args[i]
                if arg.default != null
                    called_args << arg.default
            }
        }
        return called_args
    }
    private check_function_call_args_match(this, func_ty: FunctionType, args: Expression[]): int {
        if func_ty.arg_types.length != args.length {
            return -1
        }
        for let i = 0; i < args.length; ++i {
            if !this.types_are_eq(func_ty.arg_types[i], args[i].value_type) {
                return i
            }
        }
        return -2
    }
    private check_call_expr(this, expected_type: Type, call_expr_node: CallExpressionNode): CallExpression {
        let called = this.check_expression(Type.unknown(), call_expr_node.callee)
        if this.has_errored() return null
        if called.expr_kind == ExpressionKind.INTRINSIC and called.value_type.kind == TypeKind.UNKNOWN {
            return this.check_intrinsic_call(called as IntrinsicCall, call_expr_node) as CallExpression
        }
        if called.value_type.kind != TypeKind.FNC {
            this.error(ErrorKind.TYPE, "Expected a function type for call but got '$(this.dump_type(called.value_type))'", call_expr_node.callee.range)
            return null
        }
        //TODO: Check for generic functions.
        let func_ty = called.value_type as FunctionType
        let func_args = this.get_func_args_from_expression(called)
        let args = this.fill_in_call_args(func_ty, func_args, call_expr_node.args)
        if this.has_errored() return null
        let index = this.check_function_call_args_match(func_ty, args)
        if index >= -1 {
            if index == -1 {
                this.error(ErrorKind.GEN, "Expected $(func_ty.arg_types.length) argument(s) on function call but got $(args.length)", call_expr_node.range)
            } else {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(func_ty.arg_types[index]))' but got type '$(this.dump_type(args[index].value_type))' as function call argument", call_expr_node.args[index].range)
            }
            return null
        }
        return new CallExpression(called, args, func_ty.return_type)
    }
    private check_intrinsic_call(this, intrinsic_call: IntrinsicCall, call_expr_node: CallExpressionNode): IntrinsicCall {
        //Note: This assumes that intrisics always have alteast 1 arg and that call_expr_node.args has the rest of the args
        let args = call_expr_node.args
        let intrinsic_func = intrinsic_call.intrinsic
        let is_mem_grp1 = intrinsic_func == Intrinsics.MEMCPY or intrinsic_func == Intrinsics.MEMMOVE or intrinsic_func == Intrinsics.MEMCMP
        for let i = 0; i < args.length; i++ {
            let expected_type = is_mem_grp1 and i == 1 ? Type.unknown() : intrinsic_call.args[0].value_type
            intrinsic_call.args << this.check_expression(expected_type, args[i])
            if this.has_errored() return null
        }
        // Mem intrinsics
        if !is_pointer(intrinsic_call.args[0].value_type) {
            this.error(ErrorKind.TYPE, "Expected argument 1 to be of type to be of a pointer but got '$(this.dump_type(intrinsic_call.args[0].value_type))'", call_expr_node.callee.range)
            return null
        }
        if intrinsic_func == Intrinsics.MEMRESIZE {
            if intrinsic_call.args.length != 2 {
                this.error(ErrorKind.GEN, "Expected 2 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            intrinsic_call.value_type = intrinsic_call.args[0].value_type
            if !is_int(intrinsic_call.args[1].value_type) {
                this.error(ErrorKind.TYPE, "Expected an int of but got type '$(this.dump_type(intrinsic_call.args[1].value_type))' as function call argument", call_expr_node.args[0].range)
                return null
            }
        } else if is_mem_grp1 or intrinsic_func == Intrinsics.MEMSET {
            if intrinsic_call.args.length != 3 {
                this.error(ErrorKind.GEN, "Expected 3 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            let exp_arg2_type = intrinsic_call.args[0].value_type
            intrinsic_call.value_type = exp_arg2_type
            if intrinsic_func == Intrinsics.MEMSET {
                exp_arg2_type = (exp_arg2_type as PointerType).pointee_type
            }
            if !this.types_are_eq(exp_arg2_type, intrinsic_call.args[1].value_type) {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(exp_arg2_type))' of but got type '$(this.dump_type(intrinsic_call.args[1].value_type))' as function call argument", call_expr_node.args[0].range)
                return null
            }
            if !is_int(intrinsic_call.args[2].value_type) {
                this.error(ErrorKind.TYPE, "Expected an int of but got type '$(this.dump_type(intrinsic_call.args[2].value_type))' as function call argument", call_expr_node.args[1].range)
                return null
            }
            if intrinsic_func == Intrinsics.MEMCMP {
                intrinsic_call.value_type = new Type(TypeKind.INT)
            }
        }
        return intrinsic_call
    }
    private check_int_expression(this, expected_type: Type, int_node: IntExpressionNode): IntExpression{
        let int_value = int_node.value.value
        let expr_value = new IntExpression(int_value)
        if is_int(expected_type)
            expr_value.value_type.kind = expected_type.kind
        if int_value < -8 or int_value > 7 and expr_value.value_type.kind == TypeKind.I4
            expr_value.value_type.kind = TypeKind.I8
        if int_value < -128 or int_value > 127 and expr_value.value_type.kind == TypeKind.I8
            expr_value.value_type.kind = TypeKind.I16
        if int_value < -32768 or int_value > 32767 and expr_value.value_type.kind == TypeKind.I16
            expr_value.value_type.kind = TypeKind.I32
        if int_value < -2147483648 or int_value > 2147483647 and (expr_value.value_type.kind == TypeKind.I32 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 32))
            expr_value.value_type.kind = TypeKind.I64
        if int_value < -9223372036854775808 or int_value > 9223372036854775807 and (expr_value.value_type.kind == TypeKind.I64 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 64))
            expr_value.value_type.kind = TypeKind.I128
        return expr_value
    }
    private check_float_expression(this, expected_type: Type, float_node: FloatExpressionNode): FloatExpression {
        let float_value = float_node.value.value
        let expr_value = new FloatExpression(float_value)
        let max_f32 = "3.4E38" as f64
        if is_float(expected_type)
            expr_value.value_type.kind = expected_type.kind
        if float_value < -max_f32 or float_value > max_f32 and expr_value.value_type.kind == TypeKind.F32
            expr_value.value_type.kind = TypeKind.F64

        return expr_value
    }
    private check_char_expression(this, char_node: CharExpressionNode): IntExpression {
        let expr_value = new IntExpression(char_node.value.value as i64)
        expr_value.value_type.kind = TypeKind.I8
        return expr_value
    }
    private check_string_expression(this, expected_type: Type, str_node: StringExpressionNode): StringExpression{
        let template_args: Expression[] = []
        for arg in str_node.template_args {
            template_args << this.check_expression(Type.unknown(), arg)
        }
        if !is_i8_ptr(expected_type) {
            expected_type = this.get_type_from_current_scope("string")
        }
        let str_exp = new StringExpression(str_node.value.value, str_node.value.fmt_indices, template_args, expected_type)
        str_exp.value_type = expected_type
        return str_exp
    }
    private check_expression(this, expected_type: Type, expr_node: ExpressionNode): Expression {
        if expr_node.expr_kind == ExpressionKind.INT 
            return this.check_int_expression(expected_type, expr_node as IntExpressionNode)
        if expr_node.expr_kind == ExpressionKind.FLOAT
            return this.check_float_expression(expected_type, expr_node as FloatExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CHAR
            return this.check_char_expression(expr_node as CharExpressionNode)
        if expr_node.expr_kind == ExpressionKind.STRING 
            return this.check_string_expression(expected_type, expr_node as StringExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expected_type, expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ACCESS
            return this.check_var_access_expr(expected_type, expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expected_type, expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expected_type, expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TERNARY
            return this.check_ternary_expr(expected_type, expr_node as TernaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CAST
            return this.check_typecast_expr(expr_node as TypeCastExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MEMBER
            return this.check_member_expr(expected_type, expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expected_type, expr_node as ExpressionIndexNode)
        if expr_node.expr_kind == ExpressionKind.CALL
            return this.check_call_expr(expected_type, expr_node as CallExpressionNode)
        return null
    }
    private check_condition(this, cond_node: ExpressionNode): Expression {
       let condition = this.check_expression(Type.unknown(), cond_node)
       if this.has_errored() return null
       return !is_bool(condition.value_type) ? cast_exp_to_type(condition, new BooleanType()) : condition
    }
    private check_if_stamement(this, if_stmt_node: IfStatementNode): IfStatement {
        let condition = this.check_condition(if_stmt_node.condition)
        let block = this.check_block(if_stmt_node.block)
        let else_block = if_stmt_node.else_block != null ? this.check_block(if_stmt_node.else_block) : null
        return new IfStatement(condition, block, else_block)
    }
    private check_var_declaration(this, var_decl_node: VarDeclarationStatement): VarDeclaration {
        let name = var_decl_node.var_name.value
        if this.is_constant_in_scope(name){
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", var_decl_node.var_name.range)
            return null
        }
        let current_scope = this.get_current_scope()
        let var_type = var_decl_node.var_type != null ? this.check_type(var_decl_node.var_type) : Type.unknown()
        if this.has_errored() return null
        if var_decl_node.value == null and var_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.GEN, "Variable '$name' has no type", var_decl_node.var_name.range)
            return null
        }
        let value = var_decl_node.value != null ? this.check_expression(var_type, var_decl_node.value) : null
        if this.has_errored() return null
        if value != null {
            if is_null(value) and value.value_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", var_decl_node.range)
                return null
            }
            if var_type.kind != TypeKind.UNKNOWN and !this.types_are_eq(var_type, value.value_type) {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(var_type))' but got type '$(this.dump_type(value.value_type))' on variable declaration", var_decl_node.range)
                return null
            }
            if var_type.kind == TypeKind.UNKNOWN {
                var_type = value.value_type
            }
        }
        if current_scope.vars[name] != null {
            this.error(ErrorKind.NAME, "Illegal re-declaration of already declared variable '$name'", var_decl_node.var_name.range)
            return null
        }
        let var = this.declare_var_within_current_scope(name, value, var_type)
        return new VarDeclaration(name, var.var_id)
    }
    private check_const_declaration(this, const_decl_stmt: ConstDeclarationStatement): ConstDeclaration {
        let name = const_decl_stmt.const_name.value
        let current_scope = this.get_current_scope()
        if this.is_constant_in_scope(name) or current_scope.vars[name] != null {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", const_decl_stmt.const_name.range)
            return null
        }
        let const_type = const_decl_stmt.const_type != null ? this.check_type(const_decl_stmt.const_type) : Type.unknown()
        if this.has_errored() return null
        let value = this.check_expression(const_type, const_decl_stmt.value)
        if this.has_errored() return null
        if !value.is_constant {
            this.error(ErrorKind.GEN, "Cannot assign a non-constant value to a constant", const_decl_stmt.value.range)
            return null
        }
        if is_null(value) and const_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", const_decl_stmt.range)
            return null
        }
        if const_type.kind != TypeKind.UNKNOWN and !this.types_are_eq(const_type, value.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(const_type))' but got type '$(this.dump_type(value.value_type))' on const declaration", const_decl_stmt.range)
            return null
        }
        let constant = this.declare_const_within_current_scope(name, value, value.value_type)
        return new ConstDeclaration(name, constant.const_id)
    }
    private check_for_statement(this, for_stmt_node: ForStatementNode): ForStatement {
        let for_stmt = new ForStatement()
        let for_scope = this.create_child_scope_within_current_scope()
        this.current_scope = for_scope.id
        let prev_in_loop = this.in_loop
        if for_stmt_node.for_kind == ForKind.DEF {
            if for_stmt_node.initialization != null
                for_stmt.initialization = this.check_statement(for_stmt_node.initialization)
            if for_stmt_node.condition != null
                for_stmt.condition = this.check_condition(for_stmt_node.condition)
            if for_stmt_node.incr_decr != null
                for_stmt.incr_decr = this.check_statement(for_stmt_node.incr_decr)
        } else {
            let iterator = this.check_expression(Type.unknown(), for_stmt_node.iterator)
            if this.has_errored() return null
            if !is_object(iterator.value_type) {
                this.error(ErrorKind.TYPE, "Iterator has to be an object", for_stmt_node.iterator.range)
                return null
            }
            let iterator_class = get_class_from_type(this.program, iterator.value_type)
            let iter_prop_id = iterator_class.prop_map["__iter__"]
            if iter_prop_id == null {
                this.error(ErrorKind.TYPE, "Iterator type has to have __iter__ as property", for_stmt_node.iterator.range)
                return null
            }
            let iter_generator_type = get_class_prop_type(this.program, iter_prop_id) as FunctionType
            let iteratable_type = iter_generator_type.return_type
            //TODO: Check iteratable is an iteratable
            let iterator_name =  "tmp_it"
            let iter_call = new CallExpression(new MemberExpression(iterator, iter_prop_id, iter_generator_type), [], iteratable_type)
            let iteratable_var_id = this.declare_var_within_current_scope(iterator_name, iter_call, iteratable_type).var_id
            for_stmt.for_in_setup = new VarDeclaration(iterator_name, iteratable_var_id)

            let iteratable_class = get_class_from_type(this.program, iteratable_type)
            let done_prop_id = iteratable_class.prop_map["done"]
            let iteratable_load = new VarAccessExpression(iteratable_var_id, iteratable_type)
            let bool_type = new BooleanType()
            for_stmt.condition = new UnaryExpression(UnaryOp.NOT, new MemberExpression(iteratable_load, done_prop_id, bool_type), bool_type)
            
            let iter_item_name =  for_stmt_node.it_name.value
            let next_prop_id = iteratable_class.prop_map["next"]
            let next_prop_type = get_class_prop_type(this.program, next_prop_id) as FunctionType
            let iter_item_type = next_prop_type.return_type
            let next_item_call = new CallExpression(new MemberExpression(iteratable_load, next_prop_id, next_prop_type), [], iter_item_type)
            let iter_item_var_id = this.declare_var_within_current_scope(iter_item_name, next_item_call, iter_item_type).var_id
            for_stmt.initialization = new VarDeclaration(iter_item_name, iter_item_var_id)
            for_stmt.incr_decr = new BinaryExpression(new VarAccessExpression(iter_item_var_id, iter_item_type), BinaryOp.ASSIGN, next_item_call, iter_item_type, false)
        }
        if this.has_errored() return null
        this.in_loop = true
        for_stmt.block = this.check_block(for_stmt_node.block, for_scope)
        this.in_loop = prev_in_loop
        this.current_scope = for_scope.parent
        return for_stmt
    }
    private check_while_statment(this, while_stmt_node: WhileStatementNode): WhileStatement {
        let condition = this.check_condition(while_stmt_node.condition)
        let prev_in_loop = this.in_loop
        this.in_loop = true
        let block = this.check_block(while_stmt_node.block)
        this.in_loop = prev_in_loop
        return new WhileStatement(condition, block)
    }
    private check_can_break(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal break outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.BREAK)
    }
    private check_can_continue(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal continue outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.CONTINUE)
    }
    private check_can_return(this, return_stmt: ReturnStatementNode): ReturnStatement {
        let expr = return_stmt.value
        let current_function_return_type = this.get_current_function_type().return_type
        let rt_stmt = new ReturnStatement()
        if expr != null {
            let rt_value = this.check_expression(current_function_return_type, expr)
            if this.has_errored() return null   
            if !this.types_are_eq(current_function_return_type, rt_value.value_type) {
                this.error(ErrorKind.TYPE, "Expected return type of '$(this.dump_type(current_function_return_type))' but got return type of '$(this.dump_type(rt_value.value_type))'", expr.range)
                return null
            }
            rt_stmt.return_value = rt_value
        } else {
            if current_function_return_type.kind != TypeKind.VOID {
                this.error(ErrorKind.TYPE, "Function return type is not void", return_stmt.range)
                return null
            }
        }
        return rt_stmt
    }
    private check_statement(this, stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.CONST
            return this.check_const_declaration(stmt_node as ConstDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue(stmt_node)
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break(stmt_node)
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode))
        if stmt_node.kind == StatementKind.EXPRESSION
            return this.check_expression(Type.unknown(), stmt_node as ExpressionNode)
        return null
    }
    private check_block(this, block_node: BlockNode, block_scope: Scope = null): Block {
        if this.has_errored() return null
        let block = new Block()
        block_scope = block_scope != null ? block_scope : this.create_child_scope_within_current_scope() //TODO: Use ?? in the future
        this.current_scope = block_scope.id
        for stmt_node in block_node.statements {
            let stmt = this.check_statement(stmt_node)
            if this.has_errored() return null
            block.statements << stmt
            if stmt.kind == StatementKind.RETURN {
                block.returns = true
                break
            }
            if stmt.kind == StatementKind.IF {
                let if_stmt = stmt as IfStatement
                if if_stmt.else_block != null {
                    if if_stmt.block.returns and if_stmt.else_block.returns {
                        block.returns = true
                        break
                    }
                }
            }
            if stmt.kind == StatementKind.CONTINUE {
                block.continues = true
                break
            }
            if stmt.kind == StatementKind.BREAK {
                block.breaks = true
                break
            }
        }
        this.current_scope = block_scope.parent
        del block_scope
        return block
    }
}