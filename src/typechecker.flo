$WORD_SIZE = 64
class Type {
    kind: TypeKind
    constructor(kind: TypeKind){
        this.kind = kind
    }
    __eq__(other: Type): bool {
        return this.kind == other.kind
    }
}
$UNKNOWN_TYPE = new Type(TypeKind.UNKNOWN)
class BooleanType (Type) {
    constructor(){
        super(TypeKind.BOOL)
    }
}
class PointerType (Type) {
    pointee_type: Type
    constructor(pointee_type: Type){
        super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType (Type) {
    arg_types: Type[]
    return_type: Type
    constructor(arg_types: Type[], return_type: Type){
        super(TypeKind.FNC)
        this.arg_types = arg_types
        this.return_type = return_type
    }
}
class Value {
    value_type: Type
}
class Statement {
    kind: StatementKind
    constructor(kind: StatementKind){
        this.kind = kind
    }
}
class TypeId {
    module_id: int
    kind: TypeIdKind
    id: int
    constructor(module_id: int, kind: TypeIdKind, id: int){
        this.module_id = module_id
        this.kind = kind
        this.id =  id
    }
}
class ClassId(TypeId) {
    constructor(module_id: int, id: int){
        super(module_id, TypeIdKind.CLASS, id)
    }
}
class EnumId(TypeId) {
    constructor(module_id: int, id: int){
        super(module_id, TypeIdKind.ENUM, id)
    }
}
class Expression (Statement) {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    constructor(expr_kind: ExpressionKind){
        super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.is_constant = false
    }
}
class ArrayType (Type) {
    element_type: Type
    length: int
    constructor(element_type: Type, length: int){
        super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
    __eq__(other: Type): bool {
        if other.kind != TypeKind.ARRAY
            return false
        let other_array = other as ArrayType
        return this.length == other_array.length and this.element_type == other_array.element_type
    }
}
class ObjectType (Type) {
    class_id: ClassId
    constructor(class_id: ClassId){
        super(TypeKind.OBJECT)
        this.class_id = class_id
    }
}
class EnumType (Type) {
    enum_id: EnumId
    constructor(enum_id: EnumId){
        super(TypeKind.ENUM)
        this.enum_id = enum_id
    }
}
//TODO: Find the string class.
class StringType (ObjectType){
    constructor(){
        super(new ClassId(-1, -1))
    }
}
class IntExpression (Expression) {
    value: int
    constructor(value: int){
        super(ExpressionKind.INT)
        this.value_type = new Type(TypeKind.INT)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression (Expression) {
    value: int 
    constructor(value: int){
        super(ExpressionKind.BOOL)
        this.value_type = new BooleanType()
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression (Expression) {
    value: float
    constructor(value: float){
        super(ExpressionKind.FLOAT)
        this.value_type = new Type(TypeKind.FLOAT)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression (Expression) {
    value: string
    constructor(value: string){
        super(ExpressionKind.STRING)
        this.value_type = new StringType()
        this.value = value
        this.is_constant = true
    }
}
class NullExpression (Expression) {
    constructor(value_type: Type){
        super(ExpressionKind.NULL)
        this.value_type = value_type 
        this.is_constant = true
    }
}
class ArrayExpression (Expression) {
    value: Expression[]
    constructor(value: Expression[]){
        super(ExpressionKind.ARRAY)
        this.value = value
        if value.length > 0
            this.value_type = new ArrayType(value[0].value_type, value.length)
    }
}
class BinaryExpression (Expression) {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type, is_constant = false){
        super(ExpressionKind.BIN)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.value_type = value_type
        this.is_constant = is_constant
    }
}
class UnaryExpression (Expression) {
    op: UnaryOp
    expression: Expression
    constructor(op: UnaryOp, expression: Expression, value_type: Type, is_constant = false){
        super(ExpressionKind.UNARY)
        this.op = op
        this.expression = expression
        this.value_type = value_type
        this.is_constant = is_constant
    }
}
class TernaryExpression (Expression) {
    cond: Expression
    is_true: Expression
    is_false: Expression
    constructor(cond: Expression, is_true: Expression, is_false: Expression){
        super(ExpressionKind.TERNARY)
        this.cond = cond
        this.is_true = is_true
        this.is_false = is_false
        this.value_type = is_true.value_type
    }
}
class TypeExpression (Expression) {
    expr: Expression
    ty_op: TypeExprOp
    bound_type: Type
    constructor(expr: Expression, ty_op: TypeExprOp, bound_type: Type){
        super(ExpressionKind.TYPEBOUND)
        this.expr = expr
        this.ty_op = ty_op
        if ty_op == TypeExprOp.AS 
            this.value_type = bound_type
        if ty_op == TypeExprOp.IS
            this.value_type = new BooleanType()
        this.bound_type = bound_type
        this.is_constant = expr.is_constant
    }
}
class NewExpression (Expression) {
    constructor(value_type: Type){
        super(ExpressionKind.NEW)
        this.value_type = value_type
    }
}
class IndexExpression (Expression) {
    expression: Expression
    index: Expression
    constructor(expression: Expression, index: Expression, value_type: Type){
        super(ExpressionKind.INDEX)
        this.expression = expression
        this.index = index
        this.value_type = value_type
    }
}
class CallExpression (Expression) {
    callee: Expression
    args: Expression[]
    constructor(callee: Expression, args: Expression[], value_type: Type){
        super(ExpressionKind.CALL)
        this.callee = callee
        this.args = args
        this.value_type = value_type
    }
}
class VarId {
    kind: VarIdKind
    module_id: int
    id: int
    constructor(kind: VarIdKind, module_id: int, id: int){
        this.kind = kind
        this.module_id = module_id
        this.id = id
    }
}
class ConstId(VarId) {
    constructor(module_id: int, id: int){
       super(VarIdKind.CONST, module_id, id)
    }
}
class PropId {
    kind: PropIdKind
    type_id: TypeId
    id: int
    constructor(kind: PropIdKind, type_id: TypeId, id: int){
        this.kind = kind
        this.type_id = type_id
        this.id = id
    }
}
 
class MemberExpression (Expression) {
    expression: Expression
    member_id: PropId
    constructor(expression: Expression, member_id: PropId, value_type: Type){
        super(ExpressionKind.MEMBER)
        this.expression = expression
        this.member_id = member_id
        this.value_type = value_type
    }
}
class VarAccessExpression (Expression) {
    value_id: VarId
    constructor(value_id: VarId, value_type: Type){
        super(ExpressionKind.ACCESS)
        this.value_id = value_id
        this.value_type = value_type
        this.is_constant = value_id.kind == VarIdKind.CONST
    }
}
class Block {
    statements: Statement[]
    returns: bool /* Block contains a return */
    continues: bool /* Block contains a continue */
    breaks: bool /* Block contains a break */
    constructor(){
        this.statements = []
        this.returns = false
        this.continues = false
        this.breaks = false
    }
}
class IfStatement (Statement) {
    condition: Expression
    block: Block
    else_block: Block
    constructor(condition: Expression, block: Block, else_block: Block){
        super(StatementKind.IF)
        this.condition = condition
        this.block = block
        this.else_block = else_block
    }
}
class VarDeclaration (Statement) {
    name: string
    var_id: VarId
    is_static: bool
    constructor(name: string, var_id: VarId){
        super(StatementKind.VAR)
        this.var_id = var_id
        this.name = name
        this.is_static = false
    }
}
class ConstDeclaration (Statement) {
    name: string
    const_id: ConstId
    is_static: bool
    constructor(name: string, const_id: ConstId){
        super(StatementKind.CONST)
        this.const_id = const_id
        this.name = name
        this.is_static = false
    }
}
class ForStatement (Statement) {
    initialization: Statement
    condition: Expression
    incr_decr: Expression
    block: Block
    constructor(){
        super(StatementKind.FOR)
        this.initialization = null
        this.condition = null
        this.incr_decr = null
    }
}
class WhileStatement (Statement) {
    condition: Expression
    block: Block
    constructor(condition: Expression, block: Block){
        super(StatementKind.WHILE)
        this.condition = condition
        this.block = block
    }
}
class ReturnStatement (Statement) {
    return_value: Expression
    constructor(){
        super(StatementKind.RETURN)
        this.return_value = null
    }
}
fnc is_numeric(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_float(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.F16 and val_ty.kind <= TypeKind.FLOAT
}
fnc is_int(val_ty: Type): bool {
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.INT
}
fnc is_bool(val_ty: Type): bool {
    return val_ty.kind == TypeKind.BOOL
}
fnc is_i8_ptr(val_ty: Type): bool {
    if val_ty.kind == TypeKind.PTR
        return (val_ty as PointerType).pointee_type.kind == TypeKind.I8
    return false
}
fnc is_object(val_ty: Type): bool {
    return val_ty.kind == TypeKind.OBJECT
}
fnc is_pointer(val_ty: Type): bool {
    return val_ty.kind == TypeKind.PTR
}
fnc is_null(exp: Expression): bool {
    return exp.expr_kind == ExpressionKind.NULL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    return exp.value_type == val_ty ? exp : new TypeExpression(exp, TypeExprOp.AS, val_ty)
}
fnc max_type(t1: Type, t2: Type): Type {
    return t1.kind > t2.kind ? t1 : t2
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    let ty1 = p1[0].value_type
    let ty2 = p2[0].value_type
    if ty1 != ty2 {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc check_is_var(expr: Expression): bool{
    if expr.expr_kind == ExpressionKind.ACCESS {
        return (expr as VarAccessExpression).value_id.kind == VarIdKind.VAR
    }
    return expr.expr_kind == ExpressionKind.MEMBER or expr.expr_kind == ExpressionKind.INDEX
}
fnc dump_type(ty: Type, force_bit_size = false): string {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if ty.kind == TypeKind.I4
        return "i4"
    if ty.kind == TypeKind.I8
        return "i8"
    if ty.kind == TypeKind.I16
        return "i16"
    if ty.kind == TypeKind.I32
        return "i32"
    if ty.kind == TypeKind.I64
        return "i64"
    if ty.kind == TypeKind.I128
        return "i128"
    if ty.kind == TypeKind.INT
        return force_bit_size ? "i"+$WORD_SIZE : "int"
    if ty.kind == TypeKind.F16
        return "f16"
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.FLOAT
        return force_bit_size ? "f"+$WORD_SIZE : "float"
    if ty.kind == TypeKind.VOID
        return "void"
    if ty.kind == TypeKind.FNC {
        let fnc_ty = ty as FunctionType
        let str = "("
        for let i = 0; i < fnc_ty.arg_types.length; ++i {
            str += dump_type(fnc_ty.arg_types[i]) + ","
        }
        str+=") => "+dump_type(fnc_ty.return_type)
        return str
    }
    if ty.kind == TypeKind.PTR
        return dump_type((ty as PointerType).pointee_type, force_bit_size)+"*"
    // if ty.kind == TypeKind.OBJECT
    //     return (ty as ObjectType).name
    if ty.kind == TypeKind.ARRAY {
        let arr_ty = ty as ArrayType
        return dump_type(arr_ty.element_type) + "[" + arr_ty.length + "]"
    }
    return "any"
}
fnc dump_bin_op(op: BinaryOp): string {
    if op == BinaryOp.ADD
        return "+"
    if op == BinaryOp.SUB
        return "-"
    if op == BinaryOp.MUL
        return "*"
    if op == BinaryOp.DIV
        return "/"
    if op == BinaryOp.MOD
        return "%"
    if op == BinaryOp.POW
        return "^"
    if op == BinaryOp.GT
        return ">"
    if op == BinaryOp.GTE
        return ">="
    if op == BinaryOp.LT
        return "<"
    if op == BinaryOp.LTE
        return "<="
    if op == BinaryOp.EEQ
        return "=="
    if op == BinaryOp.NEQ
        return "!"
    if op == BinaryOp.SL
        return "<<"
    if op == BinaryOp.SR
        return ">>"
    if op == BinaryOp.OR
        return "or"
    if op == BinaryOp.AND
        return "and"
    if op == BinaryOp.XOR
        return "xor"
    if op == BinaryOp.IN
        return "in"
    if op == BinaryOp.ASSIGN
        return "="
    return ".."
}
fnc dump_unary_op(op: UnaryOp): string{
    if op == UnaryOp.PREINCR
        return "++(pre)"
    if op == UnaryOp.PREDECR
        return "--(pre)"
    if op == UnaryOp.POSTINCR
        return "(post)++"
    if op == UnaryOp.POSTDECR
        return "(post)--"
    if op == UnaryOp.NEG
        return "-"
    if op == UnaryOp.NOT
        return "!"
    return "&"
}
class ScopeId {
    module_id: int
    id: int
    constructor(module_id: int, id: int){
        this.module_id = module_id
        this.id = id
    }
}
class Scope {
    id: ScopeId
    vars: Map<string, VarId>
    classes: Map<string, ClassId>
    functions: Map<string, VarId>
    enums: Map<string, EnumId>
    parent: ScopeId
    type_aliases: Map<string, Type>
    constructor(module_id: int, id: int){
        this.id = new ScopeId(module_id, id)
        this.vars = new Map<string, VarId>()
        this.classes = new Map<string, ClassId>()
        this.functions = new Map<string, VarId>()
        this.enums = new Map<string, EnumId>()
        this.type_aliases = new Map<string, Type>()
        this.parent = null 
    }
}
class FunctionArg(Expression) {
    id: VarId
    name: string
    default: Expression
    constructor(){
        super(ExpressionKind.ACCESS)
    }
}
class Function (Value) {
    id: VarId
    name: string
    args: FunctionArg[]
    block: Block
    scope: ScopeId
    is_external: bool
}
class Var (Value) {
    var_id: VarId
    value: Expression
    constructor(value: Expression, value_type: Type){
        this.value = value
        this.value_type = value_type
    }
}
class Const (Value) {
    const_id: ConstId
    value: Expression
    constructor(value: Expression){
        this.value = value
        this.value_type = value.value_type
    }
}
$ACCESS_PUBLIC = 1
$ACCESS_PRIVATE = 2
$ACCESS_STATIC = 4

class ClassField {
    id: PropId
    access_attributes: int
    name: string
    field_type: Type
}
class ClassMethod {
    access_attributes: int
    id: PropId
    name: string
    args: FunctionArg []
    block: Block
    method_type: Type
    scope: ScopeId
}
class Class {
    id: ClassId
    name: string
    fields: ClassField[]
    methods: ClassMethod[]
    field_map: Map<string, PropId>
    method_map: Map<string, PropId>
}
class EnumField {
    name: string
    // value: Value
    constructor(name: string){
        this.name = name
    }
}
class Enum {
    id: EnumId
    name: string
    fields: EnumField[]
    constructor(){
        this.fields = []
    }
}
class Module {
    id: int
    name: string
    vars: Var[]
    consts: Const[]
    classes: Class[]
    functions: Function[]
    enums: Enum[]
    scopes: Scope[]
    global_consts: ConstDeclaration[]
    global_vars: VarDeclaration[]
    constructor(){
        this.functions = []
        this.vars = []
        this.classes = []
        this.functions = []
        this.enums = []
        this.scopes = []
        this.global_consts = []
        this.global_vars = []
        this.consts = []
    }
}
class Program {
    modules: Module[]
    constructor(){
        this.modules = []
    }
}
fnc get_var(program: Program, var_id: VarId): Var {
    return program.modules[var_id.module_id].vars[var_id.id]
}
fnc get_const(program: Program, const_id: ConstId): Const {
    return program.modules[const_id.module_id].consts[const_id.id]
}
fnc get_func(program: Program, func_id: VarId): Function {
    return program.modules[func_id.module_id].functions[func_id.id]
}
fnc evaluate_const_int_expression(program: Program, exp: Expression): int {
    if exp.expr_kind == ExpressionKind.INT
        return (exp as IntExpression).value
    if exp.expr_kind == ExpressionKind.FLOAT
        return (exp as FloatExpression).value as int
    if exp.expr_kind == ExpressionKind.BIN {
        let bin_exp = exp as BinaryExpression
        if bin_exp.op == BinaryOp.ADD
            return evaluate_const_int_expression(program, bin_exp.lhs) + evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SUB
            return evaluate_const_int_expression(program, bin_exp.lhs) - evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MUL
            return evaluate_const_int_expression(program, bin_exp.lhs) * evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.DIV
            return evaluate_const_int_expression(program, bin_exp.lhs) / evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MOD
            return evaluate_const_int_expression(program, bin_exp.lhs) % evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SL
            return evaluate_const_int_expression(program, bin_exp.lhs) << evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SR
            return evaluate_const_int_expression(program, bin_exp.lhs) >> evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.OR
            return evaluate_const_int_expression(program, bin_exp.lhs) or evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.AND
            return evaluate_const_int_expression(program, bin_exp.lhs) and evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.XOR
            return evaluate_const_int_expression(program, bin_exp.lhs) xor evaluate_const_int_expression(program, bin_exp.rhs)
    }
    if exp.expr_kind == ExpressionKind.UNARY {
        let unary_exp = exp as UnaryExpression
        if unary_exp.op == UnaryOp.NEG
            return -evaluate_const_int_expression(program, unary_exp.expression)
        if unary_exp.op == UnaryOp.NOT
            return !evaluate_const_int_expression(program, unary_exp.expression)
    }
    if exp.expr_kind == ExpressionKind.ACCESS {
        let var_exp = exp as VarAccessExpression
        return evaluate_const_int_expression(program, get_const(program, var_exp.value_id as ConstId).value)
    }
    return -99999999
}
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    program: Program
    current_module: int
    current_class: ClassId
    current_function: VarId
    current_scope: ScopeId
    filename: string
    errors: FloError []
    in_loop: bool
    constructor(){
        this.current_module = -1
        this.in_loop = false
        this.program = new Program()
    }
    get_scope(scope_id: ScopeId): Scope {
       return this.program.modules[scope_id.module_id].scopes[scope_id.id]
    }
    get_current_module(): Module {
        return this.program.modules[this.current_module]
    }
    get_class_from_id(class_id: ClassId): Class{
        return this.program.modules[class_id.module_id].classes[class_id.id]
    }
    get_current_scope(): Scope {
        return this.get_scope(this.current_scope)
    }
    get_current_function(): Function {
        return this.get_current_module().functions[this.current_function.id]
    }
    create_scope(): Scope {
        let module = this.get_current_module()
        let scope = new Scope(this.current_module, module.scopes.length)
        module.scopes << scope
        return scope
    }
    is_constant_in_scope(name: string): bool {
        let is_constant = false
        let var_id = this.get_var_from_current_scope(name)
        if var_id != null { 
            is_constant = var_id.kind == VarIdKind.CONST
        }
        return is_constant
    }
    get_var_from_current_scope(name: string): VarId {
        let current_scope = this.get_current_scope()
        let value = current_scope.vars.get(name)
        while current_scope.parent != null and value == null {
            current_scope = this.get_scope(current_scope.parent)
            value = current_scope.vars.get(name)
            if value == null
                value = current_scope.functions.get(name)
        }
        return value
    }
    get_type_from_current_scope(name: string): Type {
        let current_scope = this.get_current_scope()
        let found_type = $UNKNOWN_TYPE
        while true {
            let aliased_ty = current_scope.type_aliases.get(name)
            if aliased_ty != null {
                found_type = aliased_ty
                break
            }
            let class_id = current_scope.classes.get(name)
            if class_id != null {
                found_type = new ObjectType(class_id)
                break
            }
            let enum_id = current_scope.enums.get(name)
            if enum_id != null {
                found_type = new EnumType(enum_id)
                break
            }
            if (current_scope.parent == null) break
            current_scope = this.get_scope(current_scope.parent)
        }
        return found_type
    }
    create_child_scope_within_current_scope(): Scope {
        let new_scope = this.create_scope()
        new_scope.parent = this.current_scope
        return new_scope
    } 
    error(kind: ErrorKind, message: string, range: FloRange){
        this.errors << new FloError(kind, message, range)
    }
    has_errored(): bool {
        return this.errors.length > 0
    }
    check(module_ast: ModuleAST, filename: string, errors: FloError[]): Program {
        this.current_module++
        this.filename = filename
        this.errors = errors
        let module = new Module()
        module.name = filename
        this.program.modules << module
        let module_scope = this.create_scope()
        let const_id = new ConstId(-1, -1)
        module_scope.vars.set("true", const_id)
        module_scope.vars.set("false", const_id)
        module_scope.vars.set("null", const_id)
        this.current_scope = module_scope.id
        
        // We declare module structures
        for let i = 0; i < module_ast.enums.length; i++ {
            this.declare_enum_within_current_scope(module_ast.enums[i])
        }
        for i = 0; i < module_ast.classes.length; i++ {
            this.declare_class_within_current_scope(module_ast.classes[i])
        }
        for i = 0; i < module_ast.type_aliases.length; i++  {
            let type_alias_node = module_ast.type_aliases[i]
            let ty = this.check_type(type_alias_node.parsed_type)
            let identifer_tok = type_alias_node.name
            let alias_name = identifer_tok.value
            if this.get_type_from_current_scope(alias_name).kind != TypeKind.UNKNOWN {
                this.error(ErrorKind.NAME, "Name '"+alias_name+"' has already been used for another type. consider renaming", type_alias_node.name.range)
                return null
            }
            module_scope.type_aliases.set(alias_name, ty)
        }
        for i = 0; i < module_ast.consts.length; i++ {
            this.declare_global_const(module_ast.consts[i])
        }
        for i = 0; i < module_ast.vars.length; i++ {
            this.declare_global_var(module_ast.vars[i])
        }
        for i = 0; i < module_ast.functions.length; i++ {
            this.declare_function_within_current_scope(module_ast.functions[i])
        }
        
        // We Now check bodies
        for i = 0; i < module_ast.classes.length; i++ {
            this.check_class_body(module.classes[i], module_ast.classes[i])
        }
        for i = 0; i < module_ast.enums.length; i++ {
            this.check_enum_body(module.enums[i], module_ast.enums[i])
        }
        for i = 0; i < module_ast.functions.length; i++ {
           this.check_function_body(module.functions[i], module_ast.functions[i])
        }
        return this.program
    }
    declare_var_within_current_scope(name: string, value: Expression, value_type: Type): Var {
        let var = new Var(value, value_type)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let id = new VarId(VarIdKind.VAR, this.current_module, current_module.vars.length)
        var.var_id = id
        current_module.vars << var
        current_scope.vars.set(name, id)
        return var
    }
    declare_const_within_current_scope(name: string, value: Expression): Const {
        let constant = new Const(value)
        let current_module = this.get_current_module()
        let current_scope = this.get_current_scope()
        let id = new ConstId(this.current_module, current_module.consts.length)
        constant.const_id = id
        current_module.consts << constant
        current_scope.vars.set(name, id)
        return constant
    }
    declare_global_const(const_decl_node: ConstDeclarationStatement){
        let const_stmt = this.check_const_declaration(const_decl_node)
        const_stmt.is_static = true
        this.get_current_module().global_consts << const_stmt
    }
    declare_global_var(var_decl_node: VarDeclarationStatement){
        let var_stmt = this.check_var_declaration(var_decl_node)
        if !get_var(this.program, var_stmt.var_id).value.is_constant {
            this.error(ErrorKind.GEN, "Initilializer for global variable has to be a constant", var_decl_node.value.range)
            return
        }
        var_stmt.is_static = true
        this.get_current_module().global_vars << var_stmt
    }
    init_function_signature(arg_nodes: ArgNode[], return_type_node: TypeNode, args: FunctionArg[]): Type {
        let arg_types: Type[] = []
        for let i = 0; i < arg_nodes.length; ++i {
            let arg = arg_nodes[i]
            let fnc_arg = new FunctionArg()
            fnc_arg.name = arg.name.value
            fnc_arg.default = null
            let arg_type = $UNKNOWN_TYPE
            if arg.parsed_type != null
                arg_type = this.check_type(arg.parsed_type)
            if arg.default != null
                fnc_arg.default = this.check_expression(arg_type, arg.default)
                if !arg.parsed_type != null
                    arg_type = fnc_arg.default.value_type
            args << fnc_arg
            fnc_arg.value_type = arg_type
            let var = this.declare_var_within_current_scope(fnc_arg.name, fnc_arg, arg_type)
            fnc_arg.id = var.var_id
            arg_types << arg_type
        }
        let ret_type = this.check_type(return_type_node)
        return new FunctionType(arg_types, ret_type)
    }
    declare_enum_within_current_scope(enum_node: EnumNode){
        let declared_enum = new Enum()
        let name = enum_node.name.value
        declared_enum.name = name
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Name '"+name+"' has already been used for another type. consider renaming", enum_node.name.range)
            return
        }
        declared_enum.id = new EnumId(this.current_module, this.get_current_module().enums.length)
        this.get_current_module().enums << declared_enum
        this.get_current_scope().enums.set(declared_enum.name, declared_enum.id)
    }
    declare_class_within_current_scope(class_decl_node: ClassDeclarationNode) {
        // TODO: Inheritance...
        let name = class_decl_node.name.value
        if this.get_type_from_current_scope(name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Name '"+name+"' has already been used for another type. consider renaming", class_decl_node.name.range)
            return
        }
        let declared_class = new Class()
        declared_class.fields = []
        declared_class.methods = []
        declared_class.field_map = new Map<string, PropId>()
        declared_class.name = name
        declared_class.id = new ClassId(this.current_module, this.get_current_module().classes.length)
        this.get_current_module().classes << declared_class
        this.get_current_scope().classes.set(declared_class.name, declared_class.id)
    }
    declare_function_within_current_scope(function_node: FunctionDeclarationNode) {
        let declared_function = new Function()
        declared_function.is_external = function_node.is_external
        let name = function_node.name.value
        declared_function.name = name
        if this.is_constant_in_scope(name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '"+name+"'", function_node.name.range)
            return
        }
        let fnc_scope = this.create_child_scope_within_current_scope()
        this.current_scope = fnc_scope.id 
        declared_function.args = []
        declared_function.value_type = this.init_function_signature(function_node.args, function_node.return_type, declared_function.args)
        declared_function.id = new VarId(VarIdKind.FNC, this.current_module, this.get_current_module().functions.length)
        this.current_scope = fnc_scope.parent
        declared_function.scope = fnc_scope.id
        this.get_current_module().functions << declared_function
        this.get_current_scope().functions.set(declared_function.name, declared_function.id)
    }
    check_enum_body(declared_enum: Enum, enum_node: EnumNode){
        for let i = 0; i < enum_node.fields.length; ++i {
            let enum_node_f = enum_node.fields[i]
            declared_enum.fields << new EnumField(enum_node_f.name.value)
        }
    }
    check_class_body(declared_class: Class, class_node: ClassDeclarationNode){
        //TODO: Inheritance
        //Generics
        for let i = 0; i < class_node.generic_parameters.length; ++i {
            let generic_param = class_node.generic_parameters[i]
        }
        // Fields
        for i = 0; i < class_node.fields.length; ++i {
            let field = new ClassField()
            let current_f_node = class_node.fields[i]
            field.id = new PropId(PropIdKind.FIELD, declared_class.id, i)
            field.name = current_f_node.name.value
            field.field_type = this.check_type(current_f_node.parsed_type)
            declared_class.fields << field
            declared_class.field_map.set(field.name, field.id)
        }
        // Methods
        for i = 0; i < class_node.methods.length; ++i {
            let method = new ClassMethod()
            let func_node = class_node.methods[i]
            let name = func_node.name.value
            if declared_class.method_map.get(name) != null {
                this.error(ErrorKind.NAME, "Method '"+ name +"' is already declared on class '"+declared_class.name+"'", func_node.name.range)
                return
            }
            method.name = name
            let method_scope = this.create_child_scope_within_current_scope()
            this.current_scope = method_scope.id
            method.args = []
            method.method_type = this.init_function_signature(func_node.args, func_node.return_type, method.args)
            method.id = new PropId(PropIdKind.METHOD, declared_class.id, i)
            method.scope = method_scope.id
            declared_class.methods << method
            declared_class.method_map.set(method.name, method.id)
            if !func_node.is_external
                method.block = this.check_block(func_node.block)
            this.current_scope = method_scope.parent
        }
    }
    check_function_body(func: Function, func_node: FunctionDeclarationNode) {
        if func.is_external { 
            return
        }
        this.current_function = func.id
        this.current_scope = func.scope
        func.block = this.check_block(func_node.block)
        if this.has_errored() {
            return
        }
        if !func.block.returns {
            if (func.value_type as FunctionType).return_type.kind == TypeKind.VOID {
                func.block.statements << (new ReturnStatement() as Statement)
            } else {
                this.error(ErrorKind.GEN, "Function missing ending return statement", func_node.return_type.range)
                return
            }
        }
        this.current_scope = this.get_scope(func.scope).parent
    }
    check_type(type_node: TypeNode): Type {
        if type_node.kind == TypeKind.BOOL
            return new Type(TypeKind.BOOL)
        if type_node.kind >= TypeKind.I4 and type_node.kind <= TypeKind.FLOAT
            return new Type(type_node.kind)
        if type_node.kind == TypeKind.VOID
            return new Type(TypeKind.VOID)
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY {
            let array_node = type_node as ArrayTypeNode
            let len_expr = this.check_expression(new Type(TypeKind.INT), array_node.length)
            if !is_int(len_expr.value_type) {
                this.error(ErrorKind.GEN, "length is an int", array_node.length.range)
                return null
            }
            if !len_expr.is_constant {
                this.error(ErrorKind.GEN, "length is a non-constant value", array_node.length.range)
                return null
            }
            let length = evaluate_const_int_expression(this.program, len_expr)
            if length < 0 {
                this.error(ErrorKind.GEN, "length should be greater than 0", array_node.length.range)
                return null
            }
            let element_type = this.check_type(array_node.element_type)
            return new ArrayType(element_type, length)
        }
        if type_node.kind == TypeKind.FNC {
            let fnc_node = type_node as FunctionTypeNode
            let arg_types: Type[] = []
            for let i = 0; i < fnc_node.args.length; i++ 
                arg_types << this.check_type(fnc_node.args[i])
            let return_type = this.check_type(fnc_node.return_type)
            return new FunctionType(arg_types, return_type)
        }
        if type_node.kind == TypeKind.RECORD {
            let record_type = type_node as RecordTypeNode
            let identifer_tok = record_type.name
            let found_type = this.get_type_from_current_scope(identifer_tok.value)
            if found_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Undefined type '"+identifer_tok.value+"'", identifer_tok.range)
                return null
            }
            return found_type
        }
        return $UNKNOWN_TYPE
    }
    check_array_expression(expected_type: Type, array_node: ArrayExpressionNode): ArrayExpression {
        if this.has_errored() return null
        //TODO: ARRAY is overloaded; Could be object or const so need to check which one it is.
        let elements: Expression[] = []
        let element_type = $UNKNOWN_TYPE
        let array_type = expected_type
        let is_constant = true
        if expected_type.kind == TypeKind.ARRAY {
            element_type = (expected_type as ArrayType).element_type
        }
        if array_node.elements.length > 0 {
            elements << this.check_expression(element_type, array_node.elements[0])
            if this.has_errored() return null
            if element_type.kind == TypeKind.UNKNOWN {
                is_constant = is_constant and elements[0].is_constant
                element_type =  elements[0].value_type
            }
            for let i = 1; i < array_node.elements.length; ++i {
                let element = this.check_expression(element_type, array_node.elements[i])
                if this.has_errored() return null
                is_constant = is_constant and element.is_constant
                if element.value_type == element_type {
                    elements << element
                } else {
                    this.error(ErrorKind.TYPE, "Expected element type of '"+dump_type(element_type)+"' but got type '"+dump_type(element.value_type)+"'", array_node.elements[i].range)
                    return null
                }
            }
        } 
        if array_type.kind == TypeKind.ARRAY {
            array_type = new ArrayType(element_type, elements.length)
        }
        let arr_exp = new ArrayExpression(elements)
        arr_exp.is_constant = is_constant
        arr_exp.value_type = array_type
        return arr_exp
    }
    check_var_access_expr(expected_type: Type, var_access_node: VarAccessExpressionNode): Expression {
        let name = var_access_node.name.value
        if name == "true" 
            return new BooleanExpression(1) 
        if name == "false" 
            return new BooleanExpression(0)
        if name == "null"
            return new NullExpression(expected_type)
        let current_scope = this.get_current_scope()
        let resolved = this.get_var_from_current_scope(name)
        let var_ty = $UNKNOWN_TYPE
        if resolved != null {
            let var_id = resolved
            if var_id.kind == VarIdKind.FNC
                var_ty = get_func(this.program, var_id).value_type
            else if var_id.kind == VarIdKind.VAR
                var_ty = get_var(this.program, var_id).value_type
            else if var_id.kind == VarIdKind.CONST
                var_ty = get_const(this.program, var_id as ConstId).value_type
            return new VarAccessExpression(var_id, var_ty)
        }
        this.error(ErrorKind.NAME, "Undefined variable '" + name + "'", var_access_node.range)
        return null
    }
    check_assignment(left: Expression, right: Expression, binary_node: BinaryExpressionNode): BinaryExpression {
        if !check_is_var(left) {
            this.error(ErrorKind.TYPE, "Cannot assign a value to a constant", binary_node.range)
            return null
        }
        if left.value_type != right.value_type {
            this.error(ErrorKind.TYPE, "Illegal assignment of variable of type '"+dump_type(right.value_type)+"' to '"+dump_type(left.value_type)+"'", binary_node.range)
            return null
        }
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type)
    }
    check_bin_expr(expected_type: Type, binary_node: BinaryExpressionNode): BinaryExpression {
        let left = this.check_expression(expected_type, binary_node.lhs)
        if this.has_errored() return null
        let right = this.check_expression(left.value_type, binary_node.rhs)
        if this.has_errored() return null
        let op = binary_node.op
        let is_const = left.is_constant and right.is_constant
        if op == BinaryOp.ASSIGN
            return this.check_assignment(left, right, binary_node)
        if left.value_type.kind == TypeKind.UNKNOWN and right.value_type.kind != TypeKind.UNKNOWN
            left.value_type = right.value_type
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                if is_int(right.value_type)
                    right = cast_exp_to_type(right, new Type(TypeKind.FLOAT)) // Might need to cast it to the biggest available
                return new BinaryExpression(left, op, right, left.value_type)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                check_cast_lower_bits(&left, &right)
                let exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = new BooleanType()
                
                return new BinaryExpression(left, op, right, exp_type, is_const)
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, new Type(TypeKind.INT)) // Might need to cast it to the biggest available
                }
                return new BinaryExpression(left, op, right, left.value_type, is_const)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type, is_const)
        }
        if op >= BinaryOp.GT and op <= BinaryOp.NEQ
            return new BinaryExpression(left, op, right, new BooleanType(), is_const)
        //TODO: Handle Range, In and Object Arithmetic and bit Cases.
        this.error(ErrorKind.TYPE, "Illegal binary operation '"+dump_bin_op(op)+"' between types '"+dump_type(left.value_type)+"' and '"+dump_type(right.value_type)+"'", binary_node.range)
        return null
    }
    check_unary_expr(expected_type: Type, unary_node: UnaryExpressionNode): UnaryExpression {
        let op = unary_node.op
        let expression = this.check_expression(expected_type, unary_node.expression)
        if this.has_errored() return null
        let ty = expression.value_type
        let is_const = expression.is_constant
        if op == UnaryOp.NEG {
            if is_numeric(ty)
                return new UnaryExpression(op, expression, ty, is_const)
        }
        if op == UnaryOp.NOT {
            if is_bool(ty) or is_numeric(ty)
                return new UnaryExpression(op, expression, ty, is_const)
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR {
            if is_numeric(ty) or is_pointer(ty) {
                if !check_is_var(expression) {
                    this.error(ErrorKind.GEN, "Illegal unary operation " + dump_unary_op(op) + " on constant", unary_node.expression.range)
                    return null
                }
                return new UnaryExpression(op, expression, ty)
            }
        }
        if op == UnaryOp.ADDROF {
            if check_is_var(expression)
                return new UnaryExpression(op, expression, new PointerType(expression.value_type))
        }
        this.error(ErrorKind.TYPE, "Illegal unary operation " + dump_unary_op(op) + " on type " + "'" + dump_type(ty) +"'", unary_node.range)
        return null
    }
    check_type_expr(type_expr_node: TypeExpressionNode): TypeExpression {
        //TODO: Need to check if cast is compatible for typecase & IS
        let exp = this.check_expression($UNKNOWN_TYPE, type_expr_node.expression)
        let ty = this.check_type(type_expr_node.bound_type)
        return new TypeExpression(exp, type_expr_node.op, ty)
    }
    check_new_expr(new_expr_node: NewExpressionNode): NewExpression {
        let expr_ty = this.check_type(new_expr_node.parsed_type)
        //TODO: Check constructor for classes
        return new NewExpression(expr_ty)
    }   
    check_member_expr(expected_type: Type, member_expr_node: MemberExpressionNode): MemberExpression {
        // TODO: Think about static member checks like enums/ static class attributes
        let prop_owner = this.check_expression($UNKNOWN_TYPE, member_expr_node.expression)
        if this.has_errored() return null
        let prop_owner_type = prop_owner.value_type
        let prop_name = member_expr_node.member.value
        let prop_id: PropId = null
        let prop_ty = $UNKNOWN_TYPE
        if prop_owner_type.kind == TypeKind.OBJECT {
            let parent_class = this.get_class_from_id((prop_owner_type as ObjectType).class_id)
            prop_id = parent_class.field_map.get(prop_name)
            if prop_id != null {
                //TODO: check field access
                let field = parent_class.fields[prop_id.id]
                prop_ty = field.field_type
            } else {
                prop_id = parent_class.field_map.get(prop_name)
                if prop_id != null {
                    let method = parent_class.methods[prop_id.id]
                    prop_ty = method.method_type
                }
            }
            if prop_ty.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.NAME, "Property '"+prop_name+"' doesn't exist in object '"+parent_class.name+"'", member_expr_node.member.range)
                return null
            }
        } else {
            this.error(ErrorKind.GEN, "Cannot get property of type '"+dump_type(prop_owner_type)+"'", member_expr_node.expression.range)
            return null
        }
        return new MemberExpression(prop_owner, prop_id, prop_ty)
    }
    check_ternary_expr(expected_type: Type, ternary_expr_node: TernaryExpressionNode): TernaryExpression {
        let cond = this.check_condition(ternary_expr_node.cond)
        if this.has_errored() return null
        let is_true = this.check_expression(expected_type, ternary_expr_node.is_true)
        if this.has_errored() return null
        let is_true_ty = is_true.value_type
        let is_false = this.check_expression(is_true_ty, ternary_expr_node.is_false)
        if this.has_errored() return null
        let is_false_ty = is_false.value_type
        if is_true_ty != is_false_ty {
            this.error(ErrorKind.TYPE, "Expected type '"+dump_type(is_true_ty)+"' from first case but got type '"+dump_type(is_false_ty) + "'", ternary_expr_node.range)
            return null
        }
        return new TernaryExpression(cond, is_true, is_false)
    }
    check_index_expr(expected_type: Type, index_expr_node: ExpressionIndexNode): IndexExpression {
        let root_expression = this.check_expression($UNKNOWN_TYPE, index_expr_node.expression)
        let index = this.check_expression(new Type(TypeKind.INT), index_expr_node.index)
        if this.has_errored() return null
        if !is_int(index.value_type) {
            this.error(ErrorKind.TYPE, "Expected an integer type for index", index_expr_node.index.range)
            return null
        }
        let value_type = $UNKNOWN_TYPE
        let root_type = root_expression.value_type
        if root_type.kind == TypeKind.PTR {
            value_type = (root_type as PointerType).pointee_type
        } else if root_type.kind == TypeKind.ARRAY {
            value_type = (root_type as ArrayType).element_type
        } else {
            this.error(ErrorKind.TYPE, "Cannot index into a value of type '"+dump_type(root_type)+"'", index_expr_node.range)
            return null
        }
        return new IndexExpression(root_expression, index, value_type)
    }
    fill_in_call_args(called: Expression, args: ExpressionNode[]): Expression[]{
        let func_args: FunctionArg [] = null
        let called_args: Expression[] = []
        let fnc_ty = called.value_type as FunctionType
        if called.expr_kind == ExpressionKind.ACCESS {
            let var_id = (called as VarAccessExpression).value_id
            if var_id.kind == VarIdKind.FNC
                func_args = get_func(this.program, var_id).args
        } else if called.expr_kind == ExpressionKind.MEMBER {
            let method_id = (called as MemberExpression).member_id
            let type_id = method_id.type_id
            if type_id.kind == TypeIdKind.CLASS {
                let owner_class = this.get_class_from_id(type_id as ClassId)
                func_args = owner_class.methods[method_id.id].args
            }
        } else {
            println("Case not handled; fill_in_call_args")
            exit()
        }

        for let i = 0; i < args.length; i++ {
            called_args << this.check_expression(fnc_ty.arg_types[i], args[i])
        }
        if this.has_errored() or func_args == null return called_args
        if func_args.length > args.length {
            for i = args.length; i < func_args.length; ++i {
                let arg = func_args[i]
                if arg.default != null
                    called_args << arg.default
            }
        }
        return called_args
    }
    check_call_expr(expected_type: Type,call_expr_node: CallExpressionNode): CallExpression {
        let called = this.check_expression($UNKNOWN_TYPE, call_expr_node.callee)
        if this.has_errored() return null
        if called.value_type.kind != TypeKind.FNC {
            this.error(ErrorKind.TYPE, "Expected a function type for call but got '"+dump_type(called.value_type)+"'", call_expr_node.callee.range)
            return null
        }
        //TODO: Check for generic functions.
        let func_ty = called.value_type as FunctionType
        let args = this.fill_in_call_args(called, call_expr_node.args)
        if this.has_errored() return null
        if func_ty.arg_types.length != args.length {
            this.error(ErrorKind.GEN, "Expected "+func_ty.arg_types.length+" arguments on function call but got "+args.length, call_expr_node.range)
            return null
        }
        for let i = 0; i < args.length; ++i {
            if args[i].value_type != func_ty.arg_types[i] {
                this.error(ErrorKind.TYPE, "Expected type '"+dump_type(func_ty.arg_types[i])+"' but got type '"+dump_type(args[i].value_type)+"' as function call argument", call_expr_node.args[i].range)
                return null
            }
        }
        return new CallExpression(called, args, func_ty.return_type)
    }
    check_int_expression(expected_type: Type, int_node: IntExpressionNode): IntExpression{
        let expr_value = new IntExpression(int_node.value.value)
        if is_int(expected_type)
            expr_value.value_type = expected_type
        return expr_value
    }
    check_float_expression(expected_type: Type, float_node: FloatExpressionNode): FloatExpression {
        let expr_value = new FloatExpression(float_node.value.value)
        if is_float(expected_type)
            expr_value.value_type = expected_type
        return expr_value
    }
    check_char_expression(char_node: CharExpressionNode): IntExpression {
        let expr_value = new IntExpression(char_node.value.value as int)
        expr_value.value_type.kind = TypeKind.I8
        return expr_value
    }
    check_string_expression(expected_type: Type, str_node: StringExpressionNode): StringExpression{
        let exp = new StringExpression(str_node.value.value)
        if is_i8_ptr(expected_type)
            exp.value_type = expected_type
        return exp
    }
    check_expression(expected_type: Type, expr_node: ExpressionNode): Expression {
        if expr_node.expr_kind == ExpressionKind.INT 
            return this.check_int_expression(expected_type, expr_node as IntExpressionNode)
        if expr_node.expr_kind == ExpressionKind.FLOAT
            return this.check_float_expression(expected_type, expr_node as FloatExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CHAR
            return this.check_char_expression(expr_node as CharExpressionNode)
        if expr_node.expr_kind == ExpressionKind.STRING 
            return this.check_string_expression(expected_type, expr_node as StringExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expected_type, expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ACCESS
            return this.check_var_access_expr(expected_type, expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expected_type, expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expected_type, expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TERNARY
            return this.check_ternary_expr(expected_type, expr_node as TernaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TYPEBOUND
            return this.check_type_expr(expr_node as TypeExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MEMBER
            return this.check_member_expr(expected_type, expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expected_type, expr_node as ExpressionIndexNode)
        /* if expr_node.expr_kind == ExpressionKind.CALL */
        return this.check_call_expr(expected_type, expr_node as CallExpressionNode)
    }
    check_condition(cond_node: ExpressionNode): Expression {
       let bool_type = new BooleanType()
       let condition = this.check_expression($UNKNOWN_TYPE, cond_node)
       if this.has_errored() return null
       return !is_bool(condition.value_type) ? cast_exp_to_type(condition, bool_type) : condition
    }
    check_if_stamement(if_stmt_node: IfStatementNode): IfStatement {
        let condition = this.check_condition(if_stmt_node.condition)
       // TODO: optionals.
        let block = this.check_block(if_stmt_node.block)
        let else_block: Block = if_stmt_node.else_block != null ? this.check_block(if_stmt_node.else_block) : null
        return new IfStatement(condition, block, else_block)
    }
    check_var_declaration(var_decl_node: VarDeclarationStatement): VarDeclaration {
        let name = var_decl_node.var_name.value
        if this.is_constant_in_scope(name){
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '"+name+"'", var_decl_node.var_name.range)
            return null
        }
        let current_scope = this.get_current_scope()
        let var_type = var_decl_node.var_type != null ? this.check_type(var_decl_node.var_type) : $UNKNOWN_TYPE
        if this.has_errored() return null
        if var_decl_node.value == null and var_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.GEN, "Variable '"+name+"' has no type", var_decl_node.var_name.range)
            return null
        }
        let value = var_decl_node.value != null ? this.check_expression(var_type, var_decl_node.value) : null
        if this.has_errored() return null
        if value != null {
            if is_null(value) and value.value_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", var_decl_node.range)
                return null
            }
            if var_type.kind != TypeKind.UNKNOWN and var_type != value.value_type {
                this.error(ErrorKind.TYPE, "Expected type '"+dump_type(var_type)+"' but got type '"+dump_type(value.value_type)+"' on variable declaration", var_decl_node.range)
                return null
            }
            if var_type.kind == TypeKind.UNKNOWN {
                var_type = value.value_type
            }
        }
        if current_scope.vars.get(name) != null {
            this.error(ErrorKind.NAME, "Illegal re-declaration of already declared variable '"+name+"'", var_decl_node.var_name.range)
            return null
        }
        let var = this.declare_var_within_current_scope(name, value, var_type)
        return new VarDeclaration(name, var.var_id)
    }
    check_const_declaration(const_decl_stmt: ConstDeclarationStatement): ConstDeclaration {
        let name = const_decl_stmt.const_name.value
        let current_scope = this.get_current_scope()
        if this.is_constant_in_scope(name) or current_scope.vars.get(name) != null {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '"+name+"'", const_decl_stmt.const_name.range)
            return null
        }
        let const_type = const_decl_stmt.const_type != null ? this.check_type(const_decl_stmt.const_type) : $UNKNOWN_TYPE
        if this.has_errored() return null
        let value = this.check_expression(const_type, const_decl_stmt.value)
        if this.has_errored() return null
        if !value.is_constant {
            this.error(ErrorKind.GEN, "cannot assign a non-constant value to a constant", const_decl_stmt.value.range)
            return null
        }
        if is_null(value) and value.value_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", const_decl_stmt.range)
            return null
        }
        if const_type.kind != TypeKind.UNKNOWN and const_type != value.value_type {
            this.error(ErrorKind.TYPE, "Expected type '"+dump_type(const_type)+"' but got type '"+dump_type(value.value_type)+"' on variable declaration", const_decl_stmt.range)
            return null
        }
         
        let constant = this.declare_const_within_current_scope(name, value)
        
        return new ConstDeclaration(name, constant.const_id)
    }
    check_for_statement(for_stmt_node: ForStatementNode): ForStatement {
        let for_stmt = new ForStatement()
        let prev_in_loop = this.in_loop
        if for_stmt_node.for_kind == ForKind.DEF {
            if for_stmt_node.initialization != null
                for_stmt.initialization = this.check_statement(for_stmt_node.initialization)
            if for_stmt_node.condition != null
                for_stmt.condition = this.check_condition(for_stmt_node.condition)
            if for_stmt_node.incr_decr != null
                for_stmt.incr_decr = this.check_expression($UNKNOWN_TYPE, for_stmt_node.incr_decr)
        }
        this.in_loop = true
        for_stmt.block = this.check_block(for_stmt_node.block)
        this.in_loop = prev_in_loop
        return for_stmt
    }
    check_while_statment(while_stmt_node: WhileStatementNode): WhileStatement {
        let condition = this.check_condition(while_stmt_node.condition)
        let prev_in_loop = this.in_loop
        this.in_loop = true
        let block = this.check_block(while_stmt_node.block)
        this.in_loop = prev_in_loop
        return new WhileStatement(condition, block)
    }
    check_can_break(stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal break outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.BREAK)
    }
    check_can_continue(stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal continue outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.CONTINUE)
    }
    check_can_return(return_stmt: ReturnStatementNode): ReturnStatement {
        let expr = return_stmt.value
        let current_function_return_type = (this.get_current_function().value_type as FunctionType).return_type
        let rt_stmt = new ReturnStatement()
        if expr != null {
            let rt_value = this.check_expression(current_function_return_type, expr)
            if this.has_errored() return null
            if rt_value.value_type != current_function_return_type {
                this.error(ErrorKind.TYPE, "Expected return type of "+dump_type(current_function_return_type)+ " but got return type of " + dump_type(rt_value.value_type), expr.range)
                return null
            }
            rt_stmt.return_value = rt_value
        } else {
            if current_function_return_type.kind != TypeKind.VOID {
                this.error(ErrorKind.TYPE, "function return type is not void", return_stmt.range)
                return null
            }
        }
        return rt_stmt
    }
    check_statement(stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.CONST
            return this.check_const_declaration(stmt_node as ConstDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue(stmt_node)
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break(stmt_node)
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode))
        if stmt_node.kind == StatementKind.EXPRESSION
            return this.check_expression($UNKNOWN_TYPE, stmt_node as ExpressionNode)
        return null
    }
    check_block(block_node: BlockNode): Block {
        if this.has_errored() return null
        let block = new Block()
        let new_scope = this.create_child_scope_within_current_scope()
        this.current_scope = new_scope.id
        for let i = 0; i < block_node.statements.length; i++ {
            let stmt = this.check_statement(block_node.statements[i])
            if this.has_errored() return null
            block.statements << stmt
            if stmt.kind == StatementKind.RETURN {
                block.returns = true
                break
            }
            if stmt.kind == StatementKind.IF {
                let if_stmt = stmt as IfStatement
                if if_stmt.else_block != null {
                    if if_stmt.block.returns and if_stmt.else_block.returns {
                        block.returns = true
                        break
                    }
                }
            }
            if stmt.kind == StatementKind.CONTINUE {
                block.continues = true
                break
            }
            if stmt.kind == StatementKind.BREAK {
                block.breaks = true
                break
            }
        }
        this.current_scope = new_scope.parent
        return block
    }
}