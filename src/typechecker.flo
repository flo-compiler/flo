import ARCH_WORD_SIZE in "@sys/lib"
import "@path/path"
import "types"
import Compiler in "compiler"
import panic, TextRange in "utils"
import FloError, ErrorKind in "error"
import Lexer, IdentifierToken in "lexer"
import "parser"
class Type {
    kind: TypeKind
    constructor(this, kind: TypeKind){
        this.kind = kind
    }
}
class IntType(Type){
    is_signed: bool
    constructor(this, ty: TypeKind, is_signed: bool){
        this.super(ty)
        this.is_signed = is_signed
    }
}
class PrimitiveTypes {
    unknown: Type = null
    bool: Type = null
    u4: Type = null
    u8: Type = null
    u16: Type = null
    u32: Type = null
    u64: Type = null
    u128: Type = null
    i4: Type = null
    i8: Type = null
    i16: Type = null
    i32: Type = null
    i64: Type = null
    i128: Type = null
    uint: Type = null
    int: Type = null
    f32: Type = null
    f64: Type = null
    void: Type = null
    init(){
        PrimitiveTypes.u4 = new IntType(TypeKind.I4, false)
        PrimitiveTypes.u8 = new IntType(TypeKind.I8, false)
        PrimitiveTypes.u16 = new IntType(TypeKind.I16, false)
        PrimitiveTypes.u32 = new IntType(TypeKind.I32, false)
        PrimitiveTypes.u64 = new IntType(TypeKind.I64, false)
        PrimitiveTypes.u128 = new IntType(TypeKind.I128, false)
        PrimitiveTypes.uint = new IntType(TypeKind.INT, false)
        PrimitiveTypes.i4 = new IntType(TypeKind.I4, true)
        PrimitiveTypes.i8 = new IntType(TypeKind.I8, true)
        PrimitiveTypes.i16 = new IntType(TypeKind.I16, true)
        PrimitiveTypes.i32 = new IntType(TypeKind.I32, true)
        PrimitiveTypes.i64 = new IntType(TypeKind.I64, true)
        PrimitiveTypes.i128 = new IntType(TypeKind.I128, true)
        PrimitiveTypes.int = new IntType(TypeKind.INT, true)
        PrimitiveTypes.bool = new Type(TypeKind.BOOL)
        PrimitiveTypes.f32 = new Type(TypeKind.F32)
        PrimitiveTypes.f64 = new Type(TypeKind.F64)
        PrimitiveTypes.void = new Type(TypeKind.VOID)
        PrimitiveTypes.unknown = new Type(TypeKind.UNKNOWN)
    }
}
class PointerType (Type) {
    pointee_type: Type
    constructor(this, pointee_type: Type){
        this.super(TypeKind.PTR)
        this.pointee_type = pointee_type
    }
}
class FunctionType (Type) {
    has_implicit_this: bool
    param_types: Type[]
    return_type: Type
    constructor(this, has_implicit_this: bool, param_types: Type[], return_type: Type){
        this.super(TypeKind.FNC)
        this.has_implicit_this = has_implicit_this
        this.param_types = param_types
        this.return_type = return_type
    }
}
class RecordType (Type) {
    element_names: String[]
    element_types: Type[]
    constructor(this){
        this.super(TypeKind.RECORD)
        this.element_names = []
        this.element_types = []
    }
}
enum TypeConstraints {
    Constant
    OpAnd
    OpOr
    OpNot
    OpNeg
    OpSum
    OpSub
    OpMul
    OpDiv
    OpEq
    OpGT
    OpGTE
    OpLT
    OpLTE
    OpSumEq
    OpSubEq
    OpMulEq
    OpDivEq
    Indexable
    IndexAssignable
    ArrayAccess
    Callable
    Iterable
}
class GenericTypeVariable (Type) {
    name: String
    definition_range: TextRange
    current_instance: Type
    constructor(this, name: String, definition_range: TextRange){
        this.super(TypeKind.GENERIC_VARIABLE)
        this.name = name
        this.definition_range = definition_range
    }
}
class Statement {
    kind: StatementKind
    constructor(this, kind: StatementKind){
        this.kind = kind
    }
}
class Expression (Statement) {
    is_constant: bool
    expr_kind: ExpressionKind
    value_type: Type
    range: TextRange
    constructor(this, expr_kind: ExpressionKind, value_type: Type, range: TextRange){
        this.super(StatementKind.EXPRESSION)
        this.expr_kind = expr_kind
        this.value_type = value_type
        this.range = range
        this.is_constant = false
    }
}
class ArrayType (Type) {
    element_type: Type
    length: uint
    constructor(this, element_type: Type, length: uint){
        this.super(TypeKind.ARRAY)
        this.element_type = element_type
        this.length = length
    }
}
class ResolvedGenericType(Type) {
    name: String
    arg_types: Type[]
    instantiated_type: Type
    constructor(this, name: String, arg_types: Type[], instantiated_type: Type){
        this.super(TypeKind.RESOLVED_GENERIC)
        this.name = name
        this.arg_types = arg_types
        this.instantiated_type = instantiated_type
    }
}
class ObjectType (Type) {
    class_id: ClassId
    constructor(this, class_id: ClassId){
        this.super(TypeKind.OBJECT)
        this.class_id = class_id
    }
}
class EnumType (Type) {
    enum_id: EnumId
    constructor(this, enum_id: EnumId){
        this.super(TypeKind.ENUM)
        this.enum_id = enum_id
    }
}
class IntExpression (Expression) {
    value: u64
    constructor(this, value: u64, range: TextRange){
        this.super(ExpressionKind.INT, PrimitiveTypes.uint, range)
        this.value = value
        this.is_constant = true
    }
}
class BooleanExpression (Expression) {
    value: bool 
    constructor(this, value: bool, range: TextRange){
        this.super(ExpressionKind.BOOL, PrimitiveTypes.bool, range)
        this.value = value
        this.is_constant = true
    }
}
class FloatExpression (Expression) {
    value: f64
    constructor(this, value: f64, range: TextRange){
        this.super(ExpressionKind.FLOAT, PrimitiveTypes.f64, range)
        this.value = value
        this.is_constant = true
    }
}
class StringExpression (Expression) {
    value: String
    fmt_indices: uint[]
    template_args: Expression[]
    constructor(this, value: String, fmt_indices: uint[], template_args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.STRING, value_type, range)
        this.template_args = template_args
        this.fmt_indices = fmt_indices
        this.value = value
        this.is_constant = true
    }
}
class NullExpression (Expression) {
    constructor(this, value_type: Type, range: TextRange){
        this.super(ExpressionKind.NULL, value_type, range)
        this.is_constant = true
    }
}
class ArrayExpression (Expression) {
    elements: Expression[]
    constructor(this, elements: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.ARRAY, value_type, range)
        this.elements = elements
    }
}
class RecordExpression (Expression) {
    elements: Expression[]
    constructor(this, elements: Expression[], value_type: RecordType, range: TextRange){
        this.super(ExpressionKind.RECORD, value_type, range)
        this.elements = elements
    }
}
class BinaryExpression (Expression) {
    lhs: Expression
    op: BinaryOp
    rhs: Expression
    constructor(this, lhs: Expression, op: BinaryOp, rhs: Expression, value_type: Type, range: TextRange, is_constant = false){
        this.super(ExpressionKind.BIN, value_type, range)
        this.lhs = lhs
        this.op = op
        this.rhs = rhs
        this.is_constant = is_constant
    }
}
class UnaryExpression (Expression) {
    op: UnaryOp
    expression: Expression
    constructor(this, op: UnaryOp, expression: Expression, value_type: Type, range: TextRange, is_constant = false){
        this.super(ExpressionKind.UNARY, value_type, range)
        this.op = op
        this.expression = expression
        this.is_constant = is_constant
    }
}
class TernaryExpression (Expression) {
    cond: Expression
    is_true: Expression
    is_false: Expression
    constructor(this, cond: Expression, is_true: Expression, is_false: Expression){
        this.super(ExpressionKind.TERNARY, is_true.value_type, TextRange.merge(cond.range, is_false.range))
        this.cond = cond
        this.is_true = is_true
        this.is_false = is_false
    }
}
class TypeCastExpression (Expression) {
    expr: Expression
    constructor(this, expr: Expression, value_type: Type, range: TextRange){
        this.super(ExpressionKind.CAST, value_type, range)
        this.expr = expr
        this.is_constant = expr.is_constant
    }
}
class NewExpression (Expression) {
    args: Expression[]
    onheap: bool
    memory_type: Type
    constructor(this, onheap: bool, memory_type: Type, args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.NEW, value_type, range)
        this.memory_type = memory_type
        this.onheap = onheap
        this.args = args
    }
}
class RangeExpression (Expression) {
    left: Expression
    right: Expression
    constructor(this, left: Expression, right: Expression, value_type: Type){
        this.super(ExpressionKind.RANGE, value_type, TextRange.merge(left.range, right.range))
        this.left = left
        this.right = right
    }
}
class IndexExpression (Expression) {
    expression: Expression
    index: Expression
    constructor(this, expression: Expression, index: Expression, value_type: Type, range: TextRange){
        this.super(ExpressionKind.INDEX, value_type, range)
        this.expression = expression
        this.index = index
        this.value_type = value_type
    }
}
class CallExpression (Expression) {
    callee: Expression
    args: Expression[]
    constructor(this, callee: Expression, args: Expression[], value_type: Type, range: TextRange){
        this.super(ExpressionKind.CALL, value_type, range)
        this.callee = callee
        this.args = args
    }
}
class IntrinsicCall (Expression) {
    intrinsic: Intrinsics
    args: Expression[]
    constructor(this, intrinsic: Intrinsics, return_type: Type, range: TextRange){
        this.super(ExpressionKind.INTRINSIC, return_type, range)
        this.intrinsic = intrinsic
        this.args = []
    }
}
class ScopeId {
    id: uint
    module_id: ModuleId
    constructor(this, module_id: ModuleId, id: uint){
        this.module_id = module_id
        this.id = id
    }
}
// class TypeId {
//     id: uint
//     module_id: ModuleId
//     constructor(this, module_id: ModuleId, id: uint){
//         this.module_id = module_id
//         this.id = id
//     }
// }
class ModuleId {
    id: uint
    constructor(this, id: uint){
        this.id = id
    }
}
class VarId {
    id: uint
    module_id: ModuleId
    constructor(this, module_id: ModuleId, id: uint){
        this.module_id = module_id
        this.id = id
    }
}
class FunctionId {
    id: uint
    constructor(this, id: uint){
        this.id = id
    }
}
class ClassId {
    id: uint
    constructor(this, id: uint){
        this.id = id
    }
    __eq__(this, other: ClassId): bool {
        return (this.id == other.id)
    }
}
class EnumId {
    id: uint
    constructor(this, id: uint){
        this.id = id
    }
    __eq__(this, other: EnumId): bool {
        return (this.id == other.id)
    }
}
class StaticFieldAccessExpression (Expression) {
    class_id: ClassId
    var_id: VarId
    constructor(this, class_id: ClassId, var_id: VarId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.STATIC_FIELD_ACCESS, value_type, range)
        this.class_id = class_id
        this.var_id = var_id
    }
}
class StaticMethodAccessExpression (Expression) {
    class_id: ClassId
    fnc_id: FunctionId
    constructor(this, class_id: ClassId, fnc_id: FunctionId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.STATIC_METHOD_ACCESS, value_type, range)
        this.class_id = class_id
        this.fnc_id = fnc_id
    }
}
class ClassFieldAccessExpression (Expression) {
    expression: Expression
    var_id: VarId
    constructor(this, expression: Expression, var_id: VarId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.CLASS_FIELD_ACCESS, value_type, range)
        this.expression = expression
        this.var_id = var_id
    }
}
class ClassMethodAccessExpression (Expression) {
    expression: Expression
    fnc_id: FunctionId
    constructor(this, expression: Expression, fnc_id: FunctionId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.CLASS_METHOD_ACCESS, value_type, range)
        this.expression = expression
        this.fnc_id = fnc_id
    }
}
class EnumFieldAccessExpression (Expression) {
    enum_id: EnumId
    var_id: VarId
    constructor(this, enum_id: EnumId, var_id: VarId, value_type: Type, range: TextRange){
        this.super(ExpressionKind.ENUM_FIELD_ACCESS, value_type, range)
        this.enum_id = enum_id
        this.var_id = var_id
    }
}
class RecordFieldAccessExpression (Expression) {
    expression: Expression
    field_index: uint
    constructor(this, expression: Expression, field_index: uint, value_type: Type, range: TextRange){
        this.super(ExpressionKind.RECORD_FIELD_ACCESS, value_type, range)
        this.expression = expression
        this.field_index = field_index
    }
}
class VarAccessExpression (Expression) {
    var_id: VarId
    constructor(this, var_id: VarId, value_type: Type, is_constant: bool, range: TextRange){
        this.super(ExpressionKind.VAR_ACCESS, value_type, range)
        this.var_id = var_id
        this.is_constant = is_constant
    }
}
class FncAccessExpression (Expression) {
    fnc_id: FunctionId
    constructor(this, fnc_id: FunctionId, fnc_type: Type, range: TextRange){
        this.super(ExpressionKind.FNC_ACCESS, fnc_type, range)
        this.fnc_id = fnc_id
        this.is_constant = true
    }
}
class Block {
    statements: Statement[]
    returns: bool /* Block contains a return */
    continues: bool /* Block contains a continue */
    breaks: bool /* Block contains a break */
    yields: Expression
    range: TextRange
    constructor(this, range: TextRange){
        this.range = range
        this.statements = []
        this.returns = false
        this.continues = false
        this.breaks = false
        this.yields = null
    }
    is_terminated(this): bool {
        return this.returns or this.continues or this.breaks
    }
}
class MatchExpressionCase {
    kind: MatchCaseKind
    condition: Expression
    block: Block
    constructor(this, kind: MatchCaseKind, condition: Expression, block: Block){
        this.kind = kind
        this.condition = condition
        this.block = block
    }
}
class MatchExpression(Expression){
    subject: Expression
    cases: MatchExpressionCase[]
    else_block: Block
    use_ifs: bool
    constructor(this, subject: Expression, use_ifs: bool){
        this.super(ExpressionKind.MATCH, PrimitiveTypes.void, subject.range) //TODO: Figure out if this is the best decision
        this.subject = subject
        this.use_ifs = use_ifs
        this.cases = []
        this.else_block = null
    }
}
class IfStatement (Statement) {
    condition: Expression
    block: Block
    else_block: Block
    constructor(this, condition: Expression, block: Block, else_block: Block){
        this.super(StatementKind.IF)
        this.condition = condition
        this.block = block
        this.else_block = else_block
    }
}
class VarDeclaration (Statement) {
    var: Var
    is_static: bool
    range: TextRange
    constructor(this, var: Var, range: TextRange){
        this.super(StatementKind.VAR)
        this.var = var
        this.range = range
        this.is_static = false
    }
}
class ForInStatement (Statement) {
    it_var: VarDeclaration
    iterator: Expression
    iterable_type: ObjectType
    block: Block
    constructor(this, it_var: VarDeclaration, iterator: Expression, iterable_type: ObjectType, block: Block){
        this.super(StatementKind.FOR_IN)
        this.it_var = it_var
        this.iterator = iterator
        this.iterable_type = iterable_type
        this.block = block
    }
}
class ForStatement (Statement) {
    initialization: Statement
    condition: Expression
    update: Expression
    block: Block
    constructor(this){
        this.super(StatementKind.FOR)
        this.initialization = null
        this.condition = null
        this.update = null
    }
}
class WhileStatement (Statement) {
    condition: Expression
    block: Block
    constructor(this, condition: Expression, block: Block){
        this.super(StatementKind.WHILE)
        this.condition = condition
        this.block = block
    }
}
class ReturnStatement (Statement) {
    return_value: Expression
    constructor(this){
        this.super(StatementKind.RETURN)
        this.return_value = null
    }
}
fnc is_numeric(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_numeric(generic_var_type.current_instance)
    }
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.F64
}
fnc is_float(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_float(generic_var_type.current_instance)
    }
    return val_ty.kind >= TypeKind.F32 and val_ty.kind <= TypeKind.F64
}
fnc is_int(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_int(generic_var_type.current_instance)
    }
    return val_ty.kind >= TypeKind.I4 and val_ty.kind <= TypeKind.I128
}
fnc is_bool(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_bool(generic_var_type.current_instance)
    }
    return val_ty.kind == TypeKind.BOOL
}
fnc is_void(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_void(generic_var_type.current_instance)
    }
    return val_ty.kind == TypeKind.VOID
}
fnc is_u8_ptr(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_u8_ptr(generic_var_type.current_instance)
    }
    if val_ty.kind == TypeKind.PTR {
        let pointee_type = (val_ty as PointerType).pointee_type
        if is_int(pointee_type) {
            return (pointee_type.kind == TypeKind.I8) and !((pointee_type as IntType).is_signed)
        }
    }
    return false
}
fnc is_object(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_object(generic_var_type.current_instance)
    }
    if (val_ty.kind == TypeKind.RESOLVED_GENERIC)
        return is_object((val_ty as ResolvedGenericType).instantiated_type)
    return val_ty.kind == TypeKind.OBJECT
}
fnc is_function(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_function(generic_var_type.current_instance)
    }
    return val_ty.kind == TypeKind.FNC
}
fnc is_pointer(val_ty: Type): bool {
    if (val_ty.kind == TypeKind.GENERIC_VARIABLE){
        let generic_var_type = (val_ty as GenericTypeVariable)
        if (generic_var_type.current_instance == null) return false
        return is_pointer(generic_var_type.current_instance)
    }
    return val_ty.kind == TypeKind.PTR
}
fnc is_null_expression(exp: Expression): bool {
    return exp.expr_kind == ExpressionKind.NULL
}
fnc cast_exp_to_type(exp: Expression, val_ty: Type): Expression {
    return new TypeCastExpression(exp, val_ty, exp.range)
}
fnc max_type(t1: Type, t2: Type): Type {
    return t1.kind > t2.kind ? t1 : t2
}
fnc get_unsigned_int_variant(type: Type): Type {
    if (type.kind == TypeKind.I4) return PrimitiveTypes.u4
    if (type.kind == TypeKind.I8) return PrimitiveTypes.u8
    if (type.kind == TypeKind.I16) return PrimitiveTypes.u16
    if (type.kind == TypeKind.I32) return PrimitiveTypes.u32
    if (type.kind == TypeKind.I64) return PrimitiveTypes.u64
    if (type.kind == TypeKind.INT) return PrimitiveTypes.uint
    else return PrimitiveTypes.u128
}
fnc get_signed_int_variant(type: Type): Type {
    if (type.kind == TypeKind.I4) return PrimitiveTypes.i4
    if (type.kind == TypeKind.I8) return PrimitiveTypes.i8
    if (type.kind == TypeKind.I16) return PrimitiveTypes.i16
    if (type.kind == TypeKind.I32) return PrimitiveTypes.i32
    if (type.kind == TypeKind.I64) return PrimitiveTypes.i64
    if (type.kind == TypeKind.INT) return PrimitiveTypes.int
    else return PrimitiveTypes.i128
}
fnc check_cast_lower_bits(p1: Expression*, p2: Expression*){
    let ty1 = p1[0].value_type
    let ty2 = p2[0].value_type
    if ty1.kind != ty2.kind {
        if is_float(ty1) and is_int(ty2) {
            p2[0] = cast_exp_to_type(p2[0], ty1)
        } else if is_int(ty1) and is_float(ty2){
            p1[0] = cast_exp_to_type(p1[0], ty2)
        } else {
            ty1 = max_type(ty1, ty2)
            if is_int(ty1) and is_int(ty2){
                if (ty1 as IntType).is_signed != (ty2 as IntType).is_signed {
                    ty1 = get_signed_int_variant(ty2)
                }
            }
            p1[0] = cast_exp_to_type(p1[0], ty1)
            p2[0] = cast_exp_to_type(p2[0], ty1)
        }
    }
}
fnc check_is_var(expr: Expression): bool{
    if expr.expr_kind == ExpressionKind.VAR_ACCESS {
        return !((expr as VarAccessExpression).is_constant)
    }
    if expr.expr_kind == ExpressionKind.CLASS_FIELD_ACCESS {
        return true
    }
    if expr.expr_kind == ExpressionKind.STATIC_FIELD_ACCESS {
        return true
    }
    if expr.expr_kind == ExpressionKind.RECORD_FIELD_ACCESS {
        return true
    }
    if expr.expr_kind == ExpressionKind.INDEX {
        return true
    }
    return false
}
fnc dump_type(ty: Type, force_bit_size = false): String {
    if ty.kind == TypeKind.BOOL
        return "bool"
    if is_int(ty){
        if force_bit_size return "i$ARCH_WORD_SIZE"
        let is_signed = (ty as IntType).is_signed
        if ty.kind == TypeKind.INT {
            return is_signed ? "int" : "uint"
        }
        let char = is_signed ? "i" : "u"
        if ty.kind == TypeKind.I4
            return "$(char)4" 
        if ty.kind == TypeKind.I8
            return "$(char)8"
        if ty.kind == TypeKind.I16
            return "$(char)16"
        if ty.kind == TypeKind.I32
            return "$(char)32"
        if ty.kind == TypeKind.I64
            return "$(char)64"
        if ty.kind == TypeKind.I128
            return "$(char)128"
    }
    if ty.kind == TypeKind.F32
        return "f32"
    if ty.kind == TypeKind.F64
        return "f64"
    if ty.kind == TypeKind.VOID
        return "void"
    if ty.kind == TypeKind.NAMED_RECORD
        return "record"
    return "unknown"
}
fnc dump_bin_op(op: BinaryOp): String {
    if op == BinaryOp.ADD
        return "+"
    if op == BinaryOp.SUB
        return "-"
    if op == BinaryOp.MUL
        return "*"
    if op == BinaryOp.DIV
        return "/"
    if op == BinaryOp.MOD
        return "**"
    if op == BinaryOp.POW
        return "^"
    if op == BinaryOp.GT
        return ">"
    if op == BinaryOp.GTE
        return ">="
    if op == BinaryOp.LT
        return "<"
    if op == BinaryOp.LTE
        return "<="
    if op == BinaryOp.EEQ
        return "=="
    if op == BinaryOp.NEQ
        return "!="
    if op == BinaryOp.SL
        return "<<"
    if op == BinaryOp.SR
        return ">>"
    if op == BinaryOp.OR
        return "or"
    if op == BinaryOp.AND
        return "and"
    if op == BinaryOp.XOR
        return "^"
    if op == BinaryOp.IN
        return "in"
    if op == BinaryOp.ASSIGN
        return "="
    return "<unknown>"
}
fnc dump_unary_op(op: UnaryOp): String{
    if op == UnaryOp.PREINCR
        return "++(pre)"
    if op == UnaryOp.PREDECR
        return "--(pre)"
    if op == UnaryOp.POSTINCR
        return "(post)++"
    if op == UnaryOp.POSTDECR
        return "(post)--"
    if op == UnaryOp.NEG
        return "-"
    if op == UnaryOp.NOT
        return "!"
    return "&"
}
fnc dump_access(visibility: AccessVisibility): String {
    if visibility == AccessVisibility.PRIVATE
        return "private"
    if visibility == AccessVisibility.PUBLIC
        return "public"
    return "protected"
}
fnc lower_bin_assign_node(binary_node: BinaryExpressionNode): BinaryExpressionNode {
    let op = binary_node.op
    if op == BinaryOp.ADD_ASSIGN
        op = BinaryOp.ADD
    if op == BinaryOp.SUB_ASSIGN
        op = BinaryOp.SUB
    if op == BinaryOp.MUL_ASSIGN
        op = BinaryOp.MUL
    if op == BinaryOp.DIV_ASSIGN
        op = BinaryOp.DIV
    if op == BinaryOp.MOD_ASSIGN
        op = BinaryOp.MOD
    if op == BinaryOp.POW_ASSIGN
        op = BinaryOp.POW
    if op == BinaryOp.AND_ASSIGN
        op = BinaryOp.AND
    if op == BinaryOp.OR_ASSIGN
        op = BinaryOp.OR
    if op == BinaryOp.SL_ASSIGN
        op = BinaryOp.SL
    if op == BinaryOp.SR_ASSIGN
        op = BinaryOp.SR
    return new BinaryExpressionNode(binary_node.lhs, op, binary_node.rhs)
}
class Scope {
    public id: ScopeId
    public modules: StringMap<ModuleId>
    public vars: StringMap<VarId>
    public classes: StringMap<ClassId>
    public functions: StringMap<FunctionId>
    public enums: StringMap<EnumId>
    public parent: ScopeId
    public types: StringMap<Type>
    public children: ScopeId[]
    constructor(this, module_id: ModuleId, id: uint){
        this.id = new ScopeId(module_id, id)
        this.modules = new StringMap<ModuleId>()
        this.vars = new StringMap<VarId>()
        this.classes = new StringMap<ClassId>()
        this.functions = new StringMap<FunctionId>()
        this.enums = new StringMap<EnumId>()
        this.types = new StringMap<Type>()
        this.parent = null 
        this.children = []
    }
    private __del__(this){
        del this.id
        del this.vars
        del this.classes
        del this.functions
        del this.enums
        del this.types
    }
}
class FunctionParam {
    var: Var
    range: TextRange
    constructor(this, var: Var, range: TextRange){
        this.var = var
        this.range = range
    }
}
class Function {
    id: FunctionId
    name: String
    params: FunctionParam[]
    block: Block
    fnc_type: FunctionType
    scope: ScopeId
    is_external: bool
    definition_range: TextRange
    class_id: ClassId
    visibility: AccessVisibility
    constructor(this, definition_range: TextRange){
        this.definition_range = definition_range
        this.is_external = false
        this.class_id = null
    }
}
class Var {
    id: VarId
    name: String
    value: Expression
    value_type: Type
    visibility: AccessVisibility
    is_constant: bool
    constructor(this, name: String, value: Expression, is_constant: bool, visibility: AccessVisibility, value_type: Type){
        this.name = name
        this.value = value
        this.is_constant = is_constant
        this.visibility = visibility
        this.value_type = value_type
    }
}

class Field {
    var: Var
    offset: uint
    definition_range: TextRange
    constructor(this, var: Var, offset: uint, definition_range: TextRange){
        this.var = var
        this.offset = offset
        this.definition_range = definition_range
    }
}
class Class {
    id: ClassId
    name: String
    parent: Type
    definition_range: TextRange
    fields: Field[]
    // scope: ScopeId
    props_scope: ScopeId
    static_props_scope: ScopeId
    constructor(this){
        this.fields = []
    }
}
class Enum {
    id: EnumId
    name: String
    fields: Field[]
    definition_range: TextRange
    variant_type: Type
    scope: ScopeId
    constructor(this){
        this.fields = []
    }
}

class Module {
    id: ModuleId
    name: String
    scope: ScopeId
    global_vars: VarDeclaration[]
    constructor(this, name: String){
        this.name = name
        this.global_vars = []
    }
    private __del__(this){
        for global_var in this.global_vars {
            del global_var
        }
        del this.name
        del this.global_vars
    }
}
class Program {
    modules: Module[]
    vars: Var[]
    classes: Class[]
    functions: Function[]
    enums: Enum[]
    scopes: Scope[]
    builtin_scope: ScopeId
    constructor(this){
        this.modules = []
        this.functions = []
        this.vars = []
        this.classes = []
        this.enums = []
        this.scopes = []
        this.builtin_scope = null
    }
    private __del__(this){
        for module in this.modules {
            del module
        }
        for func in this.functions {
            del func
        }
        for scope in this.scopes {
            del scope
        }
        for var in this.vars {
            del var
        }
        for checked_class in this.classes {
            del checked_class
        }
        for checked_enum in this.enums {
            del checked_enum
        }
        del this.functions
        del this.vars
        del this.classes
        del this.enums
        del this.scopes
        del this.modules
    }
    public get_module(this, module_id: ModuleId): Module {
        return this.modules[module_id.id]
    }
    public get_var(this, var_id: VarId): Var {
        return this.vars[var_id.id]
    }
    public get_func(this, func_id: FunctionId): Function {
        return this.functions[func_id.id]
    }
    public get_scope(this, scope_id: ScopeId): Scope {
        return this.scopes[scope_id.id]
    }
    public get_class(this, type_id: ClassId): Class {
        return this.classes[type_id.id]   
    }
    public get_enum(this, enum_id: EnumId): Enum {
        return this.enums[enum_id.id]
    }
    public get_class_id_from_type(this, type: Type): ClassId {
        if type.kind == TypeKind.RESOLVED_GENERIC
            return this.get_class_id_from_type((type as ResolvedGenericType).instantiated_type)
        if type.kind == TypeKind.OBJECT
            return (type as ObjectType).class_id
        return null
    }
    public get_class_from_type(this, type: Type): Class {
        let class_id = this.get_class_id_from_type(type)
        if class_id != null
            return this.get_class(class_id)
        return null
    }
    public get_enum_from_type(this, type: Type): Enum {
        if type.kind == TypeKind.ENUM
            return this.get_enum((type as EnumType).enum_id)
        return null
    }
    public is_buitin_class(this, type: Type, name: String): bool {
        if !is_object(type) return false
        let class_id = this.get_class_id_from_type(type)
        let scope = this.get_scope(this.builtin_scope)
        let eq_class_id = scope.classes[name]
        if (eq_class_id == null) return false
        return class_id == eq_class_id 
    }
}
fnc is_bin_op_comp_eq_op(op: BinaryOp): bool {
    if op == BinaryOp.EEQ
        return true
    if op == BinaryOp.NEQ
        return true
    return false
}
fnc is_bin_op_comp_op(op: BinaryOp): bool {
    if op == BinaryOp.GT
        return true
    if op == BinaryOp.LT
        return true
    if op == BinaryOp.GTE
        return true
    if op == BinaryOp.LTE
        return true
    return is_bin_op_comp_eq_op(op)
}
fnc is_operator_overload_name(name: String): bool {
    if name == "__eq__" return true
    if name == "__add__" return true
    if name == "__sub__" return true
    if name == "__mul__" return true
    if name == "__div__" return true
    if name == "__or__" return true
    if name == "__adda__" return true
    if name == "__suba__" return true
    if name == "__mula__" return true
    if name == "__diva__" return true
    if name == "__ora__" return true
    if name == "__anda__" return true
    if name == "__xora__" return true
    if name == "__getitem__" return true
    if name == "__setitem__" return true
    if name == "__sl__" return true
    if name == "__sr__" return true
    if name == "__sla__" return true
    if name == "__sra__" return true
    if name == "__in__" return true
    if name == "__lt__" return true
    if name == "__lg__" return true
    if name == "__ne__" return true
    if name == "__le__" return true
    if name == "__ge__" return true
    if name == "__pow__" return true
    if name == "__mod__" return true
    if name == "__powa__" return true
    if name == "__moda__" return true
    if name == "__iter__" return true
    if name == "__del__" return true
    return false
}
fnc bin_op_to_op_overload_name(op: BinaryOp): String {
    if op == BinaryOp.ADD return "__add__"
    if op == BinaryOp.SUB return "__sub__"
    if op == BinaryOp.MUL return "__mul__"
    if op == BinaryOp.DIV return "__div__"
    if op == BinaryOp.MOD return "__mod__"
    if op == BinaryOp.POW return "__pow__"
    if op == BinaryOp.ADD_ASSIGN return "__adda__"
    if op == BinaryOp.SUB_ASSIGN return "__suba__"
    if op == BinaryOp.MUL_ASSIGN return "__mula__"
    if op == BinaryOp.DIV_ASSIGN return "__diva__"
    if op == BinaryOp.MOD_ASSIGN return "__moda__"
    if op == BinaryOp.POW_ASSIGN return "__powa__"
    if op == BinaryOp.GT return "__gt__"
    if op == BinaryOp.GTE return "__ge__"
    if op == BinaryOp.LT return "__lt__"
    if op == BinaryOp.LTE return "__le__"
    if op == BinaryOp.EEQ return "__eq__"
    if op == BinaryOp.NEQ return "__ne__"
    if op == BinaryOp.SL return "__sl__"
    if op == BinaryOp.SR return "__sr__"
    if op == BinaryOp.SL_ASSIGN return "__sla__"
    if op == BinaryOp.SR_ASSIGN return "__sra__"
    if op == BinaryOp.OR return "__or__"
    if op == BinaryOp.AND return "__and__"
    if op == BinaryOp.XOR return "__xor__"
    if op == BinaryOp.AND_ASSIGN return "__anda__"
    if op == BinaryOp.XOR_ASSIGN return "__xora__"
    if op == BinaryOp.IN return "__in__"
    return null
}
fnc get_num_params_for_operator_overload(name: String): uint {
    if name == "__iter__" or name == "__del__" return 1
    if name =="__setitem__" return 3
    return 2
}
fnc evaluate_const_int_expression(program: Program, exp: Expression): int {
    if exp.expr_kind == ExpressionKind.INT {
        return (exp as IntExpression).value as int
    }
    if exp.expr_kind == ExpressionKind.FLOAT
        return (exp as FloatExpression).value as int
    if exp.expr_kind == ExpressionKind.BIN {
        let bin_exp = exp as BinaryExpression
        if bin_exp.op == BinaryOp.ADD
            return evaluate_const_int_expression(program, bin_exp.lhs) + evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SUB
            return evaluate_const_int_expression(program, bin_exp.lhs) - evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MUL
            return evaluate_const_int_expression(program, bin_exp.lhs) * evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.DIV
            return evaluate_const_int_expression(program, bin_exp.lhs) / evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.MOD
            return evaluate_const_int_expression(program, bin_exp.lhs) % evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SL
            return evaluate_const_int_expression(program, bin_exp.lhs) << evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.SR
            return evaluate_const_int_expression(program, bin_exp.lhs) >> evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.OR
            return evaluate_const_int_expression(program, bin_exp.lhs) or evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.AND
            return evaluate_const_int_expression(program, bin_exp.lhs) and evaluate_const_int_expression(program, bin_exp.rhs)
        if bin_exp.op == BinaryOp.XOR
            return evaluate_const_int_expression(program, bin_exp.lhs) ^ evaluate_const_int_expression(program, bin_exp.rhs)
    }
    if exp.expr_kind == ExpressionKind.UNARY {
        let unary_exp = exp as UnaryExpression
        if unary_exp.op == UnaryOp.NEG
            return -evaluate_const_int_expression(program, unary_exp.expression)
        if unary_exp.op == UnaryOp.NOT
            return !evaluate_const_int_expression(program, unary_exp.expression)
    }
    if exp.expr_kind == ExpressionKind.VAR_ACCESS {
        let var_exp = exp as VarAccessExpression
        return evaluate_const_int_expression(program, program.get_var(var_exp.var_id).value)
    }
    return -99999999
}
class Generic {
    module_id: ModuleId
    template: ClassDeclarationNode
    constructor(this, module_id: ModuleId, template: ClassDeclarationNode){
        this.module_id = module_id
        this.template = template
    }
}
let GENERIC_MODULE_ID: ModuleId = null
// Hint: For Generics and typed constraints consider Hidley-Milner Algorithm.
class TypeChecker {
    private program: Program
    private current_class: ClassId
    private current_function: FunctionId
    private current_scope: ScopeId
    private compiler: Compiler
    private in_loop: bool
    private module_contains_generics: bool
    private generic_templates: StringMap<Generic>
    constructor(this, compiler: Compiler){
        this.compiler = compiler
        this.in_loop = false
        this.program = new Program()
        this.generic_templates = new StringMap<Generic>()
        PrimitiveTypes.init()
    }
    public check(module_ast: ModuleAST, compiler: Compiler, filename: String): Program {
        let typechecker: TypeChecker(compiler)
        typechecker.load_generic_module()
        typechecker.load_builtins_module()
        if typechecker.has_errored() return typechecker.program
        typechecker.switch_to_generic_module()
        typechecker.import_all_from_module(typechecker.program.get_module(typechecker.program.builtin_scope.module_id))
        if typechecker.has_errored() return typechecker.program
        typechecker.check_module(module_ast, filename)
        return typechecker.program
    }
    private get_current_module(this): Module {
        return this.program.get_module(this.current_scope.module_id)
    }
    private get_current_module_global_scope(this): Scope {
        return this.program.get_scope(this.get_current_module().scope)
    }
    private types_are_eq(this, t1: Type, t2: Type): bool {
        if (t1.kind == TypeKind.GENERIC_VARIABLE) {
            let generic_var_type = (t1 as GenericTypeVariable)
            if (generic_var_type.current_instance != null)
                return this.types_are_eq(generic_var_type.current_instance, t2)
        }
        if (t2.kind == TypeKind.GENERIC_VARIABLE){
            let generic_var_type = (t2 as GenericTypeVariable)
            if (generic_var_type.current_instance != null)
                return this.types_are_eq(t1, generic_var_type.current_instance)
        }
        if t1.kind != t2.kind return false
        if is_function(t1) {
            let t1_fnc_type = t1 as FunctionType
            let t2_fnc_type = t2 as FunctionType
            if t1_fnc_type.param_types.length != t2_fnc_type.param_types.length return false
            if !this.types_are_eq(t2_fnc_type.return_type, t1_fnc_type.return_type) return false
            for let i = 0; i < t1_fnc_type.param_types.length; i++ {
                if !this.types_are_eq(t1_fnc_type.param_types[i], t2_fnc_type.param_types[i]) return false
            }
        }
        if t1.kind == TypeKind.ARRAY {
            let t1_arr_type = t1 as ArrayType
            let t2_arr_type = t2 as ArrayType
            return t1_arr_type.length == t2_arr_type.length and this.types_are_eq(t1_arr_type.element_type, t2_arr_type.element_type)
        }
        if t1.kind == TypeKind.RECORD {
            let t1_rec_type = t1 as RecordType
            let t2_rec_type = t2 as RecordType
            let t1_element_types_length =  t1_rec_type.element_types.length
            if t1_element_types_length != t2_rec_type.element_types.length 
                return false
            for let i = 0; i < t1_element_types_length; i++ {
                if (t1_rec_type.element_names[i] != t2_rec_type.element_names[i]) 
                    return false
                if !this.types_are_eq(t1_rec_type.element_types[i], t2_rec_type.element_types[i])
                    return false
            }
        }
        if t1.kind == TypeKind.PTR {
            let t1_ptr_type = t1 as PointerType
            let t2_ptr_type = t2 as PointerType
            return this.types_are_eq(t1_ptr_type.pointee_type, t2_ptr_type.pointee_type)
        }
        if t1.kind == TypeKind.OBJECT {
            let t1_obj_class_id = (t1 as ObjectType).class_id
            let t2_obj_class_id = (t2 as ObjectType).class_id
            if t1_obj_class_id == t2_obj_class_id  {
                return true
            }
            let t2_class = this.program.get_class(t2_obj_class_id as ClassId)
            if t2_class.parent != null {
                return this.types_are_eq(t1, t2_class.parent)
            }
            return false
        }
        if t1.kind == TypeKind.ENUM {
            let t1_enum_id = (t1 as EnumType).enum_id
            let t2_enum_id = (t2 as EnumType).enum_id
            return t1_enum_id == t2_enum_id
        }
        if t1.kind == TypeKind.RESOLVED_GENERIC {
            let t1_gen_type = t1 as ResolvedGenericType
            let t2_gen_type = t2 as ResolvedGenericType
            if t1_gen_type.name != t2_gen_type.name return false
            if t1_gen_type.arg_types.length != t2_gen_type.arg_types.length return false
            for let i = 0; i < t1_gen_type.arg_types.length; i++ {
                if (!this.types_are_eq(t1_gen_type.arg_types[i], t2_gen_type.arg_types[i])) return false
            }
        }
        if is_int(t1){
            if (t1 as IntType).is_signed != (t2 as IntType).is_signed return false
        }
        return true
    }
    private dump_type(this, ty: Type): String {
        if is_function(ty) {
            let fnc_ty = ty as FunctionType
            let param_types_str = ""
            for param_type in fnc_ty.param_types {
                param_types_str += "$(this.dump_type(param_type)), "
            }
            return "($param_types_str) => $(this.dump_type(fnc_ty.return_type))"
        }
        if ty.kind == TypeKind.PTR
            return "$(this.dump_type((ty as PointerType).pointee_type))*"
        if ty.kind == TypeKind.OBJECT {
            return this.program.get_class_from_type(ty).name
        }
        if ty.kind == TypeKind.ENUM {
            return this.program.get_enum((ty as EnumType).enum_id).name
        }
        if ty.kind == TypeKind.ARRAY {
            let arr_ty = ty as ArrayType
            return "$(this.dump_type(arr_ty.element_type))[$(arr_ty.length)]"
        }
        if ty.kind == TypeKind.RECORD {
            let tup_ty = ty as RecordType
            let rec_str = ""
            for let i = 0; i < tup_ty.element_types.length; i++ {
                let elem_ty = tup_ty.element_types[i]
                let elem_name = tup_ty.element_names[i]
                rec_str += "$(elem_name): $(this.dump_type(elem_ty)), "
            }
            return "{$rec_str}"
        }
        if ty.kind == TypeKind.RESOLVED_GENERIC {
            let gen_ty = ty as ResolvedGenericType
            let s = gen_ty.name + "<"
            for arg_type in gen_ty.arg_types {
                s +=  this.dump_type(arg_type)
            }
            return s + ">"
        }
        if ty.kind == TypeKind.GENERIC_VARIABLE {
            let gen_var_ty = ty as GenericTypeVariable
            if (gen_var_ty.current_instance != null){
                return gen_var_ty.name + " is " + this.dump_type(gen_var_ty.current_instance)
            }
            return gen_var_ty.name
        }
        return dump_type(ty, false)
    }
    private create_scope(this, module_id: ModuleId): Scope {
        let module = this.program.get_module(module_id)
        let scope = new Scope(module_id, this.program.scopes.length)
        this.program.scopes << scope
        return scope
    }
    private create_child_scope_within_scope(this, scope_id: ScopeId): Scope {
        let new_scope = this.create_scope(scope_id.module_id)
        new_scope.parent = scope_id
        let parent_scope = this.program.get_scope(scope_id)
        parent_scope.children << new_scope.id
        return new_scope
    }
    private is_constant_in_scope(this, scope_id: ScopeId, name: String): bool {
        let var_id = this.get_var_from_scope(scope_id, name)
        if var_id != null { 
            return this.program.get_var(var_id).is_constant
        } else {
            let scope =  this.program.get_scope(scope_id)
            let fnc_id = scope.functions[name]
            if (fnc_id != null) return true
        }
        return false
    }
    private get_var_from_scope(this, scope_id: ScopeId, name: String): VarId {
        let current_scope = this.program.get_scope(scope_id)
        let var_id: VarId = null
        while var_id == null {
            var_id = current_scope.vars[name]
            if current_scope.parent == null or var_id != null
                break
            current_scope = this.program.get_scope(current_scope.parent)
        }
        return var_id
    }
    private get_func_from_scope(this, scope_id: ScopeId, name: String): FunctionId {
        let current_scope = this.program.get_scope(scope_id)
        let fnc_id: FunctionId = null
        while fnc_id == null {
            fnc_id = current_scope.functions[name]
            if current_scope.parent == null or fnc_id != null
                break
            current_scope = this.program.get_scope(current_scope.parent)
        }
        return fnc_id
    }
    private get_type_from_scope(this, scope_id: ScopeId, name: String): Type {
        let current_scope = this.program.get_scope(scope_id)
        while true {
            let aliased_ty = current_scope.types[name]
            if aliased_ty != null {
                return aliased_ty
            }
            if (current_scope.parent == null) break
            current_scope = this.program.get_scope(current_scope.parent)
        }
        return PrimitiveTypes.unknown
    }
    private error(this, kind: ErrorKind, message: String, range: TextRange){
        this.compiler.errors << new FloError(kind, message, range)
    }
    private has_errored(this): bool {
        return this.compiler.errors.length > 0
    }
    private load_builtins_module(this){
        let module = this.lex_and_parse_typecheck_file(this.compiler.builtin_path, null)
        if (this.has_errored()) return
        let module_scope = this.program.get_scope(module.scope)
        module_scope.vars["true"] = null
        module_scope.vars["false"] = null
        module_scope.vars["null"] = null
        this.program.builtin_scope = module.scope
    }
    private load_generic_module(this){
        this.compiler.register_file("__generics__")
        let module = this.check_module(new ModuleAST(), "__generics__")
        GENERIC_MODULE_ID = module.scope.module_id
    }
    private switch_to_generic_module(this){
        this.current_scope = this.program.get_module(GENERIC_MODULE_ID).scope
    }
    private check_module(this, module_ast: ModuleAST, filename: String): Module {
        this.module_contains_generics = false
        let prev_scope = this.current_scope
        let module = new Module(filename)
        let current_module_id = new ModuleId(this.program.modules.length)
        module.id = current_module_id
        this.program.modules << module
        let module_scope = this.create_scope(current_module_id)
        module_scope.parent = this.program.builtin_scope
        module.scope = module_scope.id
        this.current_scope = module_scope.id
        this.current_class = null
        this.current_function = null
        for module_import in module_ast.imports {
            this.check_module_import(module_import)
            if (this.has_errored()) return module
        }
        // We declare module structures
        for parsed_enum in module_ast.enums {
            this.declare_enum_within_module(parsed_enum)
        }
        for parsed_class in module_ast.classes {
            this.declare_class_within_module(parsed_class)
        }
        if this.has_errored() return module
        for type_alias_node in module_ast.type_aliases {
            let ty = this.check_type(type_alias_node.parsed_type)
            let identifer_tok = type_alias_node.name
            let alias_name = identifer_tok.value
            if this.get_type_from_scope(this.current_scope, alias_name).kind != TypeKind.UNKNOWN {
                this.error(ErrorKind.NAME, "Name '$alias_name' has already been used for another type. consider renaming", type_alias_node.name.range)
                return module
            }
            module_scope.types[alias_name] = ty
        }
        for parsed_global_var in module_ast.vars {
            this.declare_global_var(parsed_global_var)
        }
        for parsed_function in module_ast.functions {
            this.declare_function_within_scope(module_scope.id, parsed_function)
        }
        if this.has_errored() return module
        // We Now check bodies
        for parsed_enum in module_ast.enums {
            this.check_enum_body(parsed_enum)
        }
        for parsed_class in module_ast.classes {
            this.check_class_body(parsed_class)
        }
        for let i = 0; i < module_ast.functions.length; i++ {
           this.check_function_body(module.scope, module_ast.functions[i])
        }
        if this.module_contains_generics and this.current_scope.module_id != 0 {
            this.switch_to_generic_module()
            this.import_all_from_module(module)
        }
        this.current_scope = prev_scope
        return module
    }
    private create_generic_instance_in_module(this, name: String, types: Type[]): ResolvedGenericType {
        let generic = this.generic_templates[name]
        if generic == null return null
        let generic_params = generic.template.generic_parameters
        if generic_params.length != types.length {
            this.error(ErrorKind.TYPE, "Generic expects $(generic_params.length) parameters but got $(types.length)", null)
            return null
        }
        let scope_id = this.current_scope
        this.switch_to_generic_module()
        let generic_scope = this.create_child_scope_within_scope(this.current_scope)
        let param_strings = ""
        for let i = 0; i < generic_params.length; i++ {
            let param_name = generic_params[i].name.value
            let param_type: Type = types[i].kind == TypeKind.RESOLVED_GENERIC ? (types[i] as ResolvedGenericType).instantiated_type : types[i]
            param_strings += "$(this.dump_type(param_type))_"
            generic_scope.types[param_name] = types[i]
        }
        let instantiated_generic_name = "$(name)_$param_strings"
        let possible_type = this.get_type_from_scope(this.current_scope, instantiated_generic_name)
        if possible_type.kind == TypeKind.UNKNOWN {
            // TODO: Find a better way to create this initialization.
            let new_identok: IdentifierToken(instantiated_generic_name, generic.template.name.range)
            let instantiated_generic_class: ClassDeclarationNode(new_identok)
            instantiated_generic_class.parent = generic.template.parent
            instantiated_generic_class.fields = generic.template.fields
            instantiated_generic_class.methods = generic.template.methods
            this.current_scope = generic_scope.id
            this.declare_class_within_module(instantiated_generic_class)
            this.check_class_body(instantiated_generic_class)
            possible_type = this.get_type_from_scope(generic_scope.id, instantiated_generic_name)
        }
        this.current_scope = scope_id
        return new ResolvedGenericType(name, types, possible_type)
    }
    private declare_var_within_scope(
            this,
            scope_id: ScopeId,
            name: String, 
            value: Expression, 
            value_type: Type, 
            visibility: AccessVisibility, 
            is_const: bool
        ): Var {
        let var = new Var(name, value, is_const, visibility, value_type)
        let module = this.program.get_module(scope_id.module_id)
        let scope = this.program.get_scope(scope_id)
        let var_id = new VarId(scope_id.module_id, this.program.vars.length)
        var.id = var_id
        this.program.vars << var
        scope.vars[name] = var_id
        return var
    }
    private declare_global_var(this, var_decl_node: VarDeclarationStatement){
        let var_stmt = this.check_var_declaration(var_decl_node)
        if this.has_errored() return
        let value = var_stmt.var.value
        if value != null {
            if !value.is_constant {
                this.error(ErrorKind.GEN, "Initilializer for global variable has to be a constant", var_decl_node.value.range)
                return
            }
        }
        var_stmt.is_static = true
        this.get_current_module().global_vars << var_stmt
    }
    private add_imported_type_to_module(this, alias_name: String, found_type: Type){
        let scope = this.get_current_module_global_scope()
        scope.types[alias_name] = found_type
    }
    private add_imported_var_to_module(this, var_name: String, var_id: VarId){
        let scope = this.get_current_module_global_scope()
        scope.vars[var_name] = var_id
    }
    private add_imported_fnc_to_module(this, fnc_name: String, fnc_id: FunctionId){
        let scope = this.get_current_module_global_scope()
        let func = this.program.get_func(fnc_id)
        scope.functions[fnc_name] = fnc_id
    }
    private import_all_from_module(this, module: Module){
        let global_module_scope = this.program.get_scope(module.scope)
        for var_stmt in module.global_vars {
            this.add_imported_var_to_module(var_stmt.var.name, var_stmt.var.id)
        }
        for func_entry in global_module_scope.functions {
            this.add_imported_fnc_to_module(func_entry.key, func_entry.value)
        }
        for type_alias_entry in global_module_scope.types {
            this.add_imported_type_to_module(type_alias_entry.key, type_alias_entry.value)
        }
    }
    private check_module_import(this, import_node: ImportNode){
        if import_node.module_path.args.length > 0 {
            this.error(ErrorKind.GEN, "Import statement path can't be a formatted string", import_node.module_path.range)
            return
        }
        let path = import_node.module_path.value
        let module = this.lex_and_parse_typecheck_file(path, import_node.module_path.range)
        if this.has_errored() return
        if import_node.import_list.length > 0 {
            for import_clause in import_node.import_list {
                let name_to_import = import_clause.original_identifer.value
                let renamed_name = import_clause.renamed_identifer ? import_clause.renamed_identifer.value : name_to_import
                if this.generic_templates[name_to_import] != null {
                    continue
                }
                let var_id = this.get_var_from_scope(module.scope, name_to_import)
                if var_id != null {
                    this.add_imported_var_to_module(renamed_name, var_id)
                    continue 
                }
                let func_id = this.get_func_from_scope(module.scope, name_to_import)
                if func_id != null {
                    this.add_imported_fnc_to_module(renamed_name, func_id)
                    continue
                }
                let found_type = this.get_type_from_scope(module.scope, name_to_import)
                if found_type != null {
                    this.add_imported_type_to_module(renamed_name, found_type)
                    continue
                } else {
                    this.error(ErrorKind.NAME, "'$name_to_import' not found in module '$path'", import_clause.original_identifer.range)
                    return
                }
            }
        } else if import_node.module_name != null {
            let name = import_node.module_name.value
            this.get_current_module_global_scope().modules[name] = module.id
        } else {
            this.import_all_from_module(module)
        }
    }
    private lex_and_parse_typecheck_file(this, filename: String, range: TextRange): Module {
        // TODO: You need to properly handle the built-in case; don't use null as a reference point.
        let filepath = filename
        let prev_file_id = this.compiler.current_file
        if range != null and !filename.starts_with("@") {
            filepath = Path.join(Path.dirname(this.get_current_module().name), filename)
        }
        let file_id = this.compiler.register_file(filepath)
        if file_id.id < this.program.modules.length {
            let module_id: ModuleId(file_id.id)
            return this.program.get_module(module_id)
        }
        if !this.compiler.set_current_file(file_id){ 
            this.error(ErrorKind.IO, "No such file or directory: '$filename'", range)
            return null
        }
        let tokens = Lexer.tokenize(this.compiler)
        if this.has_errored() return null
        let module_node = Parser.parse(tokens, this.compiler.errors)
        if this.has_errored() return null
        let module = this.check_module(module_node, filepath)
        if this.has_errored() return null
        this.compiler.set_current_file(prev_file_id)
        return module
    }
    private declare_enum_within_module(this, enum_node: EnumNode){
        let declared_enum = new Enum()
        let enum_scope = this.create_child_scope_within_scope(this.current_scope)
        declared_enum.scope = enum_scope.id
        let enum_name = enum_node.name.value
        declared_enum.definition_range = enum_node.name.range
        let module_scope =  this.get_current_module_global_scope()
        declared_enum.name = enum_name
        if this.get_type_from_scope(this.current_scope, enum_name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Name '$enum_name' has already been used for another type. consider renaming", enum_node.name.range)
            return
        }
        declared_enum.id = new EnumId(this.program.enums.length)
        this.program.enums << declared_enum
        module_scope.enums[enum_name] = declared_enum.id
        module_scope.types[enum_name] = new EnumType(declared_enum.id)
    }
    private declare_class_within_module(this, class_decl_node: ClassDeclarationNode) {
        let name = class_decl_node.name.value
        if (this.get_type_from_scope(this.current_scope, name).kind != TypeKind.UNKNOWN) or (this.generic_templates[name] != null) {
            this.error(ErrorKind.NAME, "Name '$name' has already been used for another type. consider renaming", class_decl_node.name.range)
            return
        }
        if class_decl_node.generic_parameters.length > 0 {
            this.module_contains_generics = true
            this.generic_templates[name] = new Generic(this.current_scope.module_id, class_decl_node)
            return
        }
        let props_scope = this.create_child_scope_within_scope(this.current_scope)
        let static_props_scope = this.create_child_scope_within_scope(this.current_scope)
        let declared_class = new Class()
        declared_class.props_scope = props_scope.id
        declared_class.static_props_scope = static_props_scope.id
        declared_class.definition_range = class_decl_node.name.range
        let module_scope = this.get_current_module_global_scope()
        if class_decl_node.parent != null {
            declared_class.parent = this.check_type(class_decl_node.parent)
            if this.has_errored() return
        } else {
            declared_class.parent = null
        }
        declared_class.name = name
        declared_class.id = new ClassId(this.program.classes.length)
        this.program.classes << declared_class
        module_scope.classes[name] = declared_class.id
        module_scope.types[name] = new ObjectType(declared_class.id)
    }
    private declare_function_within_scope(this, scope_id: ScopeId, function_node: FunctionDeclarationNode, implicit_this_param = PrimitiveTypes.unknown): Function {
        let declared_function = new Function(function_node.name.range)
        declared_function.is_external = function_node.is_external
        let name = function_node.name.value
        declared_function.name = name
        if this.is_constant_in_scope(scope_id, name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", function_node.name.range)
            return null
        }
        if this.get_type_from_scope(this.current_scope, name).kind != TypeKind.UNKNOWN {
            this.error(ErrorKind.NAME, "Illegal re-declaration of type '$name' as function", function_node.name.range)
            return null
        }
        let fnc_scope = this.create_child_scope_within_scope(this.current_scope)
        let param_types: Type[] = []
        declared_function.params = []
        for param in function_node.params {
            let fnc_param_name = param.name.value
            let fnc_param_range = param.name.range
            let fnc_param_default: Expression = null
            let fnc_param_type = PrimitiveTypes.unknown
            if param.parsed_type != null {
                fnc_param_type = param.parsed_type.kind == TypeKind.UNKNOWN ? implicit_this_param : this.check_type(param.parsed_type)
            }
            if this.has_errored() return null
            if param.default != null {
                fnc_param_default = this.check_expression(fnc_param_type, param.default)
                if this.has_errored() return null
                if (fnc_param_type.kind == TypeKind.UNKNOWN) {
                    fnc_param_type = fnc_param_default.value_type
                } else if !this.types_are_eq(fnc_param_type, fnc_param_default.value_type){
                    this.error(ErrorKind.TYPE, "Expected type of '$(this.dump_type(fnc_param_type))' but got type of '$(this.dump_type(fnc_param_default.value_type))' on signature", fnc_param_default.range)
                    return null
                }
            }
            let var = this.declare_var_within_scope(fnc_scope.id, fnc_param_name, fnc_param_default, fnc_param_type, AccessVisibility.UNDEF, false)
            let fnc_param = new FunctionParam(var, fnc_param_range)
            declared_function.params << fnc_param
            param_types << fnc_param_type
        }
        let ret_type = function_node.return_type == null ? PrimitiveTypes.void : this.check_type(function_node.return_type)
        if this.has_errored() return null
        declared_function.fnc_type = new FunctionType(!function_node.is_static(), param_types, ret_type)
        let module = this.program.get_module(scope_id.module_id)
        declared_function.id = new FunctionId(this.program.functions.length)
        this.current_scope = fnc_scope.parent
        declared_function.scope = fnc_scope.id
        if (is_object(implicit_this_param)){
            declared_function.class_id = (implicit_this_param as ObjectType).class_id
        }
        let scope = this.program.get_scope(scope_id)
        this.program.functions << declared_function
        scope.functions[declared_function.name] = declared_function.id
        return declared_function
    }
    private check_enum_body(this, enum_node: EnumNode){
        let enum_name = enum_node.name.value
        let resolved_type = this.get_type_from_scope(this.current_scope, enum_name)
        if resolved_type.kind == TypeKind.UNKNOWN return
        let declared_enum = this.program.get_enum_from_type(resolved_type)

        let enum_variant: Type = null
        if enum_node.variant == null {
            enum_variant = PrimitiveTypes.int
        } else {
            enum_variant = this.check_type(enum_node.variant)
            if !is_int(enum_variant){
                this.error(ErrorKind.TYPE, "Expected an int type for enum type but got type '$(this.dump_type(enum_variant))'", enum_node.variant.range)
            }
        }
        let raw_enum_value: u64 = 0 // What about negatives?
        for let i = 0; i < enum_node.fields.length; i++ {
            let enum_node_field = enum_node.fields[i]
            let enum_field_name = enum_node_field.name.value
            let enum_field_range = enum_node_field.name.range
            let enum_field_initializer: Expression = null
            if enum_node_field.initializer != null {
                let expression = this.check_expression(enum_variant, enum_node_field.initializer)
                if (this.has_errored()) return
                enum_field_range = TextRange.merge(enum_field_range, expression.range)
                if !expression.is_constant {
                    this.error(ErrorKind.TYPE, "Enum initializer has to be a constant", enum_node_field.initializer.range)
                    return
                }
                if !this.types_are_eq(enum_variant, expression.value_type){
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(enum_variant))' but got type '$(this.dump_type(expression.value_type))", enum_node_field.initializer.range)
                    return
                }
                raw_enum_value = evaluate_const_int_expression(this.program, expression) as u64
            }
            enum_field_initializer = new IntExpression(raw_enum_value, enum_field_range)
            enum_field_initializer.value_type = enum_variant
            let enum_field_var = this.declare_var_within_scope(declared_enum.scope, enum_field_name, enum_field_initializer, enum_variant, AccessVisibility.UNDEF, true)
            declared_enum.fields << new Field(enum_field_var, i, enum_field_range)
            raw_enum_value++
        }
        declared_enum.variant_type = enum_variant
    }
    private declare_class_fields(this, declared_class: Class, class_node: ClassDeclarationNode){
        let current_field_offset = declared_class.fields.length - 1
        for let i = 0; i < class_node.fields.length; i++ {
            let field_node = class_node.fields[i]
            let field_name = field_node.name.value
            let field_type = this.check_type(field_node.parsed_type)
            let initializer: Expression = null
            let scope: ScopeId = null
            if this.has_errored() return
            if is_operator_overload_name(field_name) {
                this.error(ErrorKind.NAME, "$field_name is reserved only for operator overloads and cannot be used as a field name", field_node.name.range)
                return
            }
            if field_node.initializer != null {
                scope = declared_class.static_props_scope
                initializer = this.check_expression(field_type, field_node.initializer)
                if this.has_errored() return
                if !this.types_are_eq(field_type, initializer.value_type) {
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(field_type))' but got type '$(this.dump_type(initializer.value_type))' on static field initialization", field_node.initializer.range)
                    return
                }
                if !initializer.is_constant {
                    this.error(ErrorKind.GEN, "Static field initializer has to be a constant", field_node.initializer.range)
                    return
                }
            } else {
                scope = declared_class.props_scope
                let possible_field_id = this.get_var_from_scope(scope, field_name)
                if possible_field_id != null {
                    this.error(ErrorKind.NAME, "Field $field_name in class $(declared_class.name) already exists", field_node.name.range)
                    return
                }
                current_field_offset++
            }

            let field_var = this.declare_var_within_scope(scope, field_name, initializer, field_type, field_node.access_modifier, false)
            declared_class.fields << new Field(field_var, current_field_offset, field_node.name.range)
        }
    }
    private is_iteratable(this, suspect_type: Type): bool {
        //TODO: Need to think about generics
        if !is_object(suspect_type) return false
        let checked_class = this.program.get_class_from_type(suspect_type)
        let done_field_id = this.get_var_from_scope(checked_class.props_scope, "done")
        if (done_field_id == null) return false
        let done_field_var = this.program.get_var(done_field_id)
        if (!is_bool(done_field_var.value_type)) return false
        let next_method_id = this.get_func_from_scope(checked_class.props_scope, "next")
        if (next_method_id == null) return false
        let next_method_type = this.program.get_func(next_method_id).fnc_type
        if (next_method_type.param_types.length != 1) return false
        return !is_void(next_method_type.return_type)
    }
    private declare_class_methods(this, declared_class: Class, class_node: ClassDeclarationNode){
        let object_type = this.get_type_from_scope(this.current_scope, declared_class.name)
        for let i = 0; i < class_node.methods.length; i++ {
            let method_node = class_node.methods[i]
            let method_name = method_node.function.name.value
            let name_range = method_node.function.name.range
            let method_is_static = method_node.function.is_static()
            let method_is_abstract = method_node.function.is_external
            let method_params_num = method_node.function.params.length
            if is_operator_overload_name(method_name) {
                if method_is_static {
                    this.error(ErrorKind.GEN, "Binary operator overload $method_name cannot be static", name_range)
                    return
                }

                let required_params_num = get_num_params_for_operator_overload(method_name)
                if method_params_num != required_params_num {
                    this.error(ErrorKind.GEN, "Expected $required_params_num parameters for binary operator overload $method_name but got $(method_params_num)", name_range)
                    return
                }
            }

            if method_is_abstract {
                if method_is_static {        
                    this.error(ErrorKind.GEN, "Static method can't be abstract", name_range)
                    return
                }
            }

            let declaration_scope = method_is_static ? declared_class.static_props_scope : declared_class.props_scope
            let method = this.declare_function_within_scope(declaration_scope, method_node.function, object_type)

            if this.has_errored() return
            if method_name == "constructor" {
                if method_is_abstract {
                    this.error(ErrorKind.GEN, "Class constructor can't be abstract", name_range)
                    return
                }
                if method_is_static {
                    this.error(ErrorKind.GEN, "Class constructor can't be static", name_range)
                    return
                }
            }
        
            if method_name == "__iter__" and (!this.is_iteratable(method.fnc_type.return_type)) {
                this.error(ErrorKind.TYPE, "__iter__ method must return an iteratable object {done: bool, next(): any}", name_range)
                return 
            }
            method.visibility = method_node.access_modifier
        }
    }
    private add_inherited_props_to_class(this, declared_class: Class, class_node: ClassDeclarationNode){
        let parent_type = declared_class.parent
        if !is_object(parent_type) {
            this.error(ErrorKind.TYPE, "Can only inherit from class not type '$(this.dump_type(parent_type))'", class_node.parent.range)
        }
        let parent_class = this.program.get_class_from_type(parent_type)
        let parent_scope = this.program.get_scope(parent_class.props_scope)
        let class_scope = this.program.get_scope(declared_class.props_scope)
        for parent_field in parent_class.fields {
            if parent_field.var.value != null continue
            class_scope.vars[parent_field.var.name] = parent_field.var.id
            declared_class.fields << parent_field
        }
        for method_map_entry in parent_scope.functions {
            let parent_method_id = method_map_entry.value
            let parent_method_name = method_map_entry.key
            if (parent_method_name == "super") continue // does not support multiple inheritance 
            let inherited_method_name = parent_method_name == "constructor" ? "super" : parent_method_name
            class_scope.functions[inherited_method_name] = parent_method_id
        }
    }
    private check_class_body(this, class_node: ClassDeclarationNode){
        let class_name = class_node.name.value
        let resolved_type = this.get_type_from_scope(this.current_scope, class_name)
        if resolved_type.kind == TypeKind.UNKNOWN return
        let declared_class = this.program.get_class_from_type(resolved_type)
        let class_scope = this.program.get_scope(declared_class.props_scope)
        let outer_class = this.current_class
        this.current_class = declared_class.id
        if declared_class.parent != null {
            this.add_inherited_props_to_class(declared_class, class_node)
        }
        // Fields
        this.declare_class_fields(declared_class, class_node)     
        if this.has_errored() return
        // Declare class methods
        this.declare_class_methods(declared_class, class_node)
        if this.has_errored() return
        // Checking if class is abstract.
        if this.is_constant_in_scope(declared_class.props_scope, "constructor") {
            for method_map_entry in class_scope.functions {
                let method = this.program.get_func(method_map_entry.value)
                let method_name = method.name
                if (method.is_external){
                    this.error(ErrorKind.GEN, "Class with constructor must implement all it's methods '$class_name' is missing $method_name's implementation", method.definition_range)
                    return
                }
            }
        }
        // Class Methods Body
        for let i = 0; i < class_node.methods.length; i++ {
            let method_node = class_node.methods[i].function
            let method_name = method_node.name.value
            let scope_context = method_node.is_static() ? declared_class.static_props_scope : declared_class.props_scope
            this.check_function_body(scope_context, method_node)
        }
        this.current_class = outer_class
    }
    private check_function_body(this, scope_id: ScopeId, func_node: FunctionDeclarationNode) {
        let fnc_id = this.get_func_from_scope(scope_id, func_node.name.value)
        let func = this.program.get_func(fnc_id)
        if (func.is_external) return

        let prev_func = this.current_function
        this.current_function = func.id
        let prev_scope = this.current_scope
        this.current_scope = func.scope
        func.block = this.check_block(func_node.block)
        if this.has_errored() return
        if !func.block.returns {
            if func.fnc_type.return_type.kind == TypeKind.VOID {
                func.block.statements << (new ReturnStatement() as Statement)
            } else {
                this.error(ErrorKind.GEN, "Function missing ending return statement", func_node.name.range)
                return
            }
        }
        this.current_function = prev_func
        this.current_scope = prev_scope
    }
    private check_array_type(this, array_type_node: ArrayTypeNode): Type {
        let len_expr = this.check_expression(PrimitiveTypes.uint, array_type_node.length)
        if this.has_errored() return PrimitiveTypes.unknown
        if !is_int(len_expr.value_type) {
            this.error(ErrorKind.GEN, "length has to be an int", array_type_node.length.range)
            return null
        }
        let size_ty = len_expr.value_type as IntType
        if size_ty.is_signed or size_ty.kind != TypeKind.INT {
            this.error(ErrorKind.GEN, "length has to be a uint", array_type_node.length.range)
            return null
        }
        if !len_expr.is_constant {
            this.error(ErrorKind.GEN, "length is a non-constant value", array_type_node.length.range)
            return null
        }
        let length = evaluate_const_int_expression(this.program, len_expr)
        if length < 0 {
            this.error(ErrorKind.GEN, "length should be an unsigned", array_type_node.length.range)
            return null
        }
        let element_type = this.check_type(array_type_node.element_type)
        return new ArrayType(element_type, length as uint)
    }
    private check_function_type(this, function_type_node: FunctionTypeNode): Type {
        let param_types: Type[] = []
        for param_type_node in function_type_node.param_types 
            param_types << this.check_type(param_type_node)
        let return_type = this.check_type(function_type_node.return_type)
        return new FunctionType(false, param_types, return_type)
    }
    private check_record_type(this, record_type_node: RecordTypeNode): Type {
        let record_type = new RecordType()
        for field_node in record_type_node.fields {
            record_type.element_types << this.check_type(field_node.type)
            record_type.element_names << field_node.name.value
        }
        return record_type
    }
    private check_named_record_type(this, record_type_node: NamedRecordTypeNode): Type {
        let record_identifier = record_type_node.name
        let name = record_identifier.value

        if record_type_node.generic_args.length > 0 {
            let types: Type[] = []
            for arg in record_type_node.generic_args
                types << this.check_type(arg)
            if this.has_errored() return null
            let generic_type = this.create_generic_instance_in_module(name, types)
            if generic_type != null {
                return generic_type
            }
        }

        let found_type = this.get_type_from_scope(this.current_scope, name)
        if found_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.TYPE, "Undefined type '$name'", record_identifier.range)
            return null
        }
        return found_type
    }
    private check_type(this, type_node: TypeNode): Type {
        if type_node.kind == TypeKind.PTR
            return new PointerType(this.check_type((type_node as PointerTypeNode).pointee_type))
        if type_node.kind == TypeKind.ARRAY
            return this.check_array_type(type_node as ArrayTypeNode)
        if type_node.kind == TypeKind.FNC {
            return this.check_function_type(type_node as FunctionTypeNode)
        } else if type_node.kind == TypeKind.RECORD {
            return this.check_record_type(type_node as RecordTypeNode)
        }
        if type_node.kind == TypeKind.NAMED_RECORD {
            let named_record_type_node = type_node as NamedRecordTypeNode
            let name_value = named_record_type_node.name.value

            if name_value == "bool" return PrimitiveTypes.bool
            if name_value == "u4" return PrimitiveTypes.u4
            if name_value == "u8" return PrimitiveTypes.u8
            if name_value == "u16" return PrimitiveTypes.u16
            if name_value == "u32" return PrimitiveTypes.u32
            if name_value == "u64" return PrimitiveTypes.u64
            if name_value == "u128" return PrimitiveTypes.u128
            if name_value == "uint" return PrimitiveTypes.uint
            if name_value == "i4" return PrimitiveTypes.i4
            if name_value == "i8" return PrimitiveTypes.i8
            if name_value == "i16" return PrimitiveTypes.i16
            if name_value == "i32" return PrimitiveTypes.i32
            if name_value == "i64" return PrimitiveTypes.i64
            if name_value == "i128" return PrimitiveTypes.i128
            if name_value == "int" return PrimitiveTypes.int
            if name_value == "f32" return PrimitiveTypes.f32
            if name_value == "f64" return PrimitiveTypes.f64
            if name_value == "void" return PrimitiveTypes.void
            else return this.check_named_record_type(named_record_type_node)
        }
        return PrimitiveTypes.unknown
    }
    private check_record_expression(this, expected_type: Type, record_node: RecordExpressionNode): RecordExpression {
        let expected_record_type: RecordType = null
        let elements: Expression[] = []
        let actual_tuple_type = new RecordType()
        let is_constant = true
        if expected_type.kind == TypeKind.RECORD {
            expected_record_type = expected_type as RecordType
        }
        for let i = 0; i < record_node.elements.length; i++ {
            let expected_element_type = PrimitiveTypes.unknown
            let record_element = record_node.elements[i]
            if expected_record_type != null {
                for let j = 0; j < expected_record_type.element_types.length; j++ {
                    if (record_element.key.value == expected_record_type.element_names[j]) {
                        expected_element_type = expected_record_type.element_types[j]
                    }
                }
            }
            let expression = this.check_expression(expected_element_type, record_element.value)
            if this.has_errored() return null
            is_constant and= expression.is_constant
            actual_tuple_type.element_types << expression.value_type
            actual_tuple_type.element_names << record_element.key.value
            elements << expression
        }
        let record_expression = new RecordExpression(elements, actual_tuple_type, record_node.range)
        record_expression.is_constant = is_constant
        return record_expression
    }
    private check_array_expression(this, expected_type: Type, array_node: ArrayExpressionNode): ArrayExpression {
        if this.has_errored() return null
        let elements: Expression[] = []
        let element_type = PrimitiveTypes.unknown
        let is_constant = true
        let array_type = expected_type
        if expected_type.kind == TypeKind.ARRAY {
            element_type = (expected_type as ArrayType).element_type
        } else if expected_type.kind == TypeKind.RESOLVED_GENERIC {
            is_constant = false
            let generic_ty =  expected_type as ResolvedGenericType
            if is_object(generic_ty) and generic_ty.name == "Array"
                element_type = generic_ty.arg_types[0]
        }
        if array_node.elements.length > 0 {
            let i = 0
            for array_node_elements in array_node.elements {
                let element = this.check_expression(element_type, array_node_elements)
                if this.has_errored() return null
                if i == 0 and element_type.kind == TypeKind.UNKNOWN {
                    element_type = element.value_type
                }
                is_constant and= element.is_constant
                if this.types_are_eq(element_type, element.value_type) {
                    elements << element
                } else {
                    this.error(ErrorKind.TYPE, "Expected element type of '$(this.dump_type(element_type))' but got type '$(this.dump_type(element.value_type))'", array_node_elements.range)
                    return null
                }
                i++
            }
        }
        if array_type.kind != TypeKind.ARRAY {
            let generic_array_type = this.create_generic_instance_in_module("Array", [element_type])
            if (generic_array_type != null) {
                array_type = generic_array_type
                is_constant = false
            }
        } else {
            array_type = new ArrayType(element_type, elements.length)
        }
        let arr_exp = new ArrayExpression(elements, array_type, array_node.range)
        arr_exp.is_constant = is_constant
        return arr_exp
    }
    private check_var_access_expr(this, expected_type: Type, var_access_node: VarAccessExpressionNode): Expression {
        let name = var_access_node.name.value
        if name == "true" 
            return new BooleanExpression(true, var_access_node.range) 
        if name == "false" 
            return new BooleanExpression(false, var_access_node.range)
        if name == "null" {
            if (expected_type.kind == TypeKind.VOID) {
                this.error(ErrorKind.TYPE, "Const 'null' cannot be of type 'void'", var_access_node.name.range)
                return null
            }
            return new NullExpression(expected_type, var_access_node.range)
        }
        let var_id = this.get_var_from_scope(this.current_scope, name)
        if var_id != null {
            let var = this.program.get_var(var_id)
            return new VarAccessExpression(var_id, var.value_type, var.is_constant, var_access_node.range)
        }
        let func_id = this.get_func_from_scope(this.current_scope, name)
        if func_id != null {
            let fnc_type = this.program.get_func(func_id).fnc_type
            return new FncAccessExpression(func_id, fnc_type, var_access_node.range)
        }
        this.error(ErrorKind.NAME, "Undefined variable '$name'", var_access_node.range)
        return null
    }
    private check_assignment(this, left: Expression, right: Expression, binary_node: BinaryExpressionNode): Expression {
        let op = binary_node.op
        if op != BinaryOp.ASSIGN {
            if is_object(left.value_type){
                let exp = this.check_object_bin_assign(left, binary_node)
                if exp != null or this.has_errored() return exp
            }
            right = this.check_bin_expr(left.value_type, lower_bin_assign_node(binary_node))
            if this.has_errored() return null
        }
        if !check_is_var(left) {
            this.error(ErrorKind.TYPE, "Assigment target is not a mutable", binary_node.lhs.range)
            return null
        }
        if !this.types_are_eq(left.value_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Illegal assignment of variable of type '$(this.dump_type(right.value_type))' to '$(this.dump_type(left.value_type))'", binary_node.range)
            return null
        }
        return new BinaryExpression(left, BinaryOp.ASSIGN, right, right.value_type, binary_node.range)
    }
    private check_object_bin_assign(this, left: Expression, binary_node: BinaryExpressionNode): Expression {
        let method_name = bin_op_to_op_overload_name(binary_node.op)
        let checked_class = this.program.get_class_from_type(left.value_type as ObjectType)
        let method_id = this.get_func_from_scope(checked_class.props_scope, method_name)
        if method_id == null {
            return null
        }
        let method = this.program.get_func(method_id)
        let method_type = method.fnc_type
        let param_type = method_type.param_types[1]
        let right = this.check_expression(param_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(param_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(param_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let method_access = new ClassMethodAccessExpression(left, method_id, method_type, binary_node.range)
        let args: Expression[] = [right]
        return new CallExpression(method_access, args, method_type.return_type, binary_node.range)
    }
    private check_object_binary_expr(this, left: Expression, binary_node: BinaryExpressionNode, right: Expression): Expression {
        let op = binary_node.op
        let method_name = bin_op_to_op_overload_name(op)
        if method_name == null {
            this.error(ErrorKind.GEN, "Unsupported binary operator overload for operator '$(dump_bin_op(op))'", binary_node.range)
            return null
        }
        let owner_class = this.program.get_class_from_type(left.value_type)
        let method_id = this.get_func_from_scope(owner_class.props_scope, method_name)
        if method_id == null {
            if op == BinaryOp.EEQ or op == BinaryOp.NEQ {
                return new BinaryExpression(left, op, this.check_expression(left.value_type, binary_node.rhs), PrimitiveTypes.bool, binary_node.range)
            }
            this.error(ErrorKind.NAME, "No binary operator overload for '$(dump_bin_op(op))' in object of class '$(owner_class.name)' please implement the method $method_name to support this", binary_node.range)
            return null
        }
        let method_type = this.program.get_func(method_id).fnc_type
        let param_type = method_type.param_types[1]
        if right == null 
            right = this.check_expression(param_type, binary_node.rhs)
        if this.has_errored() return null
        if is_null_expression(right) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            return new BinaryExpression(left, op, right, PrimitiveTypes.bool, binary_node.range)
        }
        if op == BinaryOp.IN { //FIXME: Just For Ranges. Will not be required once we have ranges are generics. 
            if is_int(right.value_type) and is_int(param_type){
                right = cast_exp_to_type(right, max_type(right.value_type, param_type))
            }
        }
        if !this.types_are_eq(param_type, right.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(param_type))' but got type '$(this.dump_type(right.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_exp = new ClassMethodAccessExpression(left, method_id, method_type, binary_node.range)
        let args: Expression[] = [right]
        return new CallExpression(member_exp, args, method_type.return_type, binary_node.range)
    }
    private check_object_setitem_expr(this, object: Expression, binary_node: BinaryExpressionNode): Expression {
        let index_expr_node = binary_node.lhs as ExpressionIndexNode
        let owner_class = this.program.get_class_from_type(object.value_type)
        let method_id = this.get_func_from_scope(owner_class.props_scope, "__setitem__")
        if method_id == null {
            this.error(ErrorKind.GEN, "No operator overload for index set operator on $(owner_class.name) object please implement method __setitem__ to use in this class", index_expr_node.range)
            return null
        }
        let method_type = this.program.get_func(method_id).fnc_type
        let param1_type = method_type.param_types[1]
        let param2_type = method_type.param_types[2]
        if this.has_errored() return null
        let index = this.check_expression(param1_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(param1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(param1_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let value = this.check_expression(param2_type, binary_node.rhs)
        if this.has_errored() return null
        if !this.types_are_eq(param1_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(param2_type))' but got type '$(this.dump_type(value.value_type))'", binary_node.rhs.range)
            return null
        }
        let member_expr = new ClassMethodAccessExpression(object, method_id, method_type, binary_node.range)
        let args: Expression[] = [index, value]
        return new CallExpression(member_expr, args, method_type.return_type, binary_node.range)
    }
    //TODO: This needs a complete re-write this is messy
    private check_bin_expr(this, expected_type: Type, binary_node: BinaryExpressionNode): BinaryExpression {
        let op = binary_node.op
        let is_assign_op = op >= BinaryOp.ASSIGN and op <= BinaryOp.SR_ASSIGN
        if op == BinaryOp.ASSIGN and binary_node.lhs.expr_kind == ExpressionKind.INDEX {
            let possible_obj = this.check_expression(PrimitiveTypes.unknown, (binary_node.lhs as ExpressionIndexNode).expression)
            if this.has_errored() return null
            if is_object(possible_obj.value_type)
                return this.check_object_setitem_expr(possible_obj, binary_node) as BinaryExpression
        }
        let left = this.check_expression(expected_type, binary_node.lhs)
        if this.has_errored() return null
        if is_object(left.value_type) and !is_assign_op and op != BinaryOp.IN
            return this.check_object_binary_expr(left, binary_node, null) as BinaryExpression
        let right = this.check_expression(left.value_type, binary_node.rhs)
        if this.has_errored() return null
        if is_object(right.value_type) and op == BinaryOp.IN {
            return this.check_object_binary_expr(right, binary_node, left) as BinaryExpression
        }
        if this.has_errored() return null
        if is_assign_op {
            return this.check_assignment(left, right, binary_node) as BinaryExpression
        }
        let is_const = left.is_constant and right.is_constant
        if left.value_type.kind == TypeKind.UNKNOWN and right.value_type.kind != TypeKind.UNKNOWN
            left.value_type = right.value_type
        if is_numeric(left.value_type) and is_numeric(right.value_type){
            if op == BinaryOp.POW {
                if is_int(left.value_type)
                    left = cast_exp_to_type(left, PrimitiveTypes.f64) // Might need to cast it to the biggest available
                if is_int(right.value_type)
                    right = cast_exp_to_type(right, PrimitiveTypes.f64) // Might need to cast it to the biggest available
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range)
            }
            if op >= BinaryOp.ADD and op <=  BinaryOp.LTE {
                check_cast_lower_bits(&left, &right)
                let exp_type = left.value_type
                if op >= BinaryOp.GT and op <= BinaryOp.LTE 
                    exp_type = PrimitiveTypes.bool
                
                return new BinaryExpression(left, op, right, exp_type, binary_node.range, is_const)
            }
            if op >= BinaryOp.SL and op <= BinaryOp.XOR {
                if is_float(left.value_type)
                    left = cast_exp_to_type(left, PrimitiveTypes.int) // Might need to cast it to the biggest available
                if is_float(right.value_type){
                    right = cast_exp_to_type(right, PrimitiveTypes.int) // Might need to cast it to the biggest available
                }
                check_cast_lower_bits(&left, &right)
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range, is_const)
            }
        } else if is_bool(left.value_type) and is_bool(right.value_type){
            if op >= BinaryOp.OR and op <= BinaryOp.AND
                return new BinaryExpression(left, op, right, left.value_type, binary_node.range, is_const)
        }
        if op >= BinaryOp.GT and op <= BinaryOp.NEQ {
            if is_numeric(left.value_type) and is_numeric(right.value_type){
                check_cast_lower_bits(&left, &right)
            }
            let boolean_type = PrimitiveTypes.bool
            return new BinaryExpression(left, op, right, boolean_type, binary_node.range, is_const)
        }
        if op == BinaryOp.ADD or op == BinaryOp.SUB and is_pointer(left.value_type) and right.value_type.kind == TypeKind.INT {
            return new BinaryExpression(left, op, right, left.value_type, binary_node.range, false)
        }
        this.error(ErrorKind.TYPE, "Illegal binary operation '$(dump_bin_op(op))' between types '$(this.dump_type(left.value_type))' and '$(this.dump_type(right.value_type))'", binary_node.range)
        return null
    }
    private check_unary_expr(this, expected_type: Type, unary_node: UnaryExpressionNode): UnaryExpression {
        let op = unary_node.op
        let expression = this.check_expression(expected_type, unary_node.expression)
        if this.has_errored() return null
        let ty = expression.value_type
        let is_const = expression.is_constant
        if op == UnaryOp.NEG {
            if is_numeric(ty){
                if is_int(ty){
                    ty = get_signed_int_variant(ty)
                }
                return new UnaryExpression(op, expression, ty, unary_node.range, is_const)
            }
        }
        if op == UnaryOp.NOT {
            if is_bool(ty) or is_numeric(ty)
                return new UnaryExpression(op, expression, ty, unary_node.range, is_const)
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR {
            if is_numeric(ty) or is_pointer(ty) {
                if !check_is_var(expression) {
                    this.error(ErrorKind.GEN, "Illegal unary operation $(dump_unary_op(op)) on constant", unary_node.expression.range)
                    return null
                }
                return new UnaryExpression(op, expression, ty, unary_node.range)
            }
        }
        if op == UnaryOp.ADDROF {
            if check_is_var(expression)
                return new UnaryExpression(op, expression, new PointerType(expression.value_type), unary_node.range)
        }
        if op == UnaryOp.DEL {
            if is_object(ty) or is_pointer(ty)
                return new UnaryExpression(op, expression, PrimitiveTypes.void, unary_node.range)
        }
        this.error(ErrorKind.TYPE, "Illegal unary operation $(dump_unary_op(op)) on type '$(this.dump_type(ty))'", unary_node.range)
        return null
    }
    private check_typecast_expr(this, type_expr_node: TypeCastExpressionNode): Expression {
        let dest_ty = this.check_type(type_expr_node.bound_type)
        let exp = this.check_expression(dest_ty, type_expr_node.expression)
        if this.has_errored() return null
        let val_ty = exp.value_type
        /* TODO:
            int to pointer.
            boolean to int/float.
        */
        if this.program.is_buitin_class(dest_ty, "String") {
            return new StringExpression("", [0], [exp], dest_ty, type_expr_node.range)
        }
        let is_valid_cast = false
        if is_numeric(dest_ty) and is_numeric(val_ty) {
            is_valid_cast = true    
        }
        if is_int(dest_ty) and val_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        // TODO: Re-think this, this is a temporary fix
        if is_int(val_ty) and dest_ty.kind == TypeKind.ENUM {
            is_valid_cast = true
        }
        if is_numeric(dest_ty) and this.program.is_buitin_class(val_ty, "String") {
            let call: IntrinsicCall = null
            if is_float(dest_ty) {
                call = new IntrinsicCall(Intrinsics.STR_TO_F, PrimitiveTypes.unknown, type_expr_node.range)
            } else if dest_ty.kind < TypeKind.I64 or (ARCH_WORD_SIZE < 64 and dest_ty.kind == TypeKind.INT) {
                call = new IntrinsicCall(Intrinsics.STR_TO_I, PrimitiveTypes.unknown, type_expr_node.range)
            } else {
                //TODO: I need to implement string to i128
                call = new IntrinsicCall(Intrinsics.STR_TO_L, PrimitiveTypes.unknown, type_expr_node.range)
            }
            call.args << exp
            exp = call
            is_valid_cast = true
        }
        if is_object(dest_ty) and is_object(val_ty) {
            is_valid_cast = true
        }
        if is_pointer(dest_ty) and is_pointer(val_ty) {
            is_valid_cast = true
        }
        if is_bool(dest_ty) {
            is_valid_cast = true
        }
        if !is_valid_cast {
            this.error(ErrorKind.TYPE, "Cannot cast type '$(this.dump_type(val_ty))' to '$(this.dump_type(dest_ty))'", type_expr_node.range)
            return null
        }
        return new TypeCastExpression(exp, dest_ty, type_expr_node.range)
    }
    private check_constructor_call(this, class_id: ClassId, args: ExpressionNode[], argsp: Expression[]*, range: TextRange*): String { 
        let checked_class = this.program.get_class(class_id)
        let method_id = this.get_func_from_scope(checked_class.props_scope, "constructor")
        if method_id == null {
            return "Cannot construct an object of abstract class"
        }
        let constructor = this.program.get_func(method_id)
        let construct_type = constructor.fnc_type
        let checked_args = this.fill_in_default_call_args(construct_type, constructor.params, args)
        if this.has_errored() return null
        let error: String = null
        this.check_function_call_args_match(construct_type, checked_args, &error, range)
        if error != null return error
        argsp[0] = checked_args
        return null
    }
    private check_new_expr(this, new_expr_node: NewExpressionNode): NewExpression {
        let expression_type = this.check_type(new_expr_node.parsed_type)
        if this.has_errored() return null
        let memory_type = expression_type
        if (memory_type.kind == TypeKind.RESOLVED_GENERIC) memory_type = (memory_type as ResolvedGenericType).instantiated_type
        let args: Expression[] = []
        if is_object(memory_type) {
            let range = new_expr_node.range
            let msg = this.check_constructor_call(this.program.get_class_from_type(memory_type).id, new_expr_node.args, &args, &range)
            if msg != null {
                this.error(ErrorKind.GEN, msg, range)
                return null
            }
        } else if memory_type.kind == TypeKind.PTR {
            memory_type = (memory_type as PointerType).pointee_type
            let args_count = new_expr_node.args.length
            if args_count != 1 {
                this.error(ErrorKind.GEN, "New operator expects 1 argument for pointers but got $args_count argument(s)", new_expr_node.range)
                return null
            }
            let int_ty = PrimitiveTypes.uint
            let arg = this.check_expression(int_ty, new_expr_node.args[0])
            if this.has_errored() return null
            if !this.types_are_eq(int_ty, arg.value_type) {
                this.error(ErrorKind.GEN, "New operator for pointers expects argument of type '$(this.dump_type(int_ty))' but got type '$(this.dump_type(arg.value_type))'", new_expr_node.args[0].range)
                del int_ty
                return null
            }
            args << arg
        } else {
            this.error(ErrorKind.TYPE, "New operator expects either an a pointer or an object not a(n) '$(this.dump_type(memory_type))'", new_expr_node.range)
            return null
        }
        return new NewExpression(new_expr_node.onheap, memory_type, args, expression_type, new_expr_node.range)
    }   
    private check_member_access(this, accessee: ClassId, class_name: String, member_name: String, visibility: AccessVisibility, range: TextRange) {
        if this.current_class != null {
            if visibility == AccessVisibility.PRIVATE and accessee != this.current_class {
                this.error(ErrorKind.NAME, "Property '$member_name' is defined as private and only accessible within the class $class_name", range)
            }
        } else if (visibility != AccessVisibility.PUBLIC and visibility != AccessVisibility.UNDEF) {
            this.error(ErrorKind.NAME, "Property '$member_name' is defined as $(dump_access(visibility)) and only accessible within the class $class_name", range)
        }
    }
    private check_class_member_expr(this, member_owner: Expression, member_name: String, range: TextRange): Expression {
        let member_owner_type = member_owner.value_type
        while member_owner_type.kind == TypeKind.RESOLVED_GENERIC {
            member_owner_type = (member_owner_type as ResolvedGenericType).instantiated_type
        }
        let checked_class = this.program.get_class_from_type(member_owner_type)
        let field_var_id = this.get_var_from_scope(checked_class.props_scope, member_name)
        if field_var_id != null {
            let class_field_var = this.program.get_var(field_var_id)
            let field_visibility = class_field_var.visibility
            this.check_member_access(checked_class.id, checked_class.name, member_name, field_visibility, range)
            return new ClassFieldAccessExpression(member_owner, field_var_id, class_field_var.value_type, range)
        }
        
        let method_fnc_id = this.get_func_from_scope(checked_class.props_scope, member_name)
        if method_fnc_id == null {
            this.error(ErrorKind.NAME, "Field '$member_name' doesn't exist in object of class '$(checked_class.name)'", range)
            return null
        }
        let class_method = this.program.get_func(method_fnc_id)
        let method_visibility = class_method.visibility
        this.check_member_access(checked_class.id, checked_class.name, member_name, method_visibility, range)
        return new ClassMethodAccessExpression(member_owner, method_fnc_id, class_method.fnc_type, range)
    }
    private check_enum_member_expr(this, enum_type: EnumType, member_name: String, range: TextRange): EnumFieldAccessExpression {
        let enum_id = enum_type.enum_id
        let checked_enum = this.program.get_enum(enum_id)
        let field_var_id = this.get_var_from_scope(checked_enum.scope, member_name)
        if field_var_id == null {
            this.error(ErrorKind.NAME, "Member '$member_name' doesn't exist in enum '$(checked_enum.name)'", range)
            return null
        }
        return new EnumFieldAccessExpression(enum_id, field_var_id, enum_type, range)
    }
    private check_static_class_member_expr(this, class_id: ClassId, member_name: String, range: TextRange): Expression {
        let checked_class = this.program.get_class(class_id)
        let field_var_id = this.get_var_from_scope(checked_class.static_props_scope, member_name)
        if field_var_id != null {
            let class_var_field = this.program.get_var(field_var_id)
            let field_visibility = class_var_field.visibility
            this.check_member_access(checked_class.id, checked_class.name, member_name, field_visibility, range)
            return new StaticFieldAccessExpression(class_id, field_var_id, class_var_field.value_type, range)
        }
        
        let method_fnc_id = this.get_func_from_scope(checked_class.static_props_scope, member_name)
        if method_fnc_id == null {
            this.error(ErrorKind.NAME, "Field '$member_name' doesn't exist in object of class '$(checked_class.name)'", range)
            return null
        }
        let class_method = this.program.get_func(method_fnc_id)
        let method_visibility = class_method.visibility
        this.check_member_access(checked_class.id, checked_class.name, member_name, method_visibility, range)
        return new StaticMethodAccessExpression(class_id, method_fnc_id, class_method.fnc_type, range)
    }
    private check_module_member_expr(this, module_id: ModuleId, member_name: String, range: TextRange): Expression {
        let module = this.program.get_module(module_id)
        let current_scope = this.current_scope
        this.current_scope = module.scope
        let identifer_token: IdentifierToken(member_name, range)
        let var_access_node: VarAccessExpressionNode(identifer_token)
        let value = this.check_var_access_expr(PrimitiveTypes.unknown, var_access_node)
        this.current_scope = current_scope
        return value
    }
    private check_record_member_expr(this, member_owner: Expression, member_name: String, range: TextRange): Expression {
        let record_type = member_owner.value_type as RecordType
        for let i = 0; i < record_type.element_types.length; i++ {
            if (record_type.element_names[i] == member_name) {
                return new RecordFieldAccessExpression(member_owner, i, record_type.element_types[i], range)
            }
        }
        this.error(ErrorKind.NAME, "Field '$member_name' doesn't exist on record '$(this.dump_type(record_type))'", range)
        return null
    }
    private check_member_expr(this, expected_type: Type, member_expr_node: MemberExpressionNode): Expression {
        let member_name = member_expr_node.member.value
        if (member_expr_node.expression.expr_kind == ExpressionKind.VAR_ACCESS){
            let var_name = (member_expr_node.expression as VarAccessExpressionNode).name.value
            let possible_type = this.get_type_from_scope(this.current_scope, var_name)
            if (possible_type.kind == TypeKind.ENUM){
                return this.check_enum_member_expr(possible_type as EnumType, member_name, member_expr_node.range)
            }
            if (possible_type.kind == TypeKind.OBJECT){
                let class_id = (possible_type as ObjectType).class_id
                return this.check_static_class_member_expr(class_id, member_name, member_expr_node.range)
            }
            let possible_module_id = this.get_current_module_global_scope().modules[var_name]
            if possible_module_id != null {
                return this.check_module_member_expr(possible_module_id, member_name, member_expr_node.range)
            }
        }
        let prop_owner = this.check_expression(expected_type, member_expr_node.expression)
        if this.has_errored() return null
        let prop_owner_type = prop_owner.value_type
        let prop_type = PrimitiveTypes.unknown
        if is_object(prop_owner_type) {
           return this.check_class_member_expr(prop_owner, member_name, member_expr_node.range)
        } else if(prop_owner_type.kind == TypeKind.RECORD) {
            return this.check_record_member_expr(prop_owner, member_name, member_expr_node.range)
        } else if is_pointer(prop_owner_type){
            // FIXME: Better way to express this.
            let mem_intrinsic = Intrinsics.MEMCPY 
            if member_name == "copy_from" {
                mem_intrinsic = Intrinsics.MEMCPY 
            } else if member_name == "move_from" {
               mem_intrinsic = Intrinsics.MEMMOVE
            } else if member_name == "fill_with" {
                mem_intrinsic = Intrinsics.MEMSET
            } else if member_name == "resize" {
                mem_intrinsic = Intrinsics.MEMRESIZE
            } else if member_name == "compare" {
                mem_intrinsic = Intrinsics.MEMCMP
            } else {
                this.error(ErrorKind.NAME, "intrinsic $member_name is not defined", member_expr_node.member.range)
                return null
            }
            let intrinsic_call = new IntrinsicCall(mem_intrinsic, PrimitiveTypes.unknown, member_expr_node.range) 
            intrinsic_call.args << prop_owner
            return intrinsic_call
        } else if prop_owner_type.kind == TypeKind.ARRAY and member_name == "size" {
            return new IntExpression((prop_owner_type as ArrayType).length as u64, member_expr_node.range)
        } else {
            this.error(ErrorKind.GEN, "Cannot get property '$member_name' of type '$(this.dump_type(prop_owner.value_type))'", member_expr_node.expression.range)
            return null
        }
        return new MemberExpression(prop_owner, prop_id, prop_type, member_expr_node.range)
    }
    private check_ternary_expr(this, expected_type: Type, ternary_expr_node: TernaryExpressionNode): TernaryExpression {
        let cond = this.check_condition(ternary_expr_node.cond)
        if this.has_errored() return null
        let is_true = this.check_expression(expected_type, ternary_expr_node.is_true)
        if this.has_errored() return null
        let is_true_ty = is_true.value_type
        let is_false = this.check_expression(is_true_ty, ternary_expr_node.is_false)
        if this.has_errored() return null
        let is_false_ty = is_false.value_type
        if !this.types_are_eq(is_true_ty, is_false_ty) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(is_true_ty))' from first case but got type '$(this.dump_type(is_false_ty))'", ternary_expr_node.range)
            return null
        }
        return new TernaryExpression(cond, is_true, is_false)
    }
    private check_object_index_expr(this, object: Expression, index_expr_node: ExpressionIndexNode): Expression {
        let owner_class = this.program.get_class_from_type(object.value_type)
        let method_id = this.get_func_from_scope(owner_class.props_scope, "__getitem__")
        if method_id == null {
            this.error(ErrorKind.GEN, "No operator overload for indexing operator on $(owner_class.name) object please implement method __getitem__ to use indexing in this class", index_expr_node.range)
            return null
        }
        let method_type = this.program.get_func(method_id).fnc_type
        let param_type = method_type.param_types[1]
        let index = this.check_expression(param_type, index_expr_node.index)
        if this.has_errored() return null
        if !this.types_are_eq(param_type, index.value_type) {
            this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(param_type))' but got type '$(this.dump_type(index.value_type))'", index_expr_node.index.range)
            return null
        }
        let member_expr = new ClassMethodAccessExpression(object, method_id, method_type, index_expr_node.range)
        return new CallExpression(member_expr, [index], method_type.return_type, index_expr_node.range)
    }
    private check_index_expr(this, index_expr_node: ExpressionIndexNode): Expression {
        let root_expression = this.check_expression(PrimitiveTypes.unknown, index_expr_node.expression)
        if this.has_errored() return null
        if is_object(root_expression.value_type)
            return this.check_object_index_expr(root_expression, index_expr_node)
        let index = this.check_expression(PrimitiveTypes.uint, index_expr_node.index)
        if this.has_errored() return null
        if !is_int(index.value_type) {
            this.error(ErrorKind.TYPE, "Expected an integer type for index", index_expr_node.index.range)
            return null
        }
        let value_type = PrimitiveTypes.unknown
        let root_type = root_expression.value_type
        if root_type.kind == TypeKind.PTR {
            value_type = (root_type as PointerType).pointee_type
        } else if root_type.kind == TypeKind.ARRAY {
            value_type = (root_type as ArrayType).element_type
        } else {
            this.error(ErrorKind.TYPE, "Cannot index into a value of type '$(this.dump_type(root_type))'", index_expr_node.range)
            return null
        }
        return new IndexExpression(root_expression, index, value_type, index_expr_node.range)
    }
    private get_func_from_expression(this, called: Expression): FunctionId {
        if called.expr_kind == ExpressionKind.FNC_ACCESS {
            return (called as FncAccessExpression).fnc_id
        } else if called.expr_kind == ExpressionKind.CLASS_METHOD_ACCESS {
            return (called as ClassMethodAccessExpression).fnc_id
            return this.program.get_func(method_id)
        } else if called.expr_kind == ExpressionKind.STATIC_METHOD_ACCESS {
            return (called as StaticMethodAccessExpression).fnc_id
        }
        return null
    }
    private fill_in_default_call_args(this, fnc_ty: FunctionType, func_args: FunctionParam[], args: ExpressionNode[]): Expression[] {
        let called_args: Expression[] = []
        let offset = fnc_ty.has_implicit_this ? 1 : 0
        for let i = 0; i < args.length; i++ {
            let fnc_arg_idx = i + offset
            let expected_type = fnc_ty.param_types.length > fnc_arg_idx ? fnc_ty.param_types[fnc_arg_idx] : PrimitiveTypes.unknown
            called_args << this.check_expression(expected_type, args[i])
        }
        if this.has_errored() or func_args == null return called_args
        if (func_args.length - offset) > args.length {
            for arg in func_args {
                if arg.var.value != null {
                    called_args << arg.var.value
                }
            }
        }
        return called_args
    }
    private check_function_call_args_match(this, fnc_ty: FunctionType, args: Expression[], error: String*, range: TextRange*) {
        let fnc_param_types_len = fnc_ty.param_types.length
        let check_start_offset = 0
        if fnc_ty.has_implicit_this {
            fnc_param_types_len--
            check_start_offset = 1
        }
        if fnc_param_types_len != args.length {
            error[0] = "Expected $(fnc_param_types_len) argument(s) on function call but got $(args.length)"
        }
        for let i = 0; i < args.length; i++ {
            let param_type = fnc_ty.param_types[i + check_start_offset]
            let arg_type = args[i].value_type
            if !this.types_are_eq(param_type, arg_type) {
                error[0] = "Expected type '$(this.dump_type(param_type))' but got type '$(this.dump_type(arg_type))' as function call argument"
                range[0] = args[i].range
            }
        }
    } 
    private position_args_by_name(this, fnc_ty: FunctionType, fnc_params: FunctionParam[], args: KeyValueItem[]): ExpressionNode[] {
        let call_args: ExpressionNode[] = []
        let non_labeled_args: ExpressionNode[] = []
        let start = fnc_ty.has_implicit_this ? 1 : 0
        for let i = start; i < fnc_params.length; i++ {
            call_args << null
        }
        for arg in args {
            if (arg.key == null) {
                non_labeled_args << arg.value
                continue
            }

            let arg_name_found = false
            for let i = start; i < fnc_params.length; i++ {
                if (fnc_params[i].var.name == arg.key.value) {
                    arg_name_found = true
                    if (call_args[i] == null){
                        call_args[i] = arg.value
                    } else {
                        this.error(ErrorKind.NAME, "Repeated named argument '$(arg.key.value)' on function call", arg.key.range)
                        return call_args
                    }
                    break
                }
            }
            if (!arg_name_found){
                this.error(ErrorKind.NAME, "Unknown named argument '$(arg.key.value)' on function call", arg.key.range)
                return call_args
            }
        }
        let last_index = 0
        for non_labeled_arg in non_labeled_args {
            for last_index; last_index < call_args.length; last_index++ {
                if (call_args[last_index] == null) {
                    call_args[last_index] = non_labeled_arg
                    break
                }
            }
        }
        del non_labeled_args
        return call_args
    }
    private get_call_expression_node_list(this, args: KeyValueItem[]): ExpressionNode[] {
        let call_args: ExpressionNode[] = []
        for arg in args {
            if (arg.key != null){
                this.error(ErrorKind.NAME, "Function doesn't have a named parameter", arg.key.range)
                return call_args
            }
            call_args << arg.value
        }
        return call_args
    }
    private check_and_fill_default_args(this, fnc_ty: FunctionType, func_args: FunctionParam[], call_args: ExpressionNode[]): Expression[] {
        let checked_call_args: Expression[] = []
        let offset = fnc_ty.has_implicit_this ? 1 : 0
        for let i = 0; i < call_args.length; i++ {
            let fnc_arg_idx = i + offset
            let expected_type = fnc_ty.param_types.length > fnc_arg_idx ? fnc_ty.param_types[fnc_arg_idx] : PrimitiveTypes.unknown
            if (call_args[i] == null and func_args != null){
                if (fnc_arg_idx < func_args.length) {
                    if (func_args[fnc_arg_idx].var.value != null) {
                        checked_call_args << func_args[fnc_arg_idx].var.value
                        continue
                    }
                }
            } else {
                checked_call_args << this.check_expression(expected_type, call_args[i])
            }
            if this.has_errored() return checked_call_args
        }
        return checked_call_args
    }
    private check_call_expr(this, expected_type: Type, call_expr_node: CallExpressionNode): CallExpression {
        let called = this.check_expression(PrimitiveTypes.unknown, call_expr_node.callee)
        if this.has_errored() return null
        if called.expr_kind == ExpressionKind.INTRINSIC and called.value_type.kind == TypeKind.UNKNOWN {
            return this.check_intrinsic_call(called as IntrinsicCall, call_expr_node) as CallExpression
        }
        if !is_function(called.value_type) {
            this.error(ErrorKind.TYPE, "Expected a function type for call but got '$(this.dump_type(called.value_type))'", call_expr_node.callee.range)
            return null
        }
        //TODO: Check for generic functions.
        let func_ty = called.value_type as FunctionType
        let func_params: FunctionParam[] = null
        let fnc_id = this.get_func_from_expression(called)
        if (fnc_id != null){
            let func = this.program.get_func(fnc_id)
            func_params = func.params
        }
        let call_args = func_params == null ? this.get_call_expression_node_list(call_expr_node.args) : this.position_args_by_name(func_ty, func_params, call_expr_node.args)
        if this.has_errored() return null
        let adjusted_args = this.check_and_fill_default_args(func_ty, func_params, call_args)
        if this.has_errored() return null
        let error: String = null
        let range: TextRange = call_expr_node.range
        this.check_function_call_args_match(func_ty, adjusted_args, &error, &range)
        if error != null {
            this.error(ErrorKind.TYPE, error, range)
        }
        return new CallExpression(called, adjusted_args, func_ty.return_type, call_expr_node.range)
    }
    private check_intrinsic_call(this, intrinsic_call: IntrinsicCall, call_expr_node: CallExpressionNode): IntrinsicCall {
        //Note: This assumes that intrisics always have alteast 1 arg and that call_expr_node.args has the rest of the args
        let args = call_expr_node.args
        let intrinsic_func = intrinsic_call.intrinsic
        intrinsic_call.range = call_expr_node.range
        let is_mem_grp1 = intrinsic_func == Intrinsics.MEMCPY or intrinsic_func == Intrinsics.MEMMOVE or intrinsic_func == Intrinsics.MEMCMP
        
        let uint_ty = PrimitiveTypes.uint
        let unknown_ty = PrimitiveTypes.unknown
        
        for let i = 0; i < args.length; i++ {
            if args[i].key != null {
                this.error(ErrorKind.NAME, "Intrinsic doesn't have a named parameter", args[i].key.range)
                return intrinsic_call
            }
            let expected_type = is_mem_grp1 and i == 1 ? unknown_ty : intrinsic_call.args[0].value_type
            if (intrinsic_func == Intrinsics.MEMCPY or intrinsic_func == Intrinsics.MEMMOVE) and (i == 1) {
                expected_type = uint_ty
            }
            if (intrinsic_func == Intrinsics.MEMRESIZE) and (i == 0) {
                expected_type = uint_ty
            }
            if (intrinsic_func == Intrinsics.MEMSET){
                expected_type = uint_ty
            }
            let arg_value = this.check_expression(expected_type, args[i].value)
            if this.has_errored() return null
            if expected_type.kind != TypeKind.UNKNOWN {
                if !this.types_are_eq(expected_type, arg_value.value_type) {
                    this.error(ErrorKind.TYPE, "Expected argument $i to be of type '$(this.dump_type(expected_type))' but got type '$(this.dump_type(arg_value.value_type))'", args[i].value.range)
                    return null
                }
            }
            intrinsic_call.args << arg_value
        }
        // Mem intrinsics
        if !is_pointer(intrinsic_call.args[0].value_type) {
            this.error(ErrorKind.TYPE, "Expected argument 1 to be of type to be of a pointer but got '$(this.dump_type(intrinsic_call.args[0].value_type))'", call_expr_node.callee.range)
            return null
        }
        if intrinsic_func == Intrinsics.MEMRESIZE {
            if intrinsic_call.args.length != 2 {
                this.error(ErrorKind.GEN, "Expected 2 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            intrinsic_call.value_type = intrinsic_call.args[0].value_type
        } else if is_mem_grp1 or intrinsic_func == Intrinsics.MEMSET {
            if intrinsic_call.args.length != 3 {
                this.error(ErrorKind.GEN, "Expected 3 arguments on function call but got $(intrinsic_call.args.length)", call_expr_node.range)
                return null
            }
            let exp_arg2_type = intrinsic_call.args[0].value_type
            intrinsic_call.value_type = exp_arg2_type
            if intrinsic_func == Intrinsics.MEMCMP {
                intrinsic_call.value_type = PrimitiveTypes.int
            }
        }
        return intrinsic_call
    }
    private check_int_expression(this, expected_type: Type, int_node: IntExpressionNode): IntExpression{
        let int_value = int_node.value.value
        let expr_value = new IntExpression(int_value, int_node.range)
        if is_int(expected_type){
            expr_value.value_type = expected_type
        }
        if int_value < -8 or int_value > 7 and expr_value.value_type.kind == TypeKind.I4
            expr_value.value_type = PrimitiveTypes.i8
        if int_value < -128 or int_value > 127 and expr_value.value_type.kind == TypeKind.I8
            expr_value.value_type = PrimitiveTypes.i16
        if int_value < -32768 or int_value > 32767 and expr_value.value_type.kind == TypeKind.I16
            expr_value.value_type = PrimitiveTypes.i32
        if int_value < -2147483648 or int_value > 2147483647 and (expr_value.value_type.kind == TypeKind.I32 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 32))
            expr_value.value_type = PrimitiveTypes.i64
        if int_value < -9223372036854775808 or int_value > 9223372036854775807 and (expr_value.value_type.kind == TypeKind.I64 or (expr_value.value_type.kind == TypeKind.INT and ARCH_WORD_SIZE == 64))
            expr_value.value_type = PrimitiveTypes.i128
        return expr_value
    }
    private check_float_expression(this, expected_type: Type, float_node: FloatExpressionNode): FloatExpression {
        let float_value = float_node.value.value
        let expr_value = new FloatExpression(float_value, float_node.range)
        let max_f32 = "3.4E38" as f64
        if is_float(expected_type)
            expr_value.value_type = expected_type
        if float_value < -max_f32 or float_value > max_f32 and expr_value.value_type.kind == TypeKind.F32
            expr_value.value_type = PrimitiveTypes.f64

        return expr_value
    }
    private check_char_expression(this, char_node: CharExpressionNode): IntExpression {
        let expr_value = new IntExpression(char_node.value.value as u64, char_node.range)
        expr_value.value_type = PrimitiveTypes.u8
        return expr_value
    }
    private check_string_expression(this, expected_type: Type, str_node: StringExpressionNode): StringExpression{
        let template_args: Expression[] = []
        let is_const = true
        for arg in str_node.template_args {
            template_args << this.check_expression(PrimitiveTypes.unknown, arg)
            is_const = false
        }
        if !is_u8_ptr(expected_type) {
            expected_type = this.get_type_from_scope(this.current_scope, "String")
            is_const = false
        }
        let str_exp = new StringExpression(str_node.value.value, str_node.value.fmt_indices, template_args, expected_type, str_node.range)
        str_exp.is_constant = is_const
        return str_exp
    }
    private check_range_expr(this, expected_type: Type, range_node: RangeExpressionNode): Expression {
        let unknown = PrimitiveTypes.unknown
        let left = this.check_expression(unknown, range_node.left)
        let right = this.check_expression(unknown, range_node.right)
        if left.value_type.kind == TypeKind.INT and right.value_type.kind == TypeKind.INT {
            // TODO: Check Range is an object type
            return new RangeExpression(left, right, this.get_type_from_scope(this.current_scope, "Range"))
        }
        this.error(ErrorKind.TYPE, "Cannot create a range between types '$(this.dump_type(left.value_type))' and '$(this.dump_type(right.value_type))'", TextRange.merge(range_node.left.range, range_node.right.range))
        return left
    }
    private check_expression(this, expected_type: Type, expr_node: ExpressionNode): Expression {
        if expr_node.expr_kind == ExpressionKind.INT 
            return this.check_int_expression(expected_type, expr_node as IntExpressionNode)
        if expr_node.expr_kind == ExpressionKind.FLOAT
            return this.check_float_expression(expected_type, expr_node as FloatExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CHAR
            return this.check_char_expression(expr_node as CharExpressionNode)
        if expr_node.expr_kind == ExpressionKind.STRING 
            return this.check_string_expression(expected_type, expr_node as StringExpressionNode)
        if expr_node.expr_kind == ExpressionKind.ARRAY
            return this.check_array_expression(expected_type, expr_node as ArrayExpressionNode)
        if expr_node.expr_kind == ExpressionKind.RECORD
            return this.check_record_expression(expected_type, expr_node as RecordExpressionNode)
        if expr_node.expr_kind == ExpressionKind.VAR_ACCESS
            return this.check_var_access_expr(expected_type, expr_node as VarAccessExpressionNode)
        if expr_node.expr_kind == ExpressionKind.BIN
            return this.check_bin_expr(expected_type, expr_node as BinaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.UNARY
            return this.check_unary_expr(expected_type, expr_node as UnaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.TERNARY
            return this.check_ternary_expr(expected_type, expr_node as TernaryExpressionNode)
        if expr_node.expr_kind == ExpressionKind.CAST
            return this.check_typecast_expr(expr_node as TypeCastExpressionNode)
        if expr_node.expr_kind == ExpressionKind.NEW
            return this.check_new_expr(expr_node as NewExpressionNode)
        if expr_node.expr_kind == ExpressionKind.RECORD_FIELD_ACCESS
            return this.check_member_expr(expected_type, expr_node as MemberExpressionNode)
        if expr_node.expr_kind == ExpressionKind.INDEX
            return this.check_index_expr(expr_node as ExpressionIndexNode)
        if expr_node.expr_kind == ExpressionKind.CALL
            return this.check_call_expr(expected_type, expr_node as CallExpressionNode)
        if expr_node.expr_kind == ExpressionKind.RANGE
            return this.check_range_expr(expected_type, expr_node as RangeExpressionNode)
        if expr_node.expr_kind == ExpressionKind.MATCH
            return this.check_match_expr(expected_type, expr_node as MatchExpressionNode)
        return null
    }
    private check_condition(this, cond_node: ExpressionNode): Expression {
       let condition = this.check_expression(PrimitiveTypes.unknown, cond_node)
       if this.has_errored() return null
       return !is_bool(condition.value_type) ? cast_exp_to_type(condition, PrimitiveTypes.bool) : condition
    }
    private check_match_expr(this, expected_type: Type, match_node: MatchExpressionNode): MatchExpression {
        let subject = this.check_expression(PrimitiveTypes.unknown, match_node.subject)
        if this.has_errored() return null
        if is_null_expression(subject){
            this.error(ErrorKind.TYPE, "Cannot match on constant 'null'", match_node.subject.range)
            return null
        }
        let use_ifs = is_object(subject.value_type)
        let match_expression = new MatchExpression(subject, use_ifs)
        let result_type = PrimitiveTypes.unknown
        for case in match_node.cases {
            let expression: Expression = null
            let match_case_kind = MatchCaseKind.EEQ
            if (use_ifs) {
                let bin_exp: BinaryExpressionNode(match_node.subject, BinaryOp.EEQ, case.condition)
                expression = this.check_object_binary_expr(subject, bin_exp, null)
                if this.has_errored() return null
                match_case_kind = MatchCaseKind.VAL
                if !is_bool(expression.value_type) {
                    this.error(ErrorKind.TYPE, "Operator overload == for '$(this.dump_type(subject.value_type))' should return a boolean to be used in match expression", case.condition.range)
                    return null
                }
            } else {
                expression = this.check_expression(subject.value_type, case.condition)
                if this.has_errored() return null
                if !this.types_are_eq(subject.value_type, expression.value_type){
                    this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(subject.value_type))' from match expression subject but got type '$(this.dump_type(expression.value_type))'", case.condition.range)
                    return null
                }
            }
            let block = this.check_block(case.block, null, true)
            if this.has_errored() return null
            let case_type = block.yields != null ? block.yields.value_type : PrimitiveTypes.void
            if result_type.kind == TypeKind.UNKNOWN {
                result_type = case_type
            } else if !this.types_are_eq(result_type, case_type){
                this.error(ErrorKind.TYPE, "Expected match case block to yield '$(this.dump_type(result_type))' but yielded '$(this.dump_type(case_type))'", case.condition.range)
                return null
            }
            match_expression.cases << new MatchExpressionCase(match_case_kind, expression, block)
        }
        if match_node.else_block == null {
            this.error(ErrorKind.GEN, "Non-exhaustable match expression, expected an else-case", match_node.range)
            return null
        } else {
            let block = this.check_block(match_node.else_block, null, true)
            let case_type = block.yields != null ? block.yields.value_type : PrimitiveTypes.void
            if !this.types_are_eq(result_type, case_type){
                this.error(ErrorKind.TYPE, "Expected match else-case block to yield '$(this.dump_type(result_type))' but yielded '$(this.dump_type(case_type))'", match_node.range)
                return null
            }
            match_expression.else_block = block
        }
        match_expression.value_type = result_type
        return match_expression
    }
    private check_if_stamement(this, if_stmt_node: IfStatementNode): IfStatement {
        let condition = this.check_condition(if_stmt_node.condition)
        let block = this.check_block(if_stmt_node.block)
        let else_block = if_stmt_node.else_block != null ? this.check_block(if_stmt_node.else_block) : null
        return new IfStatement(condition, block, else_block)
    }
    private check_var_declaration(this, var_decl_node: VarDeclarationStatement): VarDeclaration {
        let name = var_decl_node.var_name.value
        if this.is_constant_in_scope(this.current_scope, name) {
            this.error(ErrorKind.NAME, "Illegal re-declaration of const '$name'", var_decl_node.var_name.range)
            return null
        }
        let var_type = var_decl_node.var_type != null ? this.check_type(var_decl_node.var_type) : PrimitiveTypes.unknown
        if this.has_errored() return null
        if var_decl_node.value == null and var_type.kind == TypeKind.UNKNOWN {
            this.error(ErrorKind.GEN, "Variable '$name' has no type", var_decl_node.var_name.range)
            return null
        }
        let value = var_decl_node.value != null ? this.check_expression(var_type, var_decl_node.value) : null
        if this.has_errored() return null
        if value != null {
            if is_null_expression(value) and value.value_type.kind == TypeKind.UNKNOWN {
                this.error(ErrorKind.TYPE, "Cannot declare a value as null without any type hint for future usage", var_decl_node.range)
                return null
            }
            if var_type.kind != TypeKind.UNKNOWN and !this.types_are_eq(var_type, value.value_type) {
                this.error(ErrorKind.TYPE, "Expected type '$(this.dump_type(var_type))' but got type '$(this.dump_type(value.value_type))' on variable declaration", var_decl_node.range)
                return null
            }
            if var_type.kind == TypeKind.UNKNOWN {
                var_type = value.value_type
            }
            if var_type.kind == TypeKind.VOID {
                this.error(ErrorKind.TYPE, "Cannot declare a variable of type void", var_decl_node.range)
                return null
            }
        }
        let current_scope = this.program.get_scope(this.current_scope)
        if current_scope.vars[name] != null {
            let var_type = var_decl_node.is_const ? "constant" : "variable"
            this.error(ErrorKind.NAME, "Illegal re-declaration of already declared $var_type '$name'", var_decl_node.var_name.range)
            return null
        }
        let var = this.declare_var_within_scope(this.current_scope, name, value, var_type, AccessVisibility.UNDEF, var_decl_node.is_const)
        return new VarDeclaration(var, var_decl_node.var_name.range)
    }
    private check_for_in_statement(this, for_in_stmt_node: ForInStatementNode): ForInStatement {
        let for_scope = this.create_child_scope_within_scope(this.current_scope)
        this.current_scope = for_scope.id
        let prev_in_loop = this.in_loop
        let iterator = this.check_expression(PrimitiveTypes.unknown, for_in_stmt_node.iterator)
        if this.has_errored() return null
        if !is_object(iterator.value_type) {
            this.error(ErrorKind.TYPE, "Iterator has to be an object", for_in_stmt_node.iterator.range)
            return null
        }
        let iterator_class = this.program.get_class_from_type(iterator.value_type)
        let iter_method_id = this.get_func_from_scope(iterator_class.props_scope, "__iter__")
        if iter_method_id == null {
            this.error(ErrorKind.TYPE, "Iterator type has to have __iter__ as method", for_in_stmt_node.iterator.range)
            return null
        }
        let iter_item_name =  for_in_stmt_node.it_name.value
        if this.has_errored() return null
        let iteratable_type = this.program.get_func(iter_method_id).fnc_type.return_type
        let iteratable_class = this.program.get_class_from_type(iteratable_type)
        let next_method_id = this.get_func_from_scope(iteratable_class.props_scope, "next")
        let iter_item_type = this.program.get_func(next_method_id).fnc_type.return_type
        this.in_loop = true
        let var = this.declare_var_within_scope(this.current_scope, iter_item_name, null, iter_item_type, AccessVisibility.UNDEF, false)
        let for_block = this.check_block(for_in_stmt_node.block, for_scope, false)
        let for_in_stmt = new ForInStatement(new VarDeclaration(var, for_in_stmt_node.it_name.range), iterator, iteratable_type as ObjectType, for_block)
        this.in_loop = prev_in_loop
        return for_in_stmt
    }
    private check_for_statement(this, for_stmt_node: ForStatementNode): ForStatement {
        let for_stmt = new ForStatement()
        let for_scope = this.create_child_scope_within_scope(this.current_scope)
        this.current_scope = for_scope.id
        let prev_in_loop = this.in_loop
        this.in_loop = true
        if for_stmt_node.initialization != null
            for_stmt.initialization = this.check_statement(for_stmt_node.initialization)
        if for_stmt_node.condition != null
            for_stmt.condition = this.check_condition(for_stmt_node.condition)
        if for_stmt_node.update != null
            for_stmt.update = this.check_expression(PrimitiveTypes.unknown, for_stmt_node.update)
        
        for_stmt.block = this.check_block(for_stmt_node.block, for_scope, false)
        this.in_loop = prev_in_loop
        return for_stmt
    }
    private check_while_statment(this, while_stmt_node: WhileStatementNode): WhileStatement {
        let condition = this.check_condition(while_stmt_node.condition)
        let prev_in_loop = this.in_loop
        this.in_loop = true
        let block = this.check_block(while_stmt_node.block)
        this.in_loop = prev_in_loop
        return new WhileStatement(condition, block)
    }
    private check_can_break(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal break outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.BREAK)
    }
    private check_can_continue(this, stmt_node: StatementNode): Statement {
        if !this.in_loop {
            this.error(ErrorKind.GEN, "Illegal continue outside of loop", stmt_node.range)
            return null
        }
        return new Statement(StatementKind.CONTINUE)
    }
    private check_can_return(this, return_stmt: ReturnStatementNode): ReturnStatement {
        let expr = return_stmt.value
        let current_function = this.program.get_func(this.current_function)
        let current_function_return_type = current_function.fnc_type.return_type
        let rt_stmt = new ReturnStatement()
        if expr != null {
            let rt_value = this.check_expression(current_function_return_type, expr)
            if this.has_errored() return null   
            if !this.types_are_eq(current_function_return_type, rt_value.value_type) {
                this.error(ErrorKind.TYPE, "Expected return type of '$(this.dump_type(current_function_return_type))' but got return type of '$(this.dump_type(rt_value.value_type))'", expr.range)
                return null
            }
            rt_stmt.return_value = rt_value
        } else if current_function_return_type.kind != TypeKind.VOID {
            this.error(ErrorKind.TYPE, "Function return type is not void", return_stmt.range)
            return null
        }
        return rt_stmt
    }
    private check_statement(this, stmt_node: StatementNode): Statement {
        if stmt_node.kind == StatementKind.IF
            return this.check_if_stamement(stmt_node as IfStatementNode)
        if stmt_node.kind == StatementKind.VAR
            return this.check_var_declaration(stmt_node as VarDeclarationStatement)
        if stmt_node.kind == StatementKind.FOR
            return this.check_for_statement(stmt_node as ForStatementNode)
        if stmt_node.kind == StatementKind.FOR_IN
            return this.check_for_in_statement(stmt_node as ForInStatementNode)
        if stmt_node.kind == StatementKind.WHILE
            return this.check_while_statment(stmt_node as WhileStatementNode)
        if stmt_node.kind == StatementKind.CONTINUE
            return this.check_can_continue(stmt_node)
        if stmt_node.kind == StatementKind.BREAK
            return this.check_can_break(stmt_node)
        if stmt_node.kind == StatementKind.RETURN
            return this.check_can_return((stmt_node as ReturnStatementNode))
        if stmt_node.kind == StatementKind.EXPRESSION
            return this.check_expression(PrimitiveTypes.unknown, stmt_node as ExpressionNode)
        panic("Unknown statement kind")
        return null
    }
    private check_block(this, block_node: BlockNode, block_scope: Scope = null, yields: bool = false): Block {
        let block = new Block(block_node.range)
        block_scope = block_scope != null ? block_scope : this.create_child_scope_within_scope(this.current_scope) //TODO: Use ?? in the future
        this.current_scope = block_scope.id
        let stmt: Statement = null
        for stmt_node in block_node.statements {
            stmt = this.check_statement(stmt_node)
            if this.has_errored() return null
            block.statements << stmt
            if stmt.kind == StatementKind.RETURN {
                block.returns = true
                break
            }
            if stmt.kind == StatementKind.IF {
                let if_stmt = stmt as IfStatement
                if if_stmt.else_block != null {
                    if if_stmt.block.returns and if_stmt.else_block.returns {
                        block.returns = true
                        break
                    }
                }
            }
            if stmt.kind == StatementKind.CONTINUE {
                block.continues = true
                break
            }
            if stmt.kind == StatementKind.BREAK {
                block.breaks = true
                break
            }
        }
        if stmt != null {
            if yields and (stmt.kind == StatementKind.EXPRESSION) {
                block.yields = stmt as Expression
                block.statements.pop()
            }
        }
        this.current_scope = block_scope.parent
        return block
    }
}