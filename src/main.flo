import "utils"
import "error"
import "compiler"
import "lexer"
import "parser"
import "typechecker"
import "codegen"
import "flags"
import LLVMGetDefaultTargetTriple in "llvm/targetMachine"
fnc system(cmd: u8*)
fnc main(argc: int, argv: u8**): int {
    let COMPILER_VERSION = "0.0.1"
    let code: int = 0
    let show_help: FlagBool("h", "Show this help message")
    let emit_type: FlagString("-emit", "Emit output in a particular format. Options are:\n\t\t • exe - Generates an executable.\n\t\t • llvm-ir - Generates a file containing LLVM IR.\n\t\t • llvm-bc - Generates a file containing LLVM bitcode.\n\t\t • obj - Generates an object file\n\t\t • asm - Generates Assembly code.", "exec")
    let output_fn: FlagString("o", "Specify file to put the output into", "output")
    let rt_path: FlagString("I", "Specify runtime directory", "/usr/local/flo/lib/")
    let target_triple: FlagString("-target", "Compile to specific target triple", String.from_cstring(LLVMGetDefaultTargetTriple()))
    let link_libs: FlagString("l", "Specify a library to link against (should be a comma seperated list)")
    let opt_level: FlagInt("O", "Specify the compiler's optimization level", 1)
    let show_version: FlagBool("v", "Show version")

    let filename = parse_flags(argc, argv)
    if show_version.value {
        flo_println(COMPILER_VERSION)
        return 0
    }
    if show_help.value {
        flo_print("Usage: ")
        flo_print(String.from_cstring(argv[0]))
        flo_println(" [OPTIONS]? <file>\n\nOPTIONS:\n")
        print_flags()
        return 0
    }
    if filename == null {
        print_message_error(ErrorKind.GEN, "No input file specified.")
        return 1
    }
    let compiler = new Compiler()
    if (!compiler.set_std_path(rt_path.value)){
        print_message_error(ErrorKind.IO, "Runtime directory not found '$(rt_path.value)'")
        return 1
    }
    let file_id = compiler.register_file(filename)
    if (!compiler.set_current_file(file_id)) {
        print_message_error(ErrorKind.IO, "No such file or directory: '$filename'")
        return 1
    }
    /***** Lexing ******/
    let tokens = Lexer.tokenize(compiler.current_file_contents, compiler.errors)
    if (compiler.print_errors()) return 1
    /***** Parsing *****/
    let module_node = Parser.parse(tokens, compiler.errors)
    if (compiler.print_errors()) return 1
    /**** Analyzing ****/
    let program = TypeChecker.check(module_node, compiler, filename)
    if (compiler.print_errors()) return 1       
    /**** Codegen ****/
    let flo_module = CodeGen.codegen(program)
    /**** Misc ****/
    flo_module.run_passes(opt_level.value as int)
    flo_module.set_target_machine(target_triple.value)
    if emit_type.value == "exe" {
        let tmp_file = "/tmp/output.o"
        flo_module.write_obj(tmp_file)
        let link_libs_value = link_libs.value ? "-l$(link_libs.value)" : ""
        let linker_exec = "clang-15"
        let target_option = "-target $link_libs_value"
        system("$linker_exec -no-pie $target_option /tmp/output.o $link_libs -o $(output_fn.value)")
        del target_option
        del link_libs_value
        del linker_exec
    } else if emit_type.value == "llvm-ir" {
        flo_module.write_ir("$(output_fn.value)")
    } else if emit_type.value == "llvm-bc" {
        flo_module.write_bc("$(output_fn.value)")
    } else if emit_type.value == "obj" {
        flo_module.write_obj("$(output_fn.value)")
    } else if emit_type.value == "asm" {
        flo_module.write_asm("$(output_fn.value)")
    } else {
        code = flo_module.exec()
    }
    del module_node
    return code
}