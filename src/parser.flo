import TokType, ExpressionKind, StatementKind, TypeKind, ForKind, BinaryOp, UnaryOp, ACCESS_ATTR in "types"
import FloRange in "utils"
import FloError, ErrorKind in "error"
import Token, IntToken, FloatToken, StrToken, CharToken, IdentifierToken in "lexer"
class Node {
    range: FloRange
    constructor(this, range: FloRange){
        this.range = range
    }
}
class TypeNode(Node) {
    kind: TypeKind
    constructor(this, kind: TypeKind, range: FloRange){
        super(range)
        this.kind = kind
    }
}
class RecordTypeNode (TypeNode) {
    name: IdentifierToken
    generic_args: TypeNode[]
    constructor(this, name: IdentifierToken, range: FloRange) {
        super(TypeKind.RECORD, range)
        this.name = name
        this.generic_args = []
        
    }
}
class FunctionTypeNode (TypeNode) {
    args: TypeNode[]
    return_type: TypeNode
    constructor(this, range: FloRange){
        super(TypeKind.FNC, range)
        this.args = []
    }
}
class PointerTypeNode (TypeNode) {
    pointee_type: TypeNode
    constructor(this, pointee_type: TypeNode, range: FloRange){
        super(TypeKind.PTR, range)
        this.pointee_type = pointee_type
    }
}
class StatementNode(Node) {
    kind: StatementKind
    constructor(this, kind: StatementKind, range: FloRange){
        super(range)
        this.kind = kind
    }
}
class BlockNode(Node) {
    statements: StatementNode[]
    constructor(this, range: FloRange){
        super(range)
        this.statements = []
    }
}
class ExpressionNode (StatementNode) {
    expr_kind: ExpressionKind
    constructor(this, expr_kind: ExpressionKind, range: FloRange){
        super(StatementKind.EXPRESSION, range)
        this.expr_kind = expr_kind
    }
}
class ArrayTypeNode (TypeNode) {
    element_type: TypeNode
    length: ExpressionNode
    constructor(this, element_type: TypeNode, length: ExpressionNode, range: FloRange){
        super(TypeKind.ARRAY, range)
        this.element_type = element_type
        this.length = length
    }
}
class IntExpressionNode (ExpressionNode) {
    value: IntToken
    constructor(this, value: IntToken){
        super(ExpressionKind.INT, value.range)
        this.value = value
    }
}
class FloatExpressionNode (ExpressionNode) {
    value: FloatToken
    constructor(this, value: FloatToken){
        super(ExpressionKind.FLOAT, value.range)
        this.value = value
    }
}
class CharExpressionNode (ExpressionNode) {
    value: CharToken
    constructor(this, value: CharToken){
        super(ExpressionKind.CHAR, value.range)
        this.value = value
    }
}
class StringExpressionNode (ExpressionNode) {
    value: StrToken
    template_args: ExpressionNode[]
    constructor(this, value: StrToken, template_args: ExpressionNode[]){
        super(ExpressionKind.STRING, value.range)
        this.value = value
        this.template_args = template_args
    }
}
class VarAccessExpressionNode (ExpressionNode) {
    name: IdentifierToken
    constructor(this, name: IdentifierToken){
        super(ExpressionKind.ACCESS, name.range)
        this.name = name
    }
}
class ArrayExpressionNode (ExpressionNode) {
    elements: ExpressionNode[]
    constructor(this, range: FloRange){
        super(ExpressionKind.ARRAY, range)
        this.elements = []
    }
}
class NewExpressionNode (ExpressionNode) {
    parsed_type: TypeNode
    onheap: bool
    args: ExpressionNode[]
    constructor(this, parsed_type: TypeNode, range: FloRange){
        this.parsed_type = parsed_type
        this.onheap = true
        super(ExpressionKind.NEW, range)
        this.args = []
    }
}
class ExpressionIndexNode (ExpressionNode) {
    expression: ExpressionNode
    index: ExpressionNode
    constructor(this, expression: ExpressionNode, index: ExpressionNode, range: FloRange){
        this.expression = expression
        this.index = index
        super(ExpressionKind.INDEX, range)
    } 
}
class MemberExpressionNode (ExpressionNode) {
    expression: ExpressionNode
    member: IdentifierToken
    constructor(this, expression: ExpressionNode, member: IdentifierToken, range: FloRange){
        super(ExpressionKind.MEMBER, range)
        this.expression = expression
        this.member = member
    }
}
class CallExpressionNode (ExpressionNode) {
    callee: ExpressionNode
    args: ExpressionNode[]
    constructor(this, callee: ExpressionNode, range: FloRange) {
        super(ExpressionKind.CALL, range)
        this.callee = callee
        this.args = []
    }
}
class TypeCastExpressionNode (ExpressionNode) {
    expression: ExpressionNode
    bound_type: TypeNode
    constructor(this, expression: ExpressionNode, bound_type: TypeNode){
        super(ExpressionKind.CAST, FloRange.merge(expression.range, bound_type.range))
        this.expression = expression
        this.bound_type = bound_type
    }
}
class BinaryExpressionNode (ExpressionNode) {
    lhs: ExpressionNode
    op: BinaryOp
    rhs: ExpressionNode
    constructor(this, left: ExpressionNode, op: BinaryOp, right: ExpressionNode){
        super(ExpressionKind.BIN, FloRange.merge(left.range, right.range))
        this.lhs = left
        this.op = op
        this.rhs = right
    }
}
class TernaryExpressionNode (ExpressionNode) {
    cond: ExpressionNode
    is_true: ExpressionNode
    is_false: ExpressionNode
    constructor(this, cond: ExpressionNode, is_true: ExpressionNode, is_false: ExpressionNode){
        super(ExpressionKind.TERNARY, FloRange.merge(cond.range, is_false.range))
        this.cond = cond
        this.is_true = is_true
        this.is_false = is_false
        this.range = FloRange.merge(is_true.range, is_false.range)
    }
}
class UnaryExpressionNode (ExpressionNode) {
    op: UnaryOp
    expression: ExpressionNode
    constructor(this, op: UnaryOp, expression: ExpressionNode, range: FloRange){
        this.op = op
        this.expression = expression
        super(ExpressionKind.UNARY, range)
    }
}
/* Can be either 'as' or 'is' unary expression */
class IfStatementNode (StatementNode) {
    condition: ExpressionNode
    block: BlockNode
    else_block: BlockNode
    constructor(this, range: FloRange){
        super(StatementKind.IF, range)
        this.else_block = null
    }
}
class WhileStatementNode (StatementNode) {
    condition: ExpressionNode
    block: BlockNode
    constructor(this, range: FloRange){
        super(StatementKind.WHILE, range)
    }
}
class ForStatementNode (StatementNode) {
    initialization: StatementNode
    condition: ExpressionNode
    incr_decr: StatementNode
    iterator: ExpressionNode
    for_kind: ForKind
    it_name: IdentifierToken
    block: BlockNode
    constructor(this, range: FloRange){
        this.initialization = null
        this.condition = null
        this.incr_decr = null
        this.for_kind = ForKind.DEF
        super(StatementKind.FOR, range)
    }
}
class ReturnStatementNode (StatementNode) {
    value: ExpressionNode
    constructor(this, range: FloRange){
        this.value = null
        super(StatementKind.RETURN, range)
    }
}
class VarDeclarationStatement (StatementNode) {
    var_name: IdentifierToken
    var_type: TypeNode
    value: ExpressionNode
    constructor(this, range: FloRange){
        super(StatementKind.VAR, range)
        this.var_type = null
        this.value = null
    }
}

class ConstDeclarationStatement (StatementNode) {
    const_name: IdentifierToken
    const_type: TypeNode
    value: ExpressionNode
    constructor(this, range: FloRange){
        super(StatementKind.CONST, range)
        this.const_type = null
    }
}
class ArgNode {
    name: IdentifierToken
    parsed_type: TypeNode
    default: ExpressionNode
    constructor(this, name: IdentifierToken){
        this.name = name
        this.parsed_type = null
        this.default = null
    }
}
class FunctionDeclarationNode {
    name: IdentifierToken
    args: ArgNode[]
    block: BlockNode
    return_type: TypeNode
    is_external: bool
    constructor(this){
        this.args = []
        this.is_external = false
    }
}
class MethodNode {
    name: IdentifierToken
    args: ArgNode[]
    block: BlockNode
    access_modifier: ACCESS_ATTR
    return_type: TypeNode
    is_static: bool
    is_abstract: bool
    constructor(this, name: IdentifierToken){
        this.name = name
        this.args = []
        this.is_static = true
        this.is_abstract = false
    }
}

class FieldNode {
    name: IdentifierToken
    access_modifier: ACCESS_ATTR
    initializer: ExpressionNode
    parsed_type: TypeNode
    constructor(this, name: IdentifierToken){
        this.name = name
        this.initializer = null
    }
}
class GenericParameterNode {
    name: IdentifierToken
    constructor(this, name: IdentifierToken){
        this.name = name
    }
}
class ClassDeclarationNode {
    name: IdentifierToken
    generic_parameters: GenericParameterNode[]
    parent: RecordTypeNode
    fields: FieldNode[]
    methods: MethodNode[]
    constructor(this, name: IdentifierToken) {
        this.name = name
        this.fields = []
        this.methods = []
        this.generic_parameters = []
        this.parent = null
    }
}
class EnumNodeField {
    name: IdentifierToken
    initializer: ExpressionNode
    constructor(this, name: IdentifierToken){
        this.name = name
        this.initializer = null
    }
}
class EnumNode {
    name: IdentifierToken
    fields: EnumNodeField[]
    variant: TypeNode
    constructor(this, name: IdentifierToken){
        this.name = name
        this.fields = []
        this.variant = null
    }
}
class ImportClause {
    original_identifer: IdentifierToken
    renamed_identifer: IdentifierToken
    constructor(this, original_identifer: IdentifierToken){
        this.original_identifer = original_identifer
        this.renamed_identifer = null
    }
}
class ImportNode {
    import_list: ImportClause[]
    module_path: StrToken
    module_name: IdentifierToken
    constructor(this){
        this.import_list = []
        this.module_name = null
    }
}
class TypeAliasNode {
    name: IdentifierToken
    parsed_type: TypeNode
    constructor(this, name: IdentifierToken){
        this.name = name
    }
}
class ModuleAST {
    functions: FunctionDeclarationNode[]
    classes: ClassDeclarationNode[]
    enums: EnumNode[]
    imports: ImportNode[] 
    consts: ConstDeclarationStatement[] 
    vars: VarDeclarationStatement[] 
    type_aliases: TypeAliasNode[] 
    constructor(this) {
        this.functions = []
        this.classes = []
        this.imports = []
        this.consts = []
        this.vars = []
        this.enums = []
        this.type_aliases = []
    }
}
class Parser {
    private tokens: Token[]
    private errors: FloError[]
    private current_token: Token
    private idx: int
    constructor(this, tokens: Token[], errors: FloError[]){
        this.tokens = tokens
        this.errors = errors
        this.idx = -1
    }
    private can_parse(this): bool{
        return this.current_token.ttype != TokType.EOF and this.errors.length == 0
    }
    private error(this, message: string){
        this.errors << new FloError(ErrorKind.SYNTAX, message, this.current_token.range)
    }    
    private advance(this){
        if this.idx < this.tokens.length
            this.current_token = this.tokens[++this.idx]
    }
    private peek(this, offset = 1): Token{
        let peek_idx = this.idx + offset
        if peek_idx < this.tokens.length
            return this.tokens[peek_idx]
        return this.tokens[this.tokens.length - 1]
    }
    private eat(this, token_type: TokType): Token {
        let current_token = this.current_token
        if token_type == current_token.ttype {
            this.advance()
            return current_token
        } else {
            if token_type == TokType.IDENTIFER 
                this.error("Expected an Identifier")
            else if token_type == TokType.EQ 
                this.error("Expected '='")
            else if token_type == TokType.COL 
                this.error("Expected ':'")
            else if token_type == TokType.LPAR 
                this.error("Expected '('")
            else if token_type == TokType.RPAR 
                this.error("Expected ')'")
            else if token_type == TokType.LBRACE 
                this.error("Expected '{'")
            else if token_type == TokType.RBRACE 
                this.error("Expected '}'")
            else if token_type == TokType.COMMA 
                this.error("Expected ','")
            else if token_type == TokType.LT 
                this.error("Expected '<'")
            else if token_type == TokType.GT 
                this.error("Expected '>'")
            else if token_type == TokType.ARROW 
                this.error("Expected '->'")
        }
        return new Token(TokType.EOF, current_token.range)
    }
    private new_lines(this) {
        while this.current_token.ttype == TokType.LN and this.can_parse()
            this.advance()
    }
    private parse_type_list(this, type_nodes: TypeNode[]) {
        type_nodes << this.parse_type()
        while this.current_token.ttype == TokType.COMMA and this.can_parse() {
            this.advance()
            type_nodes << this.parse_type()
        }
    }
    private parse_object_type(this): RecordTypeNode {
        let identifier_tok = this.eat(TokType.IDENTIFER) as IdentifierToken
        let object_type_node = new RecordTypeNode( identifier_tok, identifier_tok.range)
        if this.current_token.ttype == TokType.LT {
            this.advance()
            this.parse_type_list(object_type_node.generic_args)
            let end_range = this.current_token.range
            if this.current_token.ttype == TokType.SR {
                this.current_token.ttype = TokType.GT
            } else {
                this.eat(TokType.GT)
            }
            object_type_node.range = FloRange.merge(object_type_node.range, end_range)
        }
        return object_type_node
    }
    private parse_function_type(this): FunctionTypeNode {
        let fnc_type_node = new FunctionTypeNode(this.current_token.range)
        this.advance()
        if this.current_token.ttype != TokType.RPAR
            this.parse_type_list(fnc_type_node.args)
        this.eat(TokType.RPAR)
        this.eat(TokType.ARROW)
        fnc_type_node.return_type = this.parse_type()
        fnc_type_node.range = FloRange.merge(fnc_type_node.range, fnc_type_node.return_type.range)
        return fnc_type_node
    }
    private parse_type(this): TypeNode {
        let type_node: TypeNode = null
        if this.current_token.ttype == TokType.IDENTIFER
            type_node = this.parse_object_type()
        else if this.current_token.ttype == TokType.LPAR
            type_node = this.parse_function_type()
        else if this.current_token.ttype == TokType.LBRACKET {
            let rec_node = new RecordTypeNode(new IdentifierToken("Map", this.current_token.range) as IdentifierToken, this.current_token.range)
            this.advance()
            rec_node.generic_args << this.parse_type()
            this.eat(TokType.COL)
            rec_node.generic_args << this.parse_type()
            this.eat(TokType.RBRACKET)
            type_node = rec_node
        }
        
        while this.current_token.ttype == TokType.LBRACKET or this.current_token.ttype == TokType.POW or this.current_token.ttype == TokType.MULT and this.can_parse() {
            if this.current_token.ttype == TokType.LBRACKET {
                this.advance()
                if this.current_token.ttype == TokType.RBRACKET {
                    let rec_node = new RecordTypeNode(new IdentifierToken("Array", this.current_token.range) as IdentifierToken, this.current_token.range)
                    rec_node.generic_args << type_node
                    type_node = rec_node
                } else {
                    type_node = new ArrayTypeNode(type_node, this.parse_expression(), this.current_token.range)
                }
                type_node.range = FloRange.merge(type_node.range, this.current_token.range)
                this.eat(TokType.RBRACKET)
            } else {
                type_node = new PointerTypeNode(type_node, FloRange.merge(type_node.range, this.current_token.range))
                if this.current_token.ttype == TokType.POW 
                    type_node = new PointerTypeNode(type_node, FloRange.merge(type_node.range, this.eat(TokType.POW).range))
                else
                    this.advance()
            }
        }
        return type_node
    }
    private parse_expression_list(this, expressions: ExpressionNode[]) {
        this.new_lines()
        expressions << this.parse_expression()
        this.new_lines()
        while this.current_token.ttype == TokType.COMMA and this.can_parse(){
            this.advance()
            this.new_lines()
            expressions << this.parse_expression()
        }
        this.new_lines()
    }
    private parse_array_expression(this): ArrayExpressionNode {
        let array_expression = new ArrayExpressionNode(this.current_token.range)
        this.advance()
        if this.current_token.ttype != TokType.RBRACKET
            this.parse_expression_list(array_expression.elements)
        array_expression.range = FloRange.merge(array_expression.range, this.eat(TokType.RBRACKET).range)
        return array_expression
    }
    private parse_new_expression(this): NewExpressionNode {
        let start_range = this.current_token.range
        this.advance()
        let new_node = new NewExpressionNode(this.parse_type(), start_range)
        this.eat(TokType.LPAR)
        if this.current_token.ttype != TokType.RPAR and this.can_parse()
            this.parse_expression_list(new_node.args)
        new_node.range = FloRange.merge(new_node.range, this.eat(TokType.RPAR).range)
        return new_node
    }
    private parse_string(this): StringExpressionNode {
        let strtoken = this.eat(TokType.STR) as StrToken
        let tmp_parser: Parser(null, this.errors)
        let template_args: ExpressionNode [] = []
        for let i = 0; i < strtoken.args.length and this.can_parse(); i++ {
            tmp_parser.tokens = strtoken.args[i]
            tmp_parser.idx = -1
            tmp_parser.advance()
            template_args << tmp_parser.parse_expression()
        }
        return new StringExpressionNode(strtoken, template_args)
    }
    private parse_atom(this): ExpressionNode {
        if this.current_token.ttype == TokType.STR
            return this.parse_string()
        else if this.current_token.ttype == TokType.INT
            return new IntExpressionNode(this.eat(TokType.INT) as IntToken)
        else if this.current_token.ttype == TokType.FLOAT
            return new FloatExpressionNode(this.eat(TokType.FLOAT) as FloatToken)
        else if this.current_token.ttype == TokType.CHAR
            return new CharExpressionNode(this.eat(TokType.CHAR) as CharToken)
        else if this.current_token.ttype == TokType.IDENTIFER 
            return new VarAccessExpressionNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        else if this.current_token.ttype == TokType.LBRACKET 
            return this.parse_array_expression()
        else if this.current_token.ttype == TokType.NEW_KW
            return this.parse_new_expression()
        else if this.current_token.ttype == TokType.LPAR {
            this.advance()
            let expression = this.parse_expression()
            this.eat(TokType.RPAR)
            return expression
        } else
            this.error("Expected an Expression value")
        return new ExpressionNode(ExpressionKind.ACCESS, this.current_token.range)
    }
    private parse_index_expression(this, expression: ExpressionNode): ExpressionIndexNode {
        this.eat(TokType.LBRACKET)
        let index_expression = new ExpressionIndexNode(expression, this.parse_expression(), this.current_token.range)
        index_expression.range = FloRange.merge(expression.range, this.eat(TokType.RBRACKET).range)
        return index_expression
    }
    private parse_call_expression(this, expression: ExpressionNode): CallExpressionNode {
        this.eat(TokType.LPAR)
        let call_expression = new CallExpressionNode(expression, this.current_token.range)
        if this.current_token.ttype != TokType.RPAR
            this.parse_expression_list(call_expression.args)
        call_expression.range = FloRange.merge(expression.range, this.eat(TokType.RPAR).range)
        return call_expression
    }
    private parse_member_expression(this, expression: ExpressionNode): MemberExpressionNode {
        this.eat(TokType.DOT)
        let identifier_tok = this.eat(TokType.IDENTIFER) as IdentifierToken
        return new MemberExpressionNode(expression, identifier_tok, FloRange.merge(expression.range, identifier_tok.range))
    }
    private parse_lhs_expression_allow_call(this): ExpressionNode {
        let expression = this.parse_atom()
        while this.can_parse() {
            if this.current_token.ttype == TokType.LPAR
                expression = this.parse_call_expression(expression)
            else if this.current_token.ttype == TokType.LBRACKET
                expression = this.parse_index_expression(expression)
            else if this.current_token.ttype == TokType.DOT
                expression = this.parse_member_expression(expression)
            else
                break
        }
        return expression
    }
    private parse_unary_expression_post(this): ExpressionNode {
        let expression = this.parse_lhs_expression_allow_call()
        let op = UnaryOp.UNDEF
        let current_token = this.current_token
        if current_token.ttype == TokType.PLUS_PLUS
            op = UnaryOp.POSTINCR
        else if current_token.ttype == TokType.MINUS_MINUS
            op = UnaryOp.POSTDECR
        else return expression
        this.advance()
        return new UnaryExpressionNode(op, expression, FloRange.merge(expression.range, current_token.range))
    }
    private is_unary_op(this): UnaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.PLUS_PLUS 
            return UnaryOp.PREINCR
        if token_type == TokType.MINUS_MINUS 
            return UnaryOp.PREDECR
        if token_type == TokType.MINUS 
            return UnaryOp.NEG
        if token_type == TokType.AMP 
            return UnaryOp.ADDROF
        if token_type == TokType.DEL_KW 
            return UnaryOp.DEL
        return UnaryOp.UNDEF
    }
    private parse_unary_expression_pre(this): ExpressionNode {
        let start_range = this.current_token.range
        let op = this.is_unary_op()
        if (op == UnaryOp.UNDEF) return this.parse_unary_expression_post()
        this.advance()
        let expression = this.parse_unary_expression_pre()
        return new UnaryExpressionNode(op, expression, FloRange.merge(start_range, expression.range))
    }
    private is_term_expr_op(this): BinaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.MULT
            return BinaryOp.MUL
        if token_type == TokType.DIV
            return BinaryOp.DIV
        if token_type == TokType.MOD
            return BinaryOp.MOD
        if token_type == TokType.POW
            return BinaryOp.POW
        return BinaryOp.UNDEF
    }
    private parse_term_expression(this): ExpressionNode {
        let unary = this.parse_unary_expression_pre()
        let op = this.is_term_expr_op()
        while op != BinaryOp.UNDEF and this.can_parse(){
            this.advance()
            unary = new BinaryExpressionNode(unary, op, this.parse_unary_expression_pre())
            op = this.is_term_expr_op()
        }
        return unary
    }
    private is_arith_expr_op(this): BinaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.PLUS
            return BinaryOp.ADD
        if token_type == TokType.MINUS
            return BinaryOp.SUB
        return BinaryOp.UNDEF
    }
    private parse_arithmetic_expression(this): ExpressionNode {
        let term = this.parse_term_expression()
        let op = this.is_arith_expr_op()
        while op != BinaryOp.UNDEF and this.can_parse() {
            this.advance()
            term = new BinaryExpressionNode(term, op, this.parse_term_expression())
            op = this.is_arith_expr_op()
        }
        return term
    }
    private is_bitshift_expr_op(this): BinaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.SL
            return BinaryOp.SL
        if token_type == TokType.SR
            return BinaryOp.SR
        if token_type == TokType.XOR
            return BinaryOp.XOR
        return BinaryOp.UNDEF
    }
    private parse_bitshift_expression(this): ExpressionNode {
        let arith = this.parse_arithmetic_expression()
        let op = this.is_bitshift_expr_op()
        while op != BinaryOp.UNDEF and this.can_parse() {
            this.advance()
            arith = new BinaryExpressionNode(arith, op, this.parse_arithmetic_expression())
            op = this.is_bitshift_expr_op()
        }
        return arith
    }
    private is_comp_expr_op(this): BinaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.GT
            return BinaryOp.GT
        if token_type == TokType.LT
            return BinaryOp.LT
        if token_type == TokType.GTE
            return BinaryOp.GTE
        if token_type == TokType.LTE
            return BinaryOp.LTE
        if token_type == TokType.EEQ
            return BinaryOp.EEQ
        if token_type == TokType.NEQ
            return BinaryOp.NEQ
        return BinaryOp.UNDEF
    }
    private parse_comparasion_expression(this): ExpressionNode {
        let start_range = this.current_token.range
        if this.current_token.ttype == TokType.NOT {
            this.advance()
            let comp_val = this.parse_comparasion_expression()
            return new UnaryExpressionNode(UnaryOp.NOT, comp_val, FloRange.merge(start_range, comp_val.range))
        }
        let bit = this.parse_bitshift_expression()
        let op = this.is_comp_expr_op()
        while op != BinaryOp.UNDEF and this.can_parse() {
            this.advance()
            bit = new BinaryExpressionNode(bit, op, this.parse_bitshift_expression())
            op = this.is_comp_expr_op()
        }
        return bit
    }
    private is_logic_expr_op(this): BinaryOp {
        let token_type = this.current_token.ttype
        if token_type == TokType.OR_KW
            return BinaryOp.OR
        if token_type == TokType.AND_KW
            return BinaryOp.AND
        return BinaryOp.UNDEF
    }
    private parse_bit_expression(this): ExpressionNode {
        let cmp = this.parse_comparasion_expression()
        let op = this.is_logic_expr_op()
        while op != BinaryOp.UNDEF and this.can_parse() {
            this.advance()
            cmp = new BinaryExpressionNode(cmp, op, this.parse_comparasion_expression())
            op = this.is_logic_expr_op()
        }
        return cmp
    }
    private parse_range_expression(this): ExpressionNode {
        let left = this.parse_bit_expression()
        if this.current_token.ttype != TokType.DOT_DOT or !this.can_parse()
            return left
        this.advance()
        return new BinaryExpressionNode(left, BinaryOp.RANGE, this.parse_expression())
    }
    private parse_typecast_expression(this): ExpressionNode {
        let left = this.parse_range_expression()
        if this.current_token.ttype != TokType.AS_KW 
            return left
        this.advance()
        let node = new TypeCastExpressionNode(left, this.parse_type())
        return node
    }
    /* TODO: Need to figure out the logic here */
    private parse_ternary_expression(this): ExpressionNode {
        let cond = this.parse_typecast_expression()
        if this.current_token.ttype != TokType.QUES or !this.can_parse()
            return cond
        this.advance()
        let is_true = this.parse_expression()
        this.eat(TokType.COL)
        let is_false = this.parse_expression()
        return new TernaryExpressionNode(cond, is_true, is_false)
    }
    private is_assign_op(this): BinaryOp {
        if this.current_token.ttype == TokType.EQ 
            return BinaryOp.ASSIGN
        if this.current_token.ttype == TokType.MULT_EQ
            return BinaryOp.MUL_ASSIGN
        if this.current_token.ttype == TokType.MINUS_EQ
            return BinaryOp.SUB_ASSIGN
        if this.current_token.ttype == TokType.PLUS_EQ
            return BinaryOp.ADD_ASSIGN
        if this.current_token.ttype == TokType.DIV_EQ
            return BinaryOp.DIV_ASSIGN
        if this.current_token.ttype == TokType.MOD_EQ
            return BinaryOp.MOD_ASSIGN
        if this.current_token.ttype == TokType.POW_EQ
            return BinaryOp.POW_ASSIGN
        if this.current_token.ttype == TokType.AND_EQ
            return BinaryOp.AND_ASSIGN
        if this.current_token.ttype == TokType.OR_EQ
            return BinaryOp.OR_ASSIGN
        if this.current_token.ttype == TokType.XOR_EQ
            return BinaryOp.XOR_ASSIGN
        if this.current_token.ttype == TokType.SL_EQ
            return BinaryOp.SL_ASSIGN
        if this.current_token.ttype == TokType.SR_EQ
            return BinaryOp.SR_ASSIGN
        return BinaryOp.UNDEF
    }
    private parse_expression(this): ExpressionNode {
        let left = this.parse_ternary_expression()
        if this.current_token.ttype == TokType.IN_KW and this.can_parse() {
            this.advance()
            return new BinaryExpressionNode(left, BinaryOp.IN, this.parse_expression())
        }
        let op = this.is_assign_op()
        if op == BinaryOp.UNDEF or !this.can_parse()
            return left
        this.advance()
        return new BinaryExpressionNode(left, op, this.parse_expression())
    }
    private parse_if_statement(this): IfStatementNode {
        let if_node = new IfStatementNode(this.current_token.range)
        this.advance()
        if_node.condition = this.parse_expression()
        if_node.range = FloRange.merge(if_node.range, if_node.condition.range)
        if_node.block = this.parse_block()
        this.new_lines()
        if this.current_token.ttype == TokType.ELSE_KW {
            this.advance()
            if_node.else_block = this.parse_block()
        }
        return if_node
    }
    private parse_while_statement(this): WhileStatementNode {
        let while_node = new WhileStatementNode(this.current_token.range)
        this.advance()
        while_node.condition = this.parse_expression()
        while_node.range = FloRange.merge(while_node.range, while_node.condition.range)
        while_node.block = this.parse_block()
        return while_node
    }
    private parse_for_statement(this): ForStatementNode {
        let for_node = new ForStatementNode(this.current_token.range)
        this.advance()
        if this.peek().ttype != TokType.IN_KW {
            if this.current_token.ttype != TokType.SEMICOL {
                for_node.initialization = this.parse_statement()
            }
            this.eat(TokType.SEMICOL)
            if this.current_token.ttype != TokType.SEMICOL {
                for_node.condition = this.parse_expression()
            }
            this.eat(TokType.SEMICOL)
            if this.current_token.ttype != TokType.LBRACE {
                for_node.incr_decr = this.parse_statement()
            }
        } else {
            for_node.for_kind = ForKind.IN
            for_node.it_name = this.eat(TokType.IDENTIFER) as IdentifierToken
            this.eat(TokType.IN_KW)
            for_node.iterator = this.parse_expression()
        }
        for_node.range = FloRange.merge(for_node.range, this.current_token.range)
        if this.can_parse()
            for_node.block = this.parse_block()
        return for_node
    }
    private parse_variable_declaration_statement(this): VarDeclarationStatement {
        let var_decl_node = new VarDeclarationStatement(this.current_token.range)
        this.advance()
        var_decl_node.var_name =  this.eat(TokType.IDENTIFER) as IdentifierToken
        if this.current_token.ttype == TokType.COL {
            this.advance()
            var_decl_node.var_type = this.parse_type()
        }
        let end_range = this.current_token.range
        if this.current_token.ttype == TokType.EQ {
            this.advance()
            var_decl_node.value = this.parse_expression()
            end_range = var_decl_node.value.range
        } else if var_decl_node.var_type != null and this.current_token.ttype == TokType.LPAR {
            // REMEMBER: DRY
            let new_node = new NewExpressionNode(var_decl_node.var_type, var_decl_node.var_type.range)
            new_node.onheap = false
            this.advance()
            if this.current_token.ttype != TokType.RPAR
                this.parse_expression_list(new_node.args)
            new_node.range = FloRange.merge(new_node.range, this.eat(TokType.RPAR).range)
            var_decl_node.value = new_node
        }
        var_decl_node.range = FloRange.merge(var_decl_node.range, end_range)
        return var_decl_node
    }
    private parse_return_statement(this): ReturnStatementNode{
        let return_node = new ReturnStatementNode(this.current_token.range)
        this.advance()
        if this.current_token.ttype != TokType.LN and this.can_parse() and this.current_token.ttype != TokType.RBRACE {
            let value = this.parse_expression()
            return_node.range = FloRange.merge(return_node.range, value.range)
            return_node.value = value
        }
        return return_node
    }
    private parse_statement(this): StatementNode {
        let start_range = this.current_token.range
        if this.current_token.ttype == TokType.IF_KW 
            return this.parse_if_statement()
        else if this.current_token.ttype == TokType.WHILE_KW
            return this.parse_while_statement()
        else if this.current_token.ttype == TokType.FOR_KW
            return this.parse_for_statement()
        else if this.current_token.ttype == TokType.RETURN_KW
            return this.parse_return_statement()
        else if this.current_token.ttype == TokType.LET_KW
            return this.parse_variable_declaration_statement()
        else if this.current_token.ttype == TokType.CONST_KW
            return this.parse_const_declaration_statement()
        else if this.current_token.ttype == TokType.CONTINUE_KW {
            this.advance()
            return new StatementNode(StatementKind.CONTINUE, start_range)
        } else if this.current_token.ttype == TokType.BREAK_KW {
            this.advance()
            return new StatementNode(StatementKind.BREAK, start_range)
        }
        return this.parse_expression()
    }
    private parse_block(this): BlockNode {
        let block_node = new BlockNode(this.current_token.range)
        this.new_lines()
        if this.current_token.ttype == TokType.LBRACE {
            this.advance()
            this.new_lines()
            while this.can_parse() and this.current_token.ttype != TokType.RBRACE {
                block_node.statements << this.parse_statement()
                this.new_lines()
            }
            this.eat(TokType.RBRACE)
        } else block_node.statements << this.parse_statement()
        return block_node
    }
    private parse_type_alias(this): TypeAliasNode {
        this.advance()
        let type_alias_node = new TypeAliasNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        this.eat(TokType.EQ)
        type_alias_node.parsed_type = this.parse_type()
        return type_alias_node
    }
    private parse_arg(this): ArgNode {
        let arg_node = new ArgNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        if !this.can_parse() return arg_node
        if this.current_token.ttype == TokType.COL {
            this.advance()
            arg_node.parsed_type = this.parse_type()
            if !this.can_parse() return arg_node
        }
        if this.current_token.ttype == TokType.EQ {
            this.advance()
            arg_node.default = this.parse_expression()
        }
        if arg_node.parsed_type == null and arg_node.default == null {
            this.error("'$(arg_node.name.value)' has no type information")
            this.errors[this.errors.length - 1].range = arg_node.name.range
        }
        return arg_node
    }
    private parse_args(this, args: ArgNode[]) {
        args << this.parse_arg()
        while this.current_token.ttype == TokType.COMMA and this.can_parse() {
            this.eat(TokType.COMMA)
            args << this.parse_arg()
        }
    }
    private parse_function(this): FunctionDeclarationNode {
        let fnc_node = new FunctionDeclarationNode()
        fnc_node.name = this.eat(TokType.IDENTIFER) as IdentifierToken
        this.eat(TokType.LPAR)
        if this.current_token.ttype != TokType.RPAR
            this.parse_args(fnc_node.args)
        
        this.eat(TokType.RPAR)
        if this.current_token.ttype == TokType.COL {
            this.advance()
            fnc_node.return_type = this.parse_type()
        } else {
            let identifier_tok = new IdentifierToken("void", new FloRange(0, 0, 0, 0))
            fnc_node.return_type = new RecordTypeNode(identifier_tok, identifier_tok.range)
        }
        if this.current_token.ttype == TokType.LBRACE {
            fnc_node.block = this.parse_block()
        } else
            fnc_node.is_external = true
        return fnc_node
    }
    private parse_method(this): MethodNode{
        let method_node = new MethodNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        this.eat(TokType.LPAR)
        if this.current_token.ttype != TokType.RPAR
            if (this.current_token as IdentifierToken).value == "this" {
                method_node.is_static = false
                this.advance()
            }
            if this.current_token.ttype != TokType.RPAR {
                if !method_node.is_static
                    this.eat(TokType.COMMA)
                this.parse_args(method_node.args)
            }
        this.eat(TokType.RPAR)
        if this.current_token.ttype == TokType.COL {
            this.advance()
            method_node.return_type = this.parse_type()
        } else {
            let identifier_tok = new IdentifierToken("void", new FloRange(0, 0, 0, 0))
            method_node.return_type = new RecordTypeNode(identifier_tok, identifier_tok.range)
        }
        if this.current_token.ttype == TokType.LBRACE {
            method_node.block = this.parse_block()
        } else
            method_node.is_abstract = true
        return method_node
    }
    private parse_access_modifier(this): ACCESS_ATTR {
        if this.current_token.ttype == TokType.PUBLIC_KW
            return ACCESS_ATTR.PUBLIC
        if this.current_token.ttype == TokType.PRIVATE_KW
            return ACCESS_ATTR.PRIVATE
        if this.current_token.ttype == TokType.PROTECTED_KW
            return ACCESS_ATTR.PROTECTED
        return ACCESS_ATTR.UNDEF
    }
    // (private | public | protected)? identider 
    private parse_class_block(this, class_node: ClassDeclarationNode) {
        this.eat(TokType.LBRACE)
        this.new_lines()
        while this.current_token.ttype != TokType.RBRACE and this.can_parse() {
            let access_modifier = this.parse_access_modifier()
            if access_modifier == ACCESS_ATTR.UNDEF {
                access_modifier = ACCESS_ATTR.PUBLIC
            } else {
                this.advance()
            }
            if this.peek().ttype == TokType.COL {
                let field = new FieldNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
                this.eat(TokType.COL)
                field.parsed_type = this.parse_type()
                if this.current_token.ttype == TokType.EQ {
                    this.advance()
                    field.initializer = this.parse_expression()
                }
                field.access_modifier = access_modifier
                class_node.fields << field
            } else if this.peek().ttype == TokType.LPAR {
                let method = this.parse_method()
                method.access_modifier = access_modifier
                class_node.methods << method
            } else {
                this.error("Expected ':' or '('")
                return
            }
            this.new_lines()
        }
        this.eat(TokType.RBRACE)
    }
    private parse_generic_parameters(this, generic_parameters: GenericParameterNode[]) {
        this.advance()
        generic_parameters << new GenericParameterNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        while this.current_token.ttype == TokType.COMMA and this.can_parse() {
            this.advance()
            generic_parameters << new GenericParameterNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        }
        this.eat(TokType.GT)
    }
    private parse_class(this): ClassDeclarationNode {
        this.advance()
        let class_node = new ClassDeclarationNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        if this.current_token.ttype == TokType.LT
            this.parse_generic_parameters(class_node.generic_parameters)
        if this.current_token.ttype == TokType.LPAR {
            this.advance()
            class_node.parent = this.parse_object_type()
            this.eat(TokType.RPAR)
        }
        this.new_lines()
        this.parse_class_block(class_node)
        return class_node
    }
    private parse_const_declaration_statement(this): ConstDeclarationStatement {
        let const_decl_node = new ConstDeclarationStatement(this.current_token.range)
        this.advance()
        const_decl_node.const_name = this.eat(TokType.IDENTIFER) as IdentifierToken
        if this.current_token.ttype == TokType.COL {
            this.advance()
            const_decl_node.const_type = this.parse_type()
        }
        this.eat(TokType.EQ)
        const_decl_node.value = this.parse_expression()
        const_decl_node.range = FloRange.merge(const_decl_node.range, const_decl_node.value.range)
        return const_decl_node
    }
    private parse_import_clause(this): ImportClause {
        let import_clause = new ImportClause(this.eat(TokType.IDENTIFER) as IdentifierToken)
        if this.current_token.ttype == TokType.AS_KW {
            this.advance()
            import_clause.renamed_identifer = this.eat(TokType.IDENTIFER) as IdentifierToken
        }
        return import_clause
    }
    private parse_import(this): ImportNode {
        this.advance()
        let import_node = new ImportNode()
        if this.current_token.ttype == TokType.IDENTIFER {
            import_node.import_list << this.parse_import_clause()
            while this.current_token.ttype == TokType.COMMA and this.can_parse() {
                this.advance()
                import_node.import_list << this.parse_import_clause()
            }
            this.eat(TokType.IN_KW)
        }
        import_node.module_path = this.eat(TokType.STR) as StrToken
        if this.current_token.ttype == TokType.AS_KW {
            this.advance()
            import_node.module_name = this.eat(TokType.IDENTIFER) as IdentifierToken
        }
        return import_node
    }
    private parse_enum(this): EnumNode {
        this.advance()
        let enum_node = new EnumNode(this.eat(TokType.IDENTIFER) as IdentifierToken)
        if this.current_token.ttype == TokType.LPAR {
            this.advance()
            enum_node.variant = this.parse_type()
            this.eat(TokType.RPAR)
        }
        this.new_lines()
        this.eat(TokType.LBRACE)
        this.new_lines()
        while this.current_token.ttype == TokType.IDENTIFER {
            let enum_field = new EnumNodeField(this.eat(TokType.IDENTIFER) as IdentifierToken)
            if this.current_token.ttype == TokType.EQ {
                this.advance()
                enum_field.initializer = this.parse_expression()
            }
            enum_node.fields << enum_field
            this.new_lines()
        }
        this.eat(TokType.RBRACE)
        return enum_node
    }
    public parse(tokens: Token[], errors: FloError[]): ModuleAST {
        let parser: Parser(tokens, errors)
        parser.advance()
        let module_node = new ModuleAST()
        parser.new_lines()
        while parser.can_parse() {
            if parser.current_token.ttype == TokType.FNC_KW {
                parser.advance()
                module_node.functions << parser.parse_function()
            }
            else if parser.current_token.ttype == TokType.CLASS_KW
                module_node.classes << parser.parse_class()
            else if parser.current_token.ttype == TokType.ENUM_KW
                module_node.enums << parser.parse_enum()
            else if parser.current_token.ttype == TokType.IMPORT_KW
                module_node.imports << parser.parse_import()
            else if parser.current_token.ttype == TokType.CONST_KW
                module_node.consts << parser.parse_const_declaration_statement()
            else if parser.current_token.ttype == TokType.LET_KW
                module_node.vars << parser.parse_variable_declaration_statement()
            else if parser.current_token.ttype == TokType.IDENTIFER and (parser.current_token as IdentifierToken).value == "type"
                module_node.type_aliases << parser.parse_type_alias()
            else 
                parser.error("Illegal expression expected: 'fnc', 'class', 'enum', 'import', 'const' or 'let'")
            parser.new_lines()
        }
        return module_node
    }
}