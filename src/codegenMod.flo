class GeneratedModule {
    private llvm_mod: LLVMModuleRef
    private errors: i8*
    constructor(this, llvm_mod: LLVMModuleRef){
        this.llvm_mod = llvm_mod
        this.errors = null
        LLVMVerifyModule(this.llvm_mod, LLVMVerifierFailureAction.LLVMAbortProcessAction, &this.errors)
        this.check_errors()
        LLVMLinkInMCJIT()
        LLVMInitializeAllTargets()
        LLVMInitializeAllTargetInfos()
        LLVMInitializeAllTargetMCs()
        LLVMInitializeAllTargetPrinters()
        LLVMInitializeAllTargetParsers()
    }
    private check_errors(this){
        if (this.errors[0] != 0) {
            println("error:", string_from_cstring(this.errors))
            LLVMDisposeMessage(this.errors)
            exit()
        }
    }
    public run_passes(this, level: int){
        let fpm = LLVMCreateFunctionPassManagerForModule(this.llvm_mod)
        // let mpm = LLVMCreatePassManager()
        let pmb = LLVMPassManagerBuilderCreate()
        LLVMPassManagerBuilderSetOptLevel(pmb, level)
        LLVMPassManagerBuilderUseInlinerWithThreshold(pmb, 255)
        // LLVMPassManagerBuilderPopulateModulePassManager(pmb, mpm)
        let func = LLVMGetFirstFunction(this.llvm_mod)
        LLVMPassManagerBuilderPopulateFunctionPassManager(pmb, fpm)
        while func != null {
            LLVMRunFunctionPassManager(fpm, func)
            func = LLVMGetNextFunction(func)
        }
        // LLVMRunPassManager(mpm, this.llvm_mod)
        LLVMDisposePassManager(fpm)
        // LLVMDisposePassManager(mpm)
        LLVMPassManagerBuilderDispose(pmb)
    }
    public exec(this){
        let module_copy = this.copy_llvm_module()
        let engine: LLVMExecutionEngineRef = null
        if (LLVMCreateExecutionEngineForModule(&engine, module_copy, &this.errors) != 0) {
            println("failed to create execution engine")
            return
        }
        let main_fnc = LLVMGetFunctionAddress(engine, "main")  as () => int
        if main_fnc == null {
            println("Main function not found in module; can't execute")
            LLVMDisposeExecutionEngine(engine)
            return
        }
        println("Exited with code:", main_fnc())
        LLVMDisposeExecutionEngine(engine)
    }
    public create_target_machine(this, triple_str: string): LLVMTargetMachineRef {
        let triple = triple_str == "" ? LLVMGetDefaultTargetTriple() : triple_str.to_cstring()
        let target = LLVMGetFirstTarget()
        if (LLVMGetTargetFromTriple(triple, &target, &this.errors) != 0) {
            println("failed to get target triple:", triple_str)
        }
        this.check_errors()
        let CPU: i8* = "generic"
        return LLVMCreateTargetMachine(target, triple, CPU, LLVMGetHostCPUFeatures(), LLVMCodeGenOptLevel.LLVMCodeGenLevelAggressive, LLVMRelocMode.LLVMRelocDefault, LLVMCodeModel.LLVMCodeModelDefault)
    }
    public write_object(this, fn: string, target: string){
        let tm = this.create_target_machine(target)
        let module_copy = this.copy_llvm_module()
        LLVMSetDataLayout(module_copy, LLVMCreateTargetDataLayout(tm))
        LLVMSetTarget(module_copy, LLVMGetTargetMachineTriple(tm))
        if (LLVMTargetMachineEmitToFile(tm, module_copy, fn.to_cstring(), 1, &this.errors) != 0) {
            println("target machine failed to emit object code")
        }
        this.check_errors()
        LLVMDisposeTargetMachine(tm)
    }
    public print(this){
        LLVMDumpModule(this.llvm_mod)
    }
    private copy_llvm_module(this): LLVMModuleRef{
        return LLVMCloneModule(this.llvm_mod)
    }
    public destroy(this){
        let ctx = LLVMGetModuleContext(this.llvm_mod)
        LLVMDisposeModule(this.llvm_mod)
        LLVMContextDispose(ctx)
        LLVMShutdown()
    }
}