fnc string_to_kw_token(word: string): TokType {
    if word == "and"
        return TokType.AND_KW
    if word == "or"
        return TokType.OR_KW
    if word == "xor"
        return TokType.XOR_KW
    if word == "const"
        return TokType.CONST_KW
    if word == "let"
        return TokType.LET_KW
    if word == "if" 
        return TokType.IF_KW
    if word == "else"
        return TokType.ELSE_KW
    if word == "bool"
        return TokType.BOOL_KW
    if word == "i4"
        return TokType.I4_KW
    if word == "i8"
        return TokType.I8_KW
    if word == "i16"
        return TokType.I16_KW
    if word == "i32"
        return TokType.I32_KW
    if word == "i64"
        return TokType.I64_KW
    if word == "i128"
        return TokType.I128_KW
    if word == "int"
        return TokType.INT_KW
    if word == "f16"
        return TokType.F16_KW
    if word == "f32"
        return TokType.F32_KW
    if word == "f64"
        return TokType.F64_KW
    if word == "float"
        return TokType.FLOAT_KW
    if word == "void"
        return TokType.VOID_KW
    if word == "for"
        return TokType.FOR_KW
    if word == "while"
        return TokType.WHILE_KW
    if word == "fnc"
        return TokType.FNC_KW
    if word == "break"
        return TokType.BREAK_KW
    if word == "continue"
        return TokType.CONTINUE_KW
    if word == "return"
        return TokType.RETURN_KW
    if word == "import"
        return TokType.IMPORT_KW
    if word == "type"
        return TokType.TYPE_KW
    if word == "in"
        return TokType.IN_KW
    if word == "class"
        return TokType.CLASS_KW
    if word == "enum"
        return TokType.ENUM_KW
    if word == "new"
        return TokType.NEW_KW
    if word == "as"
        return TokType.AS_KW
    if word == "is"
        return TokType.IS_KW
    return -1
}
fnc is_identifier_char(char: i8): bool {
    return (char >= 'A' and char <= 'Z') or (char >= 'a' and char <= 'z') or (char == '_')
}
fnc is_number_char(char: i8): bool {
    return (char >= '0' and char <= '9')
}
fnc capitalize(char: i8): i8 {
    if char >= 'a' and char <= 'z'
        return char - ' '
    return char 
}
fnc in_base_range(char: i8, base: int): bool {
    if base < 10 
        return char >= '0' and char <= (base + 48)
    return (char >= '0' and char <= (base + 48)) or (char >= 'A' and char <= (base + 65))
}
fnc get_escape_char(char: i8): i8 {
    if (char == 'a') return '\a'
    if (char == 'b') return '\b'
    if (char == 't') return '\t'
    if (char == 'f') return '\f'
    if (char == 'n') return '\n'
    if (char == 'r') return '\r'
    if (char == 'v') return '\v'
    if (char == '0') return '\0'
    if (char == '\'') return '\''
    if (char == '\"') return '\"'
    if (char == '\\') return '\\'
    return char
}
fnc unescape(str: string): string {
    let buffer = new i8[str.length]
    let new_string = new string(buffer, 0)
    new_string.size = str.length
    let ch = '\0'
    let oval = ch
    for let i = 0; i < str.length; i++ {
        ch = str.get_byte(i)
        if (ch == '\\') {
            if i + 3 < str.length {
                let window = str.get_bytes() + i + 1
                if memcmp(window, "033", 3) == 0 or memcmp(window, "x1b", 3) == 0 {
                    new_string += "\033"
                    i+=3
                    continue
                }
                if i + 6 < str.length {
                    if memcmp(window, "u001b", 5) == 0 {
                        new_string += "\033"
                        i+=5
                        continue
                    }
                }
            }
            ch = get_escape_char(str.get_byte(++i))
        }
        new_string.add_byte(ch)
    }
    return new_string
}
class Token {
    ttype: TokType
    range: FloRange
    constructor(ttype: TokType, range: FloRange){
        this.ttype = ttype
        this.range = range
    }
}
class IntToken (Token) {
    value: int
    constructor(value: int, range: FloRange){
        super(TokType.INT, range)
        this.value = value
    }
}
class FloatToken (Token) {
    value: float
    constructor(value: float, range: FloRange){
        super(TokType.FLOAT, range)
        this.value = value
    }
}
class CharToken (Token) {
    value: i8
    constructor(value: i8, range: FloRange){
        super(TokType.CHAR, range)
        this.value = value
    }
}
class StrToken (Token) {
    value: string
    constructor(value: string, range: FloRange){
        super(TokType.STR, range)
        this.value = value
    }
}
class IdentifierToken (Token) {
    value: string
    constructor(value: string, range: FloRange){
        super(TokType.IDENTIFER, range)
        this.value = value
    }
}
class Lexer {
    current_char: i8
    text: string
    errors: FloError[]
    idx: int
    col: int
    line: int
    constructor(text: string, errors: FloError[]){
        this.idx = -1
        this.line = 1
        this.col = 0
        this.text = text
        this.errors = errors
    }
    eof(): bool{
        return this.idx >= this.text.length
    }
    peek(offset = 1): i8 {
        if this.idx + offset < this.text.length 
            return this.text.get_byte(this.idx + offset)
        return '\0'
    }
    advance(){
        if this.eof() {
            return
        }
        this.current_char = this.text.get_byte(++this.idx)
        if this.current_char == '\n' {
            this.col = 0
            this.line++
        } else
            this.col++
    }
    get_range(back: int): FloRange {
        return new FloRange(this.idx - back + 1, this.idx + 1, this.col - back, this.line)
    }
    plus_token(): Token {
        if this.peek() == '+' {
            this.advance()
            return new Token(TokType.PLUS_PLUS, this.get_range(2))
        }
        return new Token(TokType.PLUS, this.get_range(1))
    }
    skip_comment(): bool{
        if this.peek() == '*' {
            this.advance()
            while !this.eof() {
                if this.peek() == '*' and this.peek(2) == '/' break
                this.advance()
            }
            this.advance()
            this.advance()
            return true
        } else if this.peek() == '/' {
            this.advance()
            while this.peek() != '\n' and !this.eof()
                this.advance()
            return true
        }
        return false
    }
    minus_token(): Token{
        if this.peek() == '-' {
            this.advance()
            return new Token(TokType.MINUS_MINUS, this.get_range(2))
        }
        return new Token(TokType.MINUS, this.get_range(2))
    }
    eq_token(): Token {
        if this.peek() == '='{
            this.advance()
            return new Token(TokType.EEQ, this.get_range(2))
        } 
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.ARROW, this.get_range(2))
        }
        return new Token(TokType.EQ, this.get_range(1))
    }
    neq_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.NEQ, this.get_range(2))
        }
        return new Token(TokType.NOT, this.get_range(1))
    }
    gt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.GTE, this.get_range(2))
        }
        else if this.peek() == '>' {
            this.advance()
            return new Token(TokType.SR, this.get_range(2))
        }
        return new Token(TokType.GT, this.get_range(1))
    }
    lt_token(): Token {
        if this.peek() == '=' {
            this.advance()
            return new Token(TokType.LTE, this.get_range(2))
        }
        else if this.peek() == '<' {
            this.advance()
            return new Token(TokType.SL, this.get_range(2))
        }
        return new Token(TokType.LT, this.get_range(1))
    }
    dot_token(): Token {
        let token = TokType.DOT
        let length = 1
        if this.peek() == '.'{
            token = TokType.DOT_DOT
            length++
            this.advance()
            if this.peek() == '.' {
                token = TokType.DOT_DOT_DOT
                length++
                this.advance()
            }
        }
        return new Token(token, this.get_range(length))
    }
    base_int_token(base: int): IntToken{
        this.advance()
        let length = 3
        let value = 0
        let current_char = '\0'
        while in_base_range(current_char = capitalize(this.peek()), base) and !this.eof() {
            value *= base
            let add =  current_char - '0'
            if (current_char >= 'A') add = current_char - 'A' + 10
            value += add
            length++
            this.advance()
        }
        return new IntToken(value, this.get_range(length))
    }
    numeric_token(): Token {
        let length = 1
        let is_float = false
        let next_char = '\0'
        if this.current_char == '0' and this.peek() == 'b'
            return this.base_int_token(2)
        if this.current_char == '0' and this.peek() == 'o'
            return this.base_int_token(8)
        if this.current_char == '0' and this.peek() == 'x'
            return this.base_int_token(16)
        while (is_number_char(next_char = this.peek()) or next_char == '.') and !this.eof() {
            if next_char == '.' and (is_float or !is_number_char(this.peek(2))) break
            if this.current_char == '.' is_float = true
            length++
            this.advance()
        }
        let range = this.get_range(length)
        let str_value = this.text.substring(range.start, length)
        return is_float ? new FloatToken(str_value as float, range) as Token : new IntToken(str_value as int, range)
    }
    identifier_token(): Token {
        let length = 1
        let start = this.idx
        let next_char = this.peek()
        while (is_identifier_char(next_char = this.peek()) or is_number_char(next_char)) and !this.eof() {
            length++
            this.advance()
        }
        let value = this.text.substring(start, length)
        let range = this.get_range(length)
        let keyword = 0
        if (keyword = string_to_kw_token(value)) != -1 return new Token(keyword, range)
        return new IdentifierToken(value, range)
    }
    string_token(): StrToken {
        let length = 2
        let escape_next = false
        this.advance()
        while !this.eof() {
            if (this.current_char == '"' and !escape_next) break
            length++
            escape_next = this.current_char == '\\'
            this.advance()
        }
        let range = this.get_range(length)
        let value = unescape(this.text.substring(range.start+1, length-2))
        return new StrToken(value, range)
    }
    char_token(): CharToken {
        let length = 3
        this.advance()
        let value = this.current_char
        if this.current_char == '\\' {
            this.advance()
            value = get_escape_char(this.current_char)
            length+=2
        }
        this.advance()
        return new CharToken(value, this.get_range(length))
    }
    tokenize(): Token[] {
        this.advance()
        let tokens: Token[] = []
        let char = '\0'
        while !this.eof() and this.errors.length == 0 {
            char = this.current_char
            if char == ' ' true
            else if is_identifier_char(char)
                tokens << (this.identifier_token() as Token)
            else if char == '"'
                tokens << (this.string_token() as Token)
            else if is_number_char(char)
                tokens << (this.numeric_token() as Token)
            else if char == ':' 
                tokens << new Token(TokType.COL, this.get_range(1))
            else if char == ';'
                tokens << new Token(TokType.SEMICOL, this.get_range(1))
            else if char == ','
                tokens << new Token(TokType.COMMA, this.get_range(1))
            else if char == '+'
                tokens << this.plus_token()
            else if char == '-'
                tokens << this.minus_token()
            else if char == '*'
                tokens << new Token(TokType.MULT, this.get_range(1))
            else if char == '('
                tokens << new Token(TokType.LPAR, this.get_range(1))
            else if char == ')'
                tokens << new Token(TokType.RPAR, this.get_range(1))
            else if char == '%'
                tokens << new Token(TokType.MOD, this.get_range(1))
            else if char == '{'
                tokens << new Token(TokType.LBRACE, this.get_range(1))
            else if char == '}'
                tokens << new Token(TokType.RBRACE, this.get_range(1))
            else if char == '['
                tokens << new Token(TokType.LBRACKET, this.get_range(1))
            else if char == ']'
                tokens << new Token(TokType.RBRACKET, this.get_range(1))
            else if char == '\n' or char == '\r'
                tokens << new Token(TokType.LN, this.get_range(1))
            else if char == '\''
                tokens << (this.char_token() as Token)
            else if char == '^'
                tokens << new Token(TokType.POW, this.get_range(1))
            else if char == '?'
                tokens << new Token(TokType.QUES, this.get_range(1))
            else if char == '&'
                tokens << new Token(TokType.AMP, this.get_range(1))
            else if char == '='
                tokens << this.eq_token()
            else if char == '!'
                tokens << this.neq_token()
            else if char == '>'
                tokens << this.gt_token()
            else if char == '<'
                tokens << this.lt_token()
            else if char == '.'
                tokens << this.dot_token()
            else if char == '/' {
                if (!this.skip_comment())
                    tokens << new Token(TokType.DIV, this.get_range(1))
            } else {
                this.errors << new FloError(ErrorKind.ILLEGALCHAR, "Illegal character: '"+this.text.substring(this.idx, 1)+"'", this.get_range(1))
            }
            this.advance()
        }
        tokens << new Token(TokType.EOF, new FloRange(0, 0, this.col, this.line))
        return tokens
    }
}