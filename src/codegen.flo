import panic, TextRange in "utils"
import "typechecker"
import ARCH_WORD_SIZE in "@sys/lib"
import "llvm/types"
import "llvm/core"
import "llvm/debugInfo"
import LLVMCreateTargetData, LLVMABIAlignmentOfType, LLVMABISizeOfType in "llvm/target"
import "types"
import "codegenMod"
class GeneratedType {
    llvm_type: LLVMTypeRef
    llvm_metadata: LLVMMetadataRef
    constructor(this, llvm_type: LLVMTypeRef, llvm_metadata: LLVMMetadataRef){
        this.llvm_type = llvm_type
        this.llvm_metadata = llvm_metadata
    }
}
class CodegenTypeScope {
    bool_type: GeneratedType
    uint_type: GeneratedType
    u4_type: GeneratedType
    u8_type: GeneratedType
    u16_type: GeneratedType
    u32_type: GeneratedType
    u64_type: GeneratedType
    u128_type: GeneratedType
    int_type: GeneratedType
    i4_type: GeneratedType
    i8_type: GeneratedType
    i16_type: GeneratedType
    i32_type: GeneratedType
    i64_type: GeneratedType
    i128_type: GeneratedType
    f32_type: GeneratedType
    f64_type: GeneratedType
    void_type: GeneratedType
    null_type: GeneratedType
    record_types: StringMap<GeneratedRecordType>
    constructor(this, builder: LLVMDIBuilderRef){
        let int_llvm_type = LLVMIntType(ARCH_WORD_SIZE)
        let i4_llvm_type = LLVMIntType(4)
        let i8_llvm_type = LLVMInt8Type()
        let i16_llvm_type = LLVMInt16Type()
        let i32_llvm_type = LLVMInt32Type()
        let i64_llvm_type = LLVMInt64Type()
        let i128_llvm_type = LLVMInt128Type()

        this.uint_type = new GeneratedType(int_llvm_type, LLVMDIBuilderCreateBasicType(builder, "uint", 4, ARCH_WORD_SIZE, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))
        this.u4_type = new GeneratedType(i4_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u4", 4, 4, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))
        this.u8_type = new GeneratedType(i8_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u8", 2, 8, LLVMDWARFTypeEncoding.DW_ATE_unsigned_char, LLVMDIFlags.LLVMDIFlagZero))
        this.u16_type = new GeneratedType(i16_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u16", 3, 16, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))
        this.u32_type = new GeneratedType(i32_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u32", 3, 32, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))
        this.u64_type = new GeneratedType(i64_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u64", 3, 64, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))
        this.u128_type = new GeneratedType(i128_llvm_type, LLVMDIBuilderCreateBasicType(builder, "u128", 4, 128, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))

        this.int_type = new GeneratedType(int_llvm_type, LLVMDIBuilderCreateBasicType(builder, "int", 3, ARCH_WORD_SIZE, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i4_type = new GeneratedType(i4_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i4", 2, 4, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i8_type = new GeneratedType(i8_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i8", 2, 8, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i16_type = new GeneratedType(i16_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i16", 3, 16, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i32_type = new GeneratedType(i32_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i32", 3, 32, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i64_type = new GeneratedType(i64_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i64", 3, 64, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))
        this.i128_type = new GeneratedType(i128_llvm_type, LLVMDIBuilderCreateBasicType(builder, "i128", 4, 128, LLVMDWARFTypeEncoding.DW_ATE_signed, LLVMDIFlags.LLVMDIFlagZero))

        this.f32_type = new GeneratedType(LLVMFloatType(), LLVMDIBuilderCreateBasicType(builder, "f32", 3, 32, LLVMDWARFTypeEncoding.DW_ATE_float, LLVMDIFlags.LLVMDIFlagZero))
        this.f64_type = new GeneratedType(LLVMDoubleType(), LLVMDIBuilderCreateBasicType(builder, "f64", 3, 64, LLVMDWARFTypeEncoding.DW_ATE_float, LLVMDIFlags.LLVMDIFlagZero))
        this.bool_type = new GeneratedType(LLVMInt1Type(), LLVMDIBuilderCreateBasicType(builder, "bool", 4, 1, LLVMDWARFTypeEncoding.DW_ATE_unsigned, LLVMDIFlags.LLVMDIFlagZero))

        this.void_type = new GeneratedType(LLVMVoidType(), LLVMDIBuilderCreateUnspecifiedType(builder, "void", 4))
        this.null_type = new GeneratedType(null, LLVMDIBuilderCreateNullPtrType(builder))

        this.record_types = new StringMap<GeneratedRecordType>()
    }
    private create_type_id_key(type_id: TypeId): String {
        return "$(type_id.module_id);$(type_id.kind as int);$(type_id.id)"
    }
    public get_record_from_typeid(this, type_id: TypeId): GeneratedRecordType {
        return this.record_types[CodegenTypeScope.create_type_id_key(type_id)]
    }
    public add_record(this, type_id: TypeId, record_type: GeneratedRecordType){
        this.record_types[CodegenTypeScope.create_type_id_key(type_id)] = record_type
    }
}
class GeneratedField {
    llvm_value: LLVMValueRef
    llvm_metadata: LLVMMetadataRef
    constructor(this, llvm_value: LLVMValueRef, llvm_metadata: LLVMMetadataRef){
        this.llvm_value = llvm_value
        this.llvm_metadata = llvm_metadata
    }
}
class GeneratedRecordType(GeneratedType)  {
    private field_map: StringMap<GeneratedField>
    constructor(this){
        this.field_map = new StringMap<GeneratedField>()
    }
    private create_prop_key(prop_id: PropId): String {
        return "$(prop_id.kind as int);$(prop_id.id)"
    }
    public get_field(this, prop_id: PropId): GeneratedField {
        return this.field_map[GeneratedRecordType.create_prop_key(prop_id)]
    }
    public set_field(this, prop_id: PropId, field: GeneratedField){
        this.field_map[GeneratedRecordType.create_prop_key(prop_id)] = field
    }
}
class DebugInfo {
    private program: Program
    private builder: LLVMDIBuilderRef
    private CU: LLVMMetadataRef
    private files: LLVMMetadataRef[]
    private ctx: LLVMContextRef
    public lexical_blocks: Stack<LLVMMetadataRef>
    public type_scope: CodegenTypeScope
    public target_data: LLVMTargetDataRef
    public ptr_size: u64
    constructor(this, program: Program, mod: LLVMModuleRef, fn: String){
        this.program = program
        this.ctx = LLVMGetModuleContext(mod)
        this.builder = LLVMCreateDIBuilder(mod)
        this.type_scope = new CodegenTypeScope(this.builder)
        let file = LLVMDIBuilderCreateFile(this.builder, fn.get_bytes(), fn.length as int, "./", 2)
        this.files = [file]
        this.target_data = LLVMCreateTargetData("")
        this.lexical_blocks = new Stack<LLVMMetadataRef>()
        this.CU = LLVMDIBuilderCreateCompileUnit(
                    Builder: this.builder, 
                    Lang: LLVMDWARFSourceLanguage.LLVMDWARFSourceLanguageC,
                    FileRef: file,
                    Producer: "Flo Compiler",
                    ProducerLen: 12,
                    isOptimized: false,
                    Flags: "",
                    FlagsLen: 0,
                    RuntimeVer: 1,
                    SplitName: "",
                    SplitNameLen: 0,
                    Kind: LLVMDWARFEmissionKind.LLVMDWARFEmissionFull,
                    DWOId: 0,
                    SplitDebugInlining: false,
                    DebugInfoForProfiling: true,
                    SysRoot: "/",
                    SysRootLen: 1,
                    SDK: "",
                    SDKLen: 0
                )
        
        let void_ptr = LLVMPointerType(this.type_scope.void_type.llvm_type)
        this.ptr_size = LLVMABISizeOfType(this.target_data, void_ptr) * 8
        this.lexical_blocks.push(this.CU)
    }
    public get_current_file(this): LLVMMetadataRef {
        return LLVMDIScopeGetFile(this.lexical_blocks.peek())
    }
    private get_or_create_file(this, id: uint): LLVMMetadataRef {
        if (this.files.length > id) return this.files[id]
        let module = this.program.modules[id]
        let file = LLVMDIBuilderCreateFile(this.builder, module.name.get_bytes(), module.name.length as int, "./", 2)
        this.files.ensure_capacity(id)
        this.files[id] = file
        return file
    }
    public create_or_get_type(this, tt: Type): LLVMMetadataRef {
         if tt.kind == TypeKind.VOID
            return this.type_scope.void_type.llvm_metadata
        if tt.kind == TypeKind.BOOL
            return this.type_scope.bool_type.llvm_metadata
        if is_int(tt)
            return this.get_int_type(tt as IntType)
        if tt.kind == TypeKind.F32 
            return this.type_scope.f32_type.llvm_metadata
        if tt.kind == TypeKind.F64
            return this.type_scope.f64_type.llvm_metadata
        if tt.kind == TypeKind.PTR
            return this.create_pointer_type(tt as PointerType)
        if tt.kind == TypeKind.ARRAY
            return this.create_array_type(tt as ArrayType)
        if is_function(tt) {
            let funct_type = this.create_function_type(tt as FunctionType, this.get_current_file())
            return LLVMDIBuilderCreatePointerType(
                Builder: this.builder, 
                PointeeTy: funct_type,
                SizeInBits: this.ptr_size,
                AlignInBits: 0, 
                AddressSpace: 0,
                Name: "<fnc>", 
                NameLen: 5
            )
        }
        if tt.kind == TypeKind.ENUM
            return this.get_enum_type(tt as EnumType)
        if is_object(tt)
            return this.get_object_type(tt as ObjectType)
        if tt.kind == TypeKind.GENERIC_VARIABLE
            return this.create_or_get_type((tt as GenericTypeVariable).current_instance)
        return this.type_scope.null_type.llvm_metadata
    }
    public get_int_type(this, int_type: IntType): LLVMMetadataRef {
        if int_type.kind == TypeKind.I4
            return int_type.is_signed ? this.type_scope.i4_type.llvm_metadata : this.type_scope.u4_type.llvm_metadata
        if int_type.kind == TypeKind.I8
            return int_type.is_signed ? this.type_scope.i8_type.llvm_metadata : this.type_scope.u8_type.llvm_metadata
        if int_type.kind == TypeKind.I16
            return int_type.is_signed ? this.type_scope.i16_type.llvm_metadata : this.type_scope.u16_type.llvm_metadata
        if int_type.kind == TypeKind.I32
            return int_type.is_signed ? this.type_scope.i32_type.llvm_metadata : this.type_scope.u32_type.llvm_metadata
        if int_type.kind == TypeKind.INT
            return int_type.is_signed ? this.type_scope.int_type.llvm_metadata : this.type_scope.uint_type.llvm_metadata
        if int_type.kind == TypeKind.I64
            return int_type.is_signed ? this.type_scope.i64_type.llvm_metadata : this.type_scope.u64_type.llvm_metadata
        else // int_type.kind == TypeKind.I128
            return int_type.is_signed ? this.type_scope.i128_type.llvm_metadata : this.type_scope.u128_type.llvm_metadata
    }
    public get_enum_type(this, enum_type: EnumType): LLVMMetadataRef {
        return this.type_scope.get_record_from_typeid(enum_type.enum_id).llvm_metadata
    }
    public get_object_type(this, object_type: ObjectType): LLVMMetadataRef {
        if object_type.kind == TypeKind.GENERIC_VARIABLE
            return this.get_object_type((object_type as GenericTypeVariable).current_instance as ObjectType)
        while object_type.kind == TypeKind.RESOLVED_GENERIC
            object_type = (object_type as GenericType).instantiated_type as ObjectType
        let class_ty = this.type_scope.get_record_from_typeid(object_type.class_id)
        if (class_ty == null) panic("Cannot find undeclared object $(this.program.get_class_from_type(object_type).name)")
        return LLVMDIBuilderCreatePointerType(
            Builder: this.builder,
            PointeeTy: class_ty.llvm_metadata,
            SizeInBits: this.ptr_size,
            AlignInBits: 0,
            AddressSpace: 0,
            Name: "",
            NameLen: 0
        )
    }
    public create_pointer_type(this, pointer_type: PointerType): LLVMMetadataRef {
        let pointee_type = this.create_or_get_type(pointer_type.pointee_type)
        let pointee_name_length = 0
        let point_name = LLVMDITypeGetName(pointee_type, &pointee_name_length)
        let pointer_name = new u8*(pointee_name_length + 1)
        pointer_name.copy_from(point_name, pointee_name_length)
        pointer_name[pointee_name_length] = '*'
        return LLVMDIBuilderCreatePointerType(
                    Builder: this.builder,
                    PointeeTy: pointee_type,
                    SizeInBits: this.ptr_size,
                    AlignInBits: 0,
                    AddressSpace: 0,
                    Name: pointer_name,
                    NameLen: pointee_name_length + 1
                )
    }
    public get_type_list(this, types: Type[], dest: LLVMMetadataRef*){
        let i = 1
        for atype in types {
            dest[i++] = this.create_or_get_type(atype)
        }
    }
    public create_array_type(this, arr_type: ArrayType): LLVMMetadataRef {
        let element_type = this.create_or_get_type(arr_type.element_type)
        return LLVMDIBuilderCreateArrayType(this.builder, arr_type.length,
                            LLVMDITypeGetSizeInBits(element_type) as u32, element_type,
                            &element_type,
                           0)
    }
    public create_function_type(this, fnc_type: FunctionType, file: LLVMMetadataRef): LLVMMetadataRef {
        let params: LLVMMetadataRef*(fnc_type.param_types.length + 1)
        params[0] = this.create_or_get_type(fnc_type.return_type)
        this.get_type_list(fnc_type.param_types, params)
        return LLVMDIBuilderCreateSubroutineType(this.builder, file,
                                  params, fnc_type.param_types.length + 1,
                                  LLVMDIFlags.LLVMDIFlagZero
                                )
    }
    public create_enumerator(this, name: String, value: i64, is_unsigned: bool): LLVMMetadataRef {
        return LLVMDIBuilderCreateEnumerator(this.builder, name.get_bytes(), name.length, value, is_unsigned)
    }
    public create_function(this, func: Function): LLVMMetadataRef {
        let file = this.get_or_create_file(func.id.module_id)
        return LLVMDIBuilderCreateFunction(this.builder, file, func.name.get_bytes(),
                    func.name.length, "", 0,
                    file, func.definition_range.line, this.create_function_type(func.fnc_type, file),
                    true, true,
                    func.block.range.line, LLVMDIFlags.LLVMDIFlagPrototyped, false)
    }
    public finalize_subprogram(this, program: LLVMMetadataRef){
        LLVMDIBuilderFinalizeSubprogram(this.builder, program)
    }
    public create_method(this, method: ClassMethod): LLVMMetadataRef {
        let file = this.get_or_create_file(this.program.get_class_from_prop_id(method.id).id.module_id)
        return LLVMDIBuilderCreateFunction(this.builder, file, method.name.get_bytes(),
                    method.name.length, "", 0,
                    file, method.definition_range.line, this.create_function_type(method.method_type, file),
                    true, true,
                    method.block.range.line, LLVMDIFlags.LLVMDIFlagPrototyped, false)
    }
    public create_enum_type(this, enum_id: EnumId, name: String, range: TextRange, elements: LLVMMetadataRef*, num_elements: uint, enum_field_type: Type): LLVMMetadataRef {
        let file = this.get_or_create_file(enum_id.module_id)
        let meta_field_type = this.create_or_get_type(enum_field_type)
        return LLVMDIBuilderCreateEnumerationType(
            this.builder, file, name.get_bytes(),
            name.length, file, range.line,
            LLVMDITypeGetSizeInBits(meta_field_type), LLVMDITypeGetAlignInBits(meta_field_type), elements,
            num_elements, null)
    }
    public create_struct_type(this, class_id: ClassId, name: String, range: TextRange, elements: LLVMMetadataRef*, num_elements: uint, llvm_type: LLVMTypeRef): LLVMMetadataRef {
        let file = this.get_or_create_file(class_id.module_id)
        let size = LLVMABISizeOfType(this.target_data, llvm_type) * 8
        return LLVMDIBuilderCreateStructType(
        Builder: this.builder, Scope: file, Name: name.get_bytes(),
        NameLen: name.length, File: file, LineNumber: range.line,
        SizeInBits: size, AlignInBits: 0, LLVMDIFlags.LLVMDIFlagZero,
        DerivedFrom: null, Elements: elements,
        NumElements: num_elements, RunTimeLang: 0, VTableHolder: null,
        UniqueId: null, UniqueIdLen: 0)
    }
    public create_temp_compound_type(this, module_id: uint, name: String, id: uint, range: TextRange): LLVMMetadataRef {
        let file = this.get_or_create_file(module_id)
        return LLVMDIBuilderCreateReplaceableCompositeType(
        Builder: this.builder, Tag: id, Name: name.get_bytes(),
        NameLen: name.length, Scope: file, File: file, Line: range.line,
        RuntimeLang: 0, SizeInBits: this.ptr_size, AlignInBits: 0,
        Flags: LLVMDIFlags.LLVMDIFlagZero, UniqueIdentifier: null,
        UniqueIdentifierLen: 0)
    }
    private access_attr_to_diFlag(visibility: ACCESS_ATTR): LLVMDIFlags {
        if visibility == ACCESS_ATTR.PRIVATE
            return LLVMDIFlags.LLVMDIFlagPrivate
        else if visibility == ACCESS_ATTR.PROTECTED
            return LLVMDIFlags.LLVMDIFlagProtected 
        return LLVMDIFlags.LLVMDIFlagPublic
    }
    public create_member_type(this, class_id: ClassId, name: String, range: TextRange, member_type: Type, visibility: ACCESS_ATTR, offset: u64*): LLVMMetadataRef {
        let file = this.get_or_create_file(class_id.module_id)
        let metadata_type = this.create_or_get_type(member_type)
        let size = LLVMDITypeGetSizeInBits(metadata_type)
        let align = LLVMDITypeGetAlignInBits(metadata_type)
        let member_offset_in_bits = offset[0]
        offset[0] += size

        return LLVMDIBuilderCreateMemberType(
            this.builder, Scope: file, name.get_bytes(),
            name.length, file, range.line,
            size, align, member_offset_in_bits,
            Flags: DebugInfo.access_attr_to_diFlag(visibility),
            metadata_type)
    }
    public create_static_member_type(this, class_id: ClassId, name: String, range: TextRange, member_type: Type, visibility: ACCESS_ATTR, initializer: LLVMValueRef): LLVMMetadataRef {
        let file = this.get_or_create_file(class_id.module_id)
        let metadata_type = this.create_or_get_type(member_type)
        let align = LLVMDITypeGetAlignInBits(metadata_type)

        return LLVMDIBuilderCreateStaticMemberType(
            this.builder, Scope: file, name.get_bytes(),
            name.length, file, range.line,
            metadata_type, 
            Flags: DebugInfo.access_attr_to_diFlag(visibility),
            initializer, align)
    }
    public emit_location(this, builder: LLVMBuilderRef, expression: Expression){
        if(builder == null) return
        let range = expression.range
        let scope = this.lexical_blocks.peek()
        LLVMSetCurrentDebugLocation2(builder, LLVMDIBuilderCreateDebugLocation(this.ctx, range.line, range.col, scope, null))
    }
    public create_lexical_block(this, block: Block): LLVMMetadataRef {
        return LLVMDIBuilderCreateLexicalBlock(this.builder, this.lexical_blocks.peek(), this.get_current_file(), block.range.line, block.range.col)
    }
    public create_param_variable(this, dbg_fnc: LLVMMetadataRef, arg_num: uint, arg: FunctionParam): LLVMMetadataRef {
        let dbg_type = this.create_or_get_type(arg.value_type)
        return LLVMDIBuilderCreateParameterVariable(
            this.builder, dbg_fnc,
            arg.name.get_bytes(), arg.name.length,
            arg_num, this.get_current_file(), arg.range.line, dbg_type,
            true, LLVMDIFlags.LLVMDIFlagZero
        )
    }
    public create_auto_variable(this, module_id: uint, var_name: String, var_type: Type, var_range: TextRange): LLVMMetadataRef {
        let dbg_type = this.create_or_get_type(var_type)
        return LLVMDIBuilderCreateAutoVariable(
            this.builder, this.lexical_blocks.peek(), var_name.get_bytes(), var_name.length,
            this.get_or_create_file(module_id), var_range.line, dbg_type,
            true, LLVMDIFlags.LLVMDIFlagZero, LLVMDITypeGetAlignInBits(dbg_type)
        )
    }
    public insert_declare_before(this, value: LLVMValueRef, dbg_var: LLVMMetadataRef){
        let dbg_expression = LLVMDIBuilderCreateExpression(this.builder, null, 0)
        let scope = LLVMDIVariableGetScope(dbg_var)
        let dbg_loc = LLVMDIBuilderCreateDebugLocation(this.ctx, LLVMDIVariableGetLine(dbg_var), 0, scope, null)
        LLVMDIBuilderInsertDeclareBefore(this.builder, value, dbg_var, dbg_expression, dbg_loc, value)
    }
    public replace_temp_node_with(this, temp_node: LLVMMetadataRef, replacement: LLVMMetadataRef){
        LLVMMetadataReplaceAllUsesWith(temp_node, replacement)
    }
}
fnc get_intrinsic(mod: LLVMModuleRef, name: String, params_types: LLVMTypeRef*, params_length: uint, return_type: LLVMTypeRef, var_args = false): (LLVMTypeRef, LLVMValueRef) {
    let fnc_type = LLVMFunctionType(return_type, params_types, params_length, var_args)
    let fn_name = name.to_cstring()
    let llvm_fnc = LLVMGetNamedFunction(mod, fn_name)
    if llvm_fnc == null {
        llvm_fnc = LLVMAddFunction(mod, fn_name, fnc_type)
    }
    let result = (fnc_type, llvm_fnc)
    return result
}
fnc create_var_key(var_id: VarId): String {
    return "$(var_id.module_id);$(var_id.kind as int);$(var_id.id)"
}

fnc get_format_from_type(ty: Type): String {
    if (ty.kind == TypeKind.GENERIC_VARIABLE)
        return get_format_from_type((ty as GenericTypeVariable).current_instance)
    if is_int(ty){
        let is_signed_int = (ty as IntType).is_signed
        if ty.kind == TypeKind.I128 return is_signed_int ? "%lld" : "%llu"
        if ty.kind == TypeKind.I64 return is_signed_int ? "%ld" : "%lu"
        return is_signed_int ? "%d" : "%u"
    }
    if ty.kind == TypeKind.F32 
        return "%f"
    if ty.kind == TypeKind.F64
        return "%lf"
    if is_pointer(ty)
        return "0x%X"
    return "%s"
}
class CodeGen {
    private module: LLVMModuleRef
    private functions: Stack<LLVMValueRef>
    private break_bbs: Stack<LLVMBasicBlockRef>
    private continue_bbs: Stack<LLVMBasicBlockRef>
    private program: Program
    private global_var_scope: StringMap<LLVMValueRef>
    private global_string_scope: StringMap<LLVMValueRef>
    private debug_info: DebugInfo
    private classes_to_codegen: Class[]
    constructor(this, program: Program, module_name: String){
        this.program = program
        this.global_var_scope = new StringMap<LLVMValueRef>()
        this.global_string_scope = new StringMap<LLVMValueRef>()
        this.continue_bbs = new Stack<LLVMBasicBlockRef>()
        this.break_bbs = new Stack<LLVMBasicBlockRef>()
        this.functions = new Stack<LLVMValueRef>()
        this.module = LLVMModuleCreateWithName(module_name.to_cstring())
        this.debug_info = new DebugInfo(this.program, this.module, module_name)
        this.classes_to_codegen = []
        LLVMAddModuleFlag(this.module, LLVMModuleFlagBehavior.LLVMModuleFlagBehaviorWarning, "Debug Info Version", 18, LLVMValueAsMetadata(LLVMConstInt(this.debug_info.type_scope.i32_type.llvm_type, LLVMDebugMetadataVersion(), false)))
    }
    public codegen(program: Program): GeneratedModule{
        let module = program.modules[2]
        let codegen: CodeGen(program, module.name)
        for checked_enum in module.enums  {
            codegen.codegen_enum(checked_enum)
        }
        for checked_class in module.classes {
            codegen.declare_class(checked_class)
        }
        for checked_var in module.global_vars {
            codegen.codegen_var_declaration(null, checked_var)
        }
        for checked_function in module.functions {
            codegen.codegen_function(checked_function)
        }
        for let i = 0; i < codegen.classes_to_codegen.length; i++ {
            codegen.codegen_class(codegen.classes_to_codegen[i])
        }
        del program
        return new GeneratedModule(codegen.module)
    }
    private get_var_from_varid(this, var_id: VarId): LLVMValueRef{
        return this.global_var_scope[create_var_key(var_id)]
    }
    private add_var(this, var_id: VarId, value: LLVMValueRef){
        this.global_var_scope[create_var_key(var_id)] = value
    }
    private neg_int(builder: LLVMBuilderRef, val: LLVMValueRef): LLVMValueRef {
        return LLVMIsConstant(val) ? LLVMConstNeg(val) : LLVMBuildNeg(builder, val, "")
    }
    private createLLVMBool(this, val: bool): LLVMValueRef{
        return LLVMConstInt(this.debug_info.type_scope.bool_type.llvm_type, val ? 1 : 0 as u64, false)
    }
    private create_llvm_int(this, i: uint): LLVMValueRef {
        return LLVMConstInt(this.debug_info.type_scope.int_type.llvm_type, i as u64, false)
    }
    private codegen_type(this, tt: Type): LLVMTypeRef {
        while tt.kind == TypeKind.RESOLVED_GENERIC
            tt = (tt as GenericType).instantiated_type
        if tt.kind == TypeKind.VOID
            return this.debug_info.type_scope.void_type.llvm_type
        if tt.kind == TypeKind.BOOL
            return this.debug_info.type_scope.bool_type.llvm_type
        if tt.kind == TypeKind.I4
            return this.debug_info.type_scope.i4_type.llvm_type
        if tt.kind == TypeKind.I8
            return this.debug_info.type_scope.i8_type.llvm_type
        if tt.kind == TypeKind.I16
            return this.debug_info.type_scope.i16_type.llvm_type
        if tt.kind == TypeKind.I32
            return this.debug_info.type_scope.i32_type.llvm_type
        if tt.kind == TypeKind.INT
            return this.debug_info.type_scope.int_type.llvm_type
        if tt.kind == TypeKind.I64
            return this.debug_info.type_scope.i64_type.llvm_type
        if tt.kind == TypeKind.I128
            return this.debug_info.type_scope.i128_type.llvm_type
        if tt.kind == TypeKind.F32 
            return this.debug_info.type_scope.f32_type.llvm_type
        if tt.kind == TypeKind.F64
            return this.debug_info.type_scope.f64_type.llvm_type
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegen_type((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.GENERIC_VARIABLE
            return this.codegen_type((tt as GenericTypeVariable).current_instance)
        if tt.kind == TypeKind.ARRAY
            return this.codegen_array_type(tt as ArrayType)
        if tt.kind == TypeKind.TUPLE
            return this.codegen_tuple_type(tt as TupleType)
        if tt.kind == TypeKind.ENUM 
            return this.codegen_enum_type(tt as EnumType)
        if is_function(tt) 
            return LLVMPointerType(this.codegen_function_type(tt as FunctionType))
        if tt.kind == TypeKind.OBJECT
            return LLVMPointerType(this.codegen_class_type(tt as ObjectType))

        panic("Type could not be code generated")
        return null
    }
    private codegen_array_type(this, array_type: ArrayType): LLVMTypeRef {
        let element_type = this.codegen_type(array_type.element_type)
        return LLVMArrayType(element_type, array_type.length)
    }
    private codegen_tuple_type(this, tuple_type: TupleType): LLVMTypeRef {
        let element_types: LLVMTypeRef*(tuple_type.element_types.length)
        let idx = 0
        for element_type in tuple_type.element_types {
            element_types[idx++] = this.codegen_type(element_type)
        }
        return LLVMStructType(element_types, idx, false)
    }
    private codegen_function_type(this, fnc_type: FunctionType): LLVMTypeRef {
        let param_types: LLVMTypeRef*(fnc_type.param_types.length)
        let idx = 0
        for param_type in fnc_type.param_types {
            param_types[idx++] = this.codegen_type(param_type)
        }
        return LLVMFunctionType(this.codegen_type(fnc_type.return_type), param_types, fnc_type.param_types.length, false)
    }
    private codegen_class_type(this, object_type: ObjectType): LLVMTypeRef {
        return this.get_or_codegen_class_from_typeid(object_type.class_id).llvm_type
    }
    private codegen_enum_type(this, enum_type: EnumType): LLVMTypeRef {
        return this.get_or_codegen_enum_from_typeid(enum_type.enum_id).llvm_type
    }
    private codegen_return_stmt(this, builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value != null {
            let expression = this.codegen_expression(builder, return_stmt.return_value)
            if return_stmt.return_value.value_type.kind != TypeKind.VOID {
                LLVMBuildRet(builder, expression)
                return
            }
        }
        LLVMBuildRetVoid(builder)
    }
    private codegen_int(this, int_exp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegen_type(int_exp.value_type), int_exp.value, true)
    }
    private codegen_float(this, float_exp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegen_type(float_exp.value_type), float_exp.value)
    }
    private codegen_bool(this, bool_exp: BooleanExpression): LLVMValueRef {
        let val = bool_exp.value
        return this.createLLVMBool(val)
    }
    private codegen_atof_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)]
        let args: LLVMValueRef[1] = [arg]
        let atof = get_intrinsic(this.module, "atof", &arg_types[0], arg_types.size, this.debug_info.type_scope.f64_type.llvm_type)
        return LLVMBuildCall2(builder, atof[0], atof[1], &args[0], args.size, "")
    }
    private codegen_atoi_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)]
        let args: LLVMValueRef[1] = [arg]
        let atoi = get_intrinsic(this.module, "atoi", &arg_types[0], arg_types.size, this.debug_info.type_scope.i32_type.llvm_type)
        return LLVMBuildCall2(builder, atoi[0], atoi[1], &args[0], args.size, "")
    }
    private codegen_atol_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)]
        let args: LLVMValueRef[1] = [arg]
        let atol = get_intrinsic(this.module, "atol", &arg_types[0], arg_types.size, this.debug_info.type_scope.i64_type.llvm_type)
        return LLVMBuildCall2(builder, atol[0], atol[1], &args[0], args.size, "")
    }
    private codegen_realloc_call(this, builder: LLVMBuilderRef, args: LLVMValueRef*): LLVMValueRef {
        let i8_ptr_ty = LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)
        let arg_types: LLVMTypeRef[2] = [i8_ptr_ty, this.debug_info.type_scope.int_type.llvm_type]
        let realloc = get_intrinsic(this.module, "realloc", &arg_types[0], arg_types.size, i8_ptr_ty)
        return LLVMBuildCall2(builder, realloc[0], realloc[1], args, arg_types.size, "")
    }
    private codegen_memcmp_call(this, builder: LLVMBuilderRef, args: LLVMValueRef*): LLVMValueRef {
        let i8_ptr_ty = LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)
        let int_ty = this.debug_info.type_scope.int_type.llvm_type
        let arg_types: LLVMTypeRef[3] = [i8_ptr_ty, i8_ptr_ty, int_ty]
        let memcmp = get_intrinsic(this.module, "memcmp", &arg_types[0], arg_types.size, int_ty)
        return LLVMBuildCall2(builder, memcmp[0], memcmp[1], args, arg_types.size, "")
    }
    private codegen_del_call(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_ty: ObjectType, range: TextRange): LLVMValueRef {
        let func_type: FunctionType
        let func = this.codegen_get_member_with_name(builder, self, obj_ty, "__del__", range, &func_type)
        if func == null return null
        let args: LLVMValueRef[1] = [self]
        return LLVMBuildCall2(builder, this.codegen_function_type(func_type), func, &args[0], args.size, "")
    }
    private createGlobalLLVMString(this, builder: LLVMBuilderRef, str_value: String): LLVMValueRef {
        let str = this.global_string_scope[str_value]
        if str == null {
            str = LLVMBuildGlobalString(builder, str_value.to_cstring(), "")
            this.global_string_scope[str_value] = str
        }
        return str
    }
    private codegen_safe_fmt_string(this, builder: LLVMBuilderRef, fmt: String, args: LLVMValueRef*, args_length: uint, len_ptr: LLVMValueRef*): LLVMValueRef {
        let i8_ptr_ty = LLVMPointerType(this.debug_info.type_scope.u8_type.llvm_type)
        let alloc_buff = LLVMBuildAlloca(builder, i8_ptr_ty, "")
        let llvm_fmt = this.createGlobalLLVMString(builder, fmt)
        let num_passed_args = args_length + 2
        let call_args_buffer: LLVMValueRef*(num_passed_args)
        call_args_buffer[0] = alloc_buff
        call_args_buffer[1] = llvm_fmt
        (call_args_buffer + 2).copy_from(args, args_length)
        let arg_types: LLVMTypeRef[2] = [i8_ptr_ty, i8_ptr_ty]
        let asprintf = get_intrinsic(this.module, "asprintf", &arg_types[0], arg_types.size, this.debug_info.type_scope.int_type.llvm_type, true)
        let str_len = LLVMBuildCall2(builder, asprintf[0], asprintf[1], call_args_buffer, num_passed_args, "")
        if len_ptr != null {
            len_ptr[0] = str_len
        }
        return LLVMBuildLoad2(builder, i8_ptr_ty, alloc_buff, "")
    }
    private get_string_val(this, builder: LLVMBuilderRef, llvm_val: LLVMValueRef, val_ty: Type, malloc_list: LLVMValueRef[], range: TextRange, depth = 0): LLVMValueRef {
        if is_bool(val_ty){
            let true_str = this.createGlobalLLVMString(builder, "true")
            let false_str = this.createGlobalLLVMString(builder, "false")
            return LLVMBuildSelect(builder, llvm_val, true_str, false_str, "")
        }
        if is_object(val_ty){
            if this.program.is_buitin(val_ty, "String") {
                let result = this.codegen_string_to_cstring(builder, llvm_val, range)
                malloc_list << result
                return result
            }
            //TODO: will need to check for nullable
            let obj_class = this.program.get_class_from_type(val_ty)
            let string_value = String.with_capacity(obj_class.name.length + 14)
            string_value += "$(obj_class.name) {\n"
            if depth == 3 {
                string_value += " ... }"
                return this.createGlobalLLVMString(builder, string_value)
            }
            let fmt_args_length = obj_class.prop_map.length
            let fmt_args: LLVMValueRef*(fmt_args_length)
            let idx = 0
            for field_entry in obj_class.prop_map {
                let field_ty = this.program.get_class_prop_type(field_entry.value)
                let member_val = this.codegen_get_member_with_name(builder, llvm_val, val_ty as ObjectType, field_entry.key, range)
                let arg = this.get_string_val(builder, member_val, field_ty, malloc_list, range, depth + 1)
                if !is_object(field_ty) and LLVMGetTypeKind(LLVMTypeOf(arg)) == LLVMTypeKind.LLVMPointerTypeKind and !LLVMIsGlobalConstant(arg) {
                    malloc_list << arg
                }
                fmt_args[idx++] = arg
                string_value += " '$(field_entry.key)': $(get_format_from_type(field_ty)), \n"
            }
            string_value +="}"
            let result = this.codegen_safe_fmt_string(builder, string_value, fmt_args, fmt_args_length, null)
            malloc_list << result
            return result
        }
        if is_function(val_ty) {
            return this.createGlobalLLVMString(builder, "<fnc>")
        }
        //TODO: print enums, tuples, arrays
        return llvm_val
    }
    private codegen_string(this, builder: LLVMBuilderRef, string_exp: StringExpression): LLVMValueRef {
        let str_value = string_exp.value
        let fmt_string = String.with_capacity(str_value.length + string_exp.fmt_indices.length*2)
        let chars = str_value.get_bytes()
        let curr_ind = 0
        let prev_ind = 0
        let malloc_list: LLVMValueRef[] = []
        let call_args_length = string_exp.template_args.length
        let call_args: LLVMValueRef*(call_args_length)
        for let i = 0; i < call_args_length; i++ {
            let templ_arg = string_exp.template_args[i]
            let templ_arg_ty = templ_arg.value_type
            let fmt = get_format_from_type(templ_arg_ty)
            prev_ind = curr_ind
            curr_ind = string_exp.fmt_indices[i]
            let incr = curr_ind - prev_ind
            fmt_string.append_bytes_length(chars, incr)
            fmt_string += fmt
            chars += incr
            let templ_arg_exp = this.codegen_expression(builder, templ_arg)
            call_args[i] = this.get_string_val(builder, templ_arg_exp, templ_arg_ty, malloc_list, string_exp.range)
        }
        fmt_string.append_bytes_length(chars, str_value.length - curr_ind)
        str_value = fmt_string
        let str_len = this.create_llvm_int(str_value.length)
        let str = call_args_length > 0 ? this.codegen_safe_fmt_string(builder, str_value, call_args, call_args_length, &str_len) : this.createGlobalLLVMString(builder, str_value)
        if is_object(string_exp.value_type) {
            let str_ty = this.codegen_class_type(string_exp.value_type as ObjectType)
            if LLVMIsConstant(str) and LLVMIsGlobalConstant(str) {
                let func = LLVMGetNamedFunction(this.module, "String_from_bytes")
                if func == null {
                    panic("Could not find function 'String.from_bytes' in program")
                }
                let args: LLVMValueRef[2] = [str, str_len]
                str = LLVMBuildCall2(builder, LLVM_GetFunctionType(func), func, &args[0], args.size, "")
            } else {
                let self = LLVMBuildMalloc(builder, str_ty, "")
                let args: LLVMValueRef[3] = [self, str, str_len] 
                this.build_constructor_call(builder, string_exp.value_type as ObjectType, &args[0], args.size)
                str = self
            }
        }
        for mem in malloc_list {
            LLVMBuildFree(builder, mem)
        }
        return str
    }
    private store_array_elements(this, builder: LLVMBuilderRef, ptr: LLVMValueRef, array_exp: ArrayExpression): LLVMValueRef {
        let next_indices: LLVMValueRef[1] = [this.create_llvm_int(1)]
        let ptr_ty = LLVMTypeOf(ptr)
        let addr = ptr
        for value in array_exp.elements {
            LLVMBuildStore(builder, this.codegen_expression(builder, value), addr)
            addr = LLVMBuildInBoundsGEP2(builder, ptr_ty, addr, &next_indices[0], next_indices.size, "")
        }
        return addr
    }
    private store_tuple_elements(this, builder: LLVMBuilderRef, ptr: LLVMValueRef, tuple_exp: TupleExpression): LLVMValueRef {
        let int32ty = this.debug_info.type_scope.i32_type.llvm_type
        let next_indices: LLVMValueRef[2] = [LLVMConstInt(int32ty, 0, false), null]
        let idx: u64 = 0
        let tuple_type = this.codegen_type(tuple_exp.value_type)
        for value in tuple_exp.elements {
            next_indices[1] = LLVMConstInt(int32ty, idx++, false)
            let addr = LLVMBuildInBoundsGEP2(builder, tuple_type, ptr, &next_indices[0], next_indices.size, "")
            LLVMBuildStore(builder, this.codegen_expression(builder, value), addr)
        }
        return ptr
    }
    private codegen_array_exp(this, builder: LLVMBuilderRef, array_exp: ArrayExpression): LLVMValueRef {
        if array_exp.value_type.kind == TypeKind.RESOLVED_GENERIC {
            return this.codegen_builtin_array(builder, array_exp.value_type as GenericType, array_exp)
        } 
        //FIXME: What if array is not constant?
        if !array_exp.is_constant {
            panic("Array expression is not a constant (codegen_array_exp)")
        }
        let elem_ty = this.codegen_type((array_exp.value_type as ArrayType).element_type)
        let elems_buffer: LLVMValueRef*(array_exp.elements.length)
        let idx = 0
        for value in array_exp.elements {
            elems_buffer[idx++] = this.codegen_expression(builder, value)
        }
        return LLVMConstArray(elem_ty, elems_buffer, array_exp.elements.length)
    }
    private codegen_tuple_exp(this, builder: LLVMBuilderRef, tuple_exp: TupleExpression): LLVMValueRef {
        //FIXME: What if tuple is not constant?
        if !tuple_exp.is_constant {
            panic("Array expression is not a constant (codegen_tuple_exp)")
        }
        let elems_buffer: LLVMValueRef*(tuple_exp.elements.length)
        let idx = 0
        for value in tuple_exp.elements {
            elems_buffer[idx++] = this.codegen_expression(builder, value)
        }
        return LLVMConstStruct(elems_buffer, idx, false)
    }
    private get_or_codegen_var(this, target_id: VarId): LLVMValueRef {
        let var = this.get_var_from_varid(target_id)
        if var != null return var
        // We need to find this var..
        let module = this.program.modules[target_id.module_id]
        if target_id.kind == VarIdKind.VAR or target_id.kind == VarIdKind.CONST {
            for global_var in module.global_vars {
                let var_id = global_var.var_id
                if var_id.id == target_id.id {
                    this.codegen_var_declaration(null, global_var)
                    return this.get_var_from_varid(target_id)
                }
            }
        }
        if target_id.kind == VarIdKind.FNC {
            for function in module.functions {
                let fnc_id = function.id
                if fnc_id.id == target_id.id {
                    this.codegen_function(function)
                    return this.get_var_from_varid(target_id)
                }
            }
        }
        return null
    }
    private get_or_codegen_class_from_typeid(this, ty_id: TypeId): GeneratedRecordType {
        let cg_class = this.debug_info.type_scope.get_record_from_typeid(ty_id)
        if cg_class != null return cg_class
        let checked_class = this.program.get_class(ty_id as ClassId)
        this.declare_class(checked_class)
        return this.debug_info.type_scope.get_record_from_typeid(checked_class.id)
    }
    private get_or_codegen_enum_from_typeid(this, ty_id: TypeId): GeneratedRecordType {
        let cg_enum = this.debug_info.type_scope.get_record_from_typeid(ty_id)
        if cg_enum != null return cg_enum
        let enum_ = this.program.get_enum(ty_id as EnumId)
        this.codegen_enum(enum_)
        return this.debug_info.type_scope.get_record_from_typeid(enum_.id)
    }
    private get_var_expr_mem(this, builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let ptr = this.get_or_codegen_var(var_exp.value_id)
        if ptr == null {
            panic("This should never happen! (get_expr_mem: var)")
        }
        return ptr
    }
    private get_index_expr_mem(this, builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let index = this.codegen_expression(builder, index_exp.index)
        let expr_val_ty = index_exp.expression.value_type
        let ty = is_pointer(expr_val_ty) ? this.codegen_type((expr_val_ty as PointerType).pointee_type) : this.codegen_type(expr_val_ty)
        let ind_ptr: LLVMValueRef = null
        if expr_val_ty.kind == TypeKind.ARRAY {
            let indices: LLVMValueRef[2] = [this.create_llvm_int(0), index]
            ind_ptr = this.get_expr_mem(builder, index_exp.expression)
            return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices[0], indices.size, "")
        }
        if expr_val_ty.kind == TypeKind.TUPLE {
            let int32ty = this.debug_info.type_scope.i32_type.llvm_type
            let indices: LLVMValueRef[2] = [LLVMConstInt(int32ty, 0, false), LLVMConstIntCast(index, int32ty, false)]
            ind_ptr = this.get_expr_mem(builder, index_exp.expression)
            return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices[0], indices.size, "")
        }
        let indices_1: LLVMValueRef[1] = [index]
        ind_ptr = this.codegen_expression(builder, index_exp.expression)
        return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices_1[0], indices_1.size, "")
    }
    private get_member_expr_mem(this, builder: LLVMBuilderRef, member_expr: MemberExpression, ptr: LLVMValueRef): LLVMValueRef {
        let struct_class = this.get_or_codegen_class_from_typeid(member_expr.member_id.type_id)
        let struct_type = struct_class.llvm_type
        let method = struct_class.get_field(member_expr.member_id)
        if method != null {
            return method.llvm_value
        }
        if ptr == null {
            ptr = this.codegen_expression(builder, member_expr.expression)
        }
        let i32_llvm_type = this.debug_info.type_scope.i32_type.llvm_type
        let indices_buffer: LLVMValueRef[2] = [LLVMConstInt(i32_llvm_type, 0, false), null]
        indices_buffer[1] = LLVMConstInt(i32_llvm_type, this.program.get_field_offset(member_expr.member_id) as u64, false)
        return LLVMBuildInBoundsGEP2(builder, struct_type, ptr, &indices_buffer[0], indices_buffer.size, "memberidx")
    }
    private get_expr_mem(this, builder: LLVMBuilderRef, exp: Expression): LLVMValueRef {
        if exp.expr_kind == ExpressionKind.ACCESS
            return this.get_var_expr_mem(builder, exp as VarAccessExpression)
        if exp.expr_kind == ExpressionKind.INDEX
            return this.get_index_expr_mem(builder, exp as IndexExpression)
        if exp.expr_kind == ExpressionKind.MEMBER
            return this.get_member_expr_mem(builder, exp as MemberExpression, null)
        return this.codegen_expression(builder, exp)
    }
    // Only call for non-static members.
    private codegen_get_member_mem_with_name(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_type: ObjectType, name: String, range: TextRange, save_type: Type* = null): LLVMValueRef {
        let obj_class = this.program.get_class_from_type(obj_type)
        let prop_id = obj_class.prop_map[name]
        if prop_id == null  return null
        let prop_ty = this.program.get_class_prop_type(prop_id)
        if save_type != null save_type[0] = prop_ty
        let expr: Expression(ExpressionKind.ACCESS, obj_type, range)
        let member_expr: MemberExpression(expr, prop_id, prop_ty, range)
        return this.get_member_expr_mem(builder, member_expr, self)
    }
    // Only call for non-static members.
    private codegen_get_member_with_name(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_type: ObjectType, name: String, range: TextRange, save_type: Type* = null): LLVMValueRef {
        let obj_class = this.program.get_class_from_type(obj_type)
        let prop_id = obj_class.prop_map[name]
        if prop_id == null  return null
        let prop_ty = this.program.get_class_prop_type(prop_id)
        if save_type != null save_type[0] = prop_ty
        let expr: Expression(ExpressionKind.ACCESS, obj_type, range)
        let member_expr: MemberExpression(expr, prop_id, prop_ty, range)
        return this.codegen_member_exp(builder, member_expr, self)
    }
    private codegen_builtin_array(this, builder: LLVMBuilderRef, arrgen_ty: GenericType, arr_expr: ArrayExpression): LLVMValueRef {
        let obj_type = (arrgen_ty as GenericType).instantiated_type as ObjectType
        this.debug_info.emit_location(builder, arr_expr)
        let objllvm_ty = this.codegen_class_type(obj_type)
        let elmllvm_ty = this.codegen_type(arrgen_ty.arg_types[0])
        let self = LLVMBuildMalloc(builder, objllvm_ty, "")
        let len_val = arr_expr.elements.length
        let size_value = this.create_llvm_int(len_val > 0 ? len_val: 1)
        let len_value = this.create_llvm_int(len_val)
        let args: LLVMValueRef[2] = [self, LLVMConstMul(size_value, LLVMSizeOf(elmllvm_ty))]
        this.build_constructor_call(builder, obj_type, &args[0], args.size)
        let arg_ptr = this.codegen_get_member_with_name(builder, self, obj_type, "buffer", arr_expr.range)
        this.store_array_elements(builder, arg_ptr, arr_expr)
        let len_ptr = this.codegen_get_member_mem_with_name(builder, self, obj_type, "length", arr_expr.range)
        LLVMBuildStore(builder, len_value, len_ptr)
        return self
    }
    private store_expr_to_mem(this, builder: LLVMBuilderRef, ptr: LLVMValueRef, expr: Expression): LLVMValueRef {
        let value: LLVMValueRef = null
        if expr.expr_kind == ExpressionKind.ARRAY and !expr.is_constant {
            let arr_expr = expr as ArrayExpression
            let value_ty = expr.value_type
            if value_ty.kind != TypeKind.RESOLVED_GENERIC {
                let zero = this.create_llvm_int(0)
                let indices: LLVMValueRef[2] = [zero, zero]
                let array_type = this.codegen_type(value_ty)
                ptr = LLVMBuildInBoundsGEP2(builder, array_type, ptr, &indices[0], indices.size, "")
                return this.store_array_elements(builder, ptr, arr_expr)
            }
            value = this.codegen_builtin_array(builder, value_ty as GenericType, arr_expr)
        } else if expr.expr_kind == ExpressionKind.TUPLE and !expr.is_constant {
            return this.store_tuple_elements(builder, ptr, expr as TupleExpression)
        } else {
            value = this.codegen_expression(builder, expr)
        }
        LLVMBuildStore(builder, value, ptr)
        return value
    }
    private codegen_assignment(this, builder: LLVMBuilderRef, assign_exp: BinaryExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, assign_exp.lhs)
        return this.store_expr_to_mem(builder, ptr, assign_exp.rhs)
    }
    private codegen_pow_expr(this, builder: LLVMBuilderRef, ty: Type,  lhs: LLVMValueRef, rhs: LLVMValueRef): LLVMValueRef {
        let args: LLVMValueRef[2] = [lhs, rhs]
        let name = "llvm.pow.$(dump_type(ty, true))"
        let llvmty = this.codegen_type(ty)
        let arg_types: LLVMTypeRef[2] = [llvmty, llvmty]
        let pow = get_intrinsic(this.module, name, &arg_types[0], arg_types.size, llvmty)
        return LLVMBuildCall2(builder, pow[0], pow[1], &args[0], args.size, "")
    }
    private codegen_int_comparason(this, builder: LLVMBuilderRef, op: BinaryOp, lhs: LLVMValueRef, rhs: LLVMValueRef, as_const: bool): LLVMValueRef {
        let ipred: LLVMIntPredicate = null
        if is_bin_op_comp_eq_op(op) {
            ipred = ((op as int) - (BinaryOp.EEQ as int) + 32) as LLVMIntPredicate
            return as_const ? LLVMConstICmp(ipred, lhs, rhs) : LLVMBuildICmp(builder, ipred, lhs, rhs, "")
        } else {
            ipred = ((op as int) - (BinaryOp.GT as int) + 38) as LLVMIntPredicate // Consider Enum variants
            return as_const ? LLVMConstICmp(ipred, lhs, rhs) : LLVMBuildICmp(builder, ipred, lhs, rhs, "")
        }
    }
    private codegen_float_comparason(this, builder: LLVMBuilderRef, op: BinaryOp, lhs: LLVMValueRef, rhs: LLVMValueRef, as_const: bool): LLVMValueRef {
        let rpred: LLVMRealPredicate = null
        if is_bin_op_comp_eq_op(op) {
            rpred = op == BinaryOp.NEQ ? LLVMRealPredicate.LLVMRealONE : LLVMRealPredicate.LLVMRealOEQ
            return as_const ? LLVMConstFCmp(rpred, lhs, rhs) : LLVMBuildFCmp(builder, rpred, lhs, rhs, "")
        } else {
            rpred = ((op as int) - (BinaryOp.GT as int) + (LLVMRealPredicate.LLVMRealOGT as int)) as LLVMRealPredicate
            return as_const ? LLVMConstFCmp(rpred, lhs, rhs) : LLVMBuildFCmp(builder, rpred, lhs, rhs, "")
        }
    }
    private codegen_bin_exp(this, builder: LLVMBuilderRef, bin_exp: BinaryExpression): LLVMValueRef {   
        let op = bin_exp.op
        
        let lty = bin_exp.lhs.value_type
        let rty = bin_exp.rhs.value_type
        if lty.kind != rty.kind {
            if op == BinaryOp.EEQ
                return this.createLLVMBool(false)
            else if op == BinaryOp.NEQ
                return this.createLLVMBool(true)
        }
        if (lty.kind == TypeKind.ARRAY or lty.kind == TypeKind.TUPLE) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            println("array or tuple comparison not yet supported.")
            return this.createLLVMBool(false)
        }

        if op == BinaryOp.ASSIGN
            return this.codegen_assignment(builder, bin_exp)
        let lhs = this.codegen_expression(builder, bin_exp.lhs)
        let rhs = this.codegen_expression(builder, bin_exp.rhs)
        if is_null_expression(bin_exp.rhs) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            if LLVMIsConstant(lhs)
                return this.createLLVMBool(op == BinaryOp.EEQ ? LLVMIsNull(lhs) : LLVMIsNull(lhs))
            return op == BinaryOp.EEQ ? LLVMBuildIsNull(builder, lhs, "") : LLVMBuildIsNotNull(builder, lhs, "")
        }
        if is_numeric(rty) and op == BinaryOp.POW
            return this.codegen_pow_expr(builder, rty, lhs, rhs)
        if is_pointer(lty) and (op == BinaryOp.ADD or op == BinaryOp.SUB) {
            let indices: LLVMValueRef[1] = [op == BinaryOp.ADD ? rhs: CodeGen.neg_int(builder, rhs)]
            let pointee_type = this.codegen_type((lty as PointerType).pointee_type)
            return LLVMBuildInBoundsGEP2(builder, pointee_type, lhs, &indices[0], indices.size, "")
        }
        let is_const_expr = LLVMIsConstant(lhs) and LLVMIsConstant(rhs)
            
        if ((is_object(lty) and is_object(rty)) or (is_pointer(lty) and is_pointer(rty))) and is_bin_op_comp_op(op) {
            let left_int = LLVMBuildPtrToInt(builder, lhs, this.debug_info.type_scope.int_type.llvm_type, "")
            let right_int = LLVMBuildPtrToInt(builder, rhs, this.debug_info.type_scope.int_type.llvm_type, "")
            return this.codegen_int_comparason(builder, op, left_int, right_int, false)
        } else if is_int(rty) or (rty.kind == TypeKind.ENUM) {
            if op == BinaryOp.ADD {
                if ((bin_exp.value_type as IntType).is_signed)
                    return is_const_expr ? LLVMConstNSWAdd(lhs, rhs) : LLVMBuildNSWAdd(builder, lhs, rhs, "")
                return is_const_expr ? LLVMConstNUWAdd(lhs, rhs) : LLVMBuildNUWAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                if ((bin_exp.value_type as IntType).is_signed)
                    return is_const_expr ? LLVMConstNSWSub(lhs, rhs) : LLVMBuildNSWSub(builder, lhs, rhs, "")
                return is_const_expr ? LLVMConstNUWSub(lhs, rhs) : LLVMBuildNUWSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                if ((bin_exp.value_type as IntType).is_signed)
                    return is_const_expr ? LLVMConstNSWMul(lhs, rhs) : LLVMBuildNSWMul(builder, lhs, rhs, "")
                return is_const_expr ? LLVMConstNUWMul(lhs, rhs) : LLVMBuildNUWMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                if ((bin_exp.value_type as IntType).is_signed)
                        return LLVMBuildSDiv(builder, lhs, rhs, "")
                    return LLVMBuildUDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                if ((bin_exp.value_type as IntType).is_signed)
                    return LLVMBuildSRem(builder, lhs, rhs, "")
                return LLVMBuildURem(builder, lhs, rhs, "")
            } else if is_bin_op_comp_op(op) {
                return this.codegen_int_comparason(builder, op, lhs, rhs, is_const_expr)
            } else if op == BinaryOp.SL {
                return is_const_expr ? LLVMConstShl(lhs, rhs) : LLVMBuildShl(builder, lhs, rhs, "")
            } else if op == BinaryOp.SR {
                return is_const_expr ? LLVMConstLShr(lhs, rhs) : LLVMBuildLShr(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.AND {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.XOR {
                return is_const_expr ? LLVMConstXor(lhs, rhs) : LLVMBuildXor(builder, lhs, rhs, "")
            }
        } else if is_float(rty) {
            if op == BinaryOp.ADD { 
                return LLVMBuildFAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return LLVMBuildFSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return LLVMBuildFMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildFDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildFRem(builder, lhs, rhs, "")
            } else if is_bin_op_comp_op(op) {
                return this.codegen_float_comparason(builder, op, lhs, rhs, is_const_expr)
            }
        } else if is_bool(rty) {
            if op == BinaryOp.AND or op == BinaryOp.EEQ {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.NEQ {
                return is_const_expr ? LLVMConstXor(lhs, rhs) : LLVMBuildXor(builder, lhs, rhs, "")
            }
        }
        panic("Unknown bin expression case case! $op")
        return lhs
    }
    private codegen_typecast_exp(this, builder: LLVMBuilderRef, type_exp: TypeCastExpression): LLVMValueRef {
        let exp = type_exp.expr
        let value_type = type_exp.value_type
        let val = this.codegen_expression(builder, exp)
        let ty = this.codegen_type(value_type)
        let is_const = LLVMIsConstant(val)
        if is_bool(value_type) {
            return is_const ? this.createLLVMBool(!LLVMIsNull(val)) : LLVMBuildIsNotNull(builder, val, "")
        }
        if is_int(exp.value_type) and is_float(value_type) {
            return is_const ? LLVMConstSIToFP(val, ty) : LLVMBuildSIToFP(builder, val, ty, "")
        } else if is_float(exp.value_type) and is_int(value_type) {
            return is_const ? LLVMConstFPToSI(val, ty) : LLVMBuildFPToSI(builder, val, ty, "")
        } else if is_int(exp.value_type) and is_int(value_type){ // FIXME: Enums?
            let int_ty = value_type as IntType
            return is_const ? LLVMConstIntCast(val, ty, int_ty.is_signed) : LLVMBuildIntCast2(builder, val, ty, int_ty.is_signed, "")
        } else if is_float(exp.value_type) and is_float(value_type){
            return is_const ? LLVMConstFPCast(val, ty) : LLVMBuildFPCast(builder, val, ty, "")
        }
        return is_const ? LLVMConstBitCast(val, ty) : LLVMBuildBitCast(builder, val, ty, "")
    }
    //TODO: Refactor!!
    private codegen_unary_exp(this, builder: LLVMBuilderRef, unary_exp: UnaryExpression): LLVMValueRef { 
        let op = unary_exp.op
        let exp = unary_exp.expression
        let val = this.codegen_expression(builder, exp)
        if op == UnaryOp.DEL {
            if is_object(exp.value_type)
                this.codegen_del_call(builder, val, exp.value_type as ObjectType, unary_exp.range)
            LLVMBuildFree(builder, val)
            return val
        }
        if op == UnaryOp.NEG {
            if is_int(exp.value_type){
                if (exp.value_type as IntType).is_signed
                    return LLVMIsConstant(val) ? LLVMConstNSWNeg(val) : LLVMBuildNSWNeg(builder, val, "")
                return LLVMIsConstant(val) ? LLVMConstNUWNeg(val) : LLVMBuildNUWNeg(builder, val, "")
            } else if is_float(exp.value_type){
                return LLVMBuildFNeg(builder, val, "")
            }
        } 
        if op == UnaryOp.NOT {
            return LLVMIsConstant(val) ? LLVMConstNot(val) : LLVMBuildNot(builder, val, "")
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR or op == UnaryOp.ADDROF {
            let ptr = this.get_expr_mem(builder, exp)
            if op == UnaryOp.ADDROF {
                return ptr
            }
            let alloc_ty = this.codegen_type(exp.value_type)
            let incr_value: i64 = op == UnaryOp.PREINCR or op == UnaryOp.POSTINCR ? 1 : -1
            let new_value: LLVMValueRef = null
            if is_pointer(exp.value_type) {
                alloc_ty = this.codegen_type((exp.value_type as PointerType).pointee_type)
                let indices: LLVMValueRef[1] = [LLVMConstInt(this.debug_info.type_scope.i32_type.llvm_type, incr_value as u64, true)]
                new_value = LLVMBuildInBoundsGEP2(builder, alloc_ty, val, &indices[0], indices.size, "incdec.ptr")
            } else if is_numeric(exp.value_type){
                let incr_amt = is_int(exp.value_type) ? LLVMConstInt(alloc_ty, incr_value as u64, false) : LLVMConstReal(alloc_ty, incr_value * 1.0 as f64)
                new_value = LLVMBuildNSWAdd(builder, val, incr_amt, "")
            }
            LLVMBuildStore(builder, new_value, ptr)
            return op >= UnaryOp.PREDECR ? val : new_value 
        }
        return val
    }
    private codegen_var_access_exp(this, builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let val = this.get_or_codegen_var(var_exp.value_id)
        let ty = this.codegen_type(var_exp.value_type)
        if val == null {
            panic("This should never happen; (codegen_var_access_exp)")
        }
        if var_exp.value_id.kind == VarIdKind.FNC
            return val
        if builder == null
            return LLVMGetInitializer(val)
        return LLVMBuildLoad2(builder, ty, val, "")
    }
    private codegen_null(this, null_exp: NullExpression): LLVMValueRef{
        return LLVMConstNull(this.codegen_type(null_exp.value_type))
    }
    private codegen_ternary_exp(this, builder: LLVMBuilderRef, ternary_exp: TernaryExpression): LLVMValueRef {
        let true_block = LLVMAppendBasicBlock(this.functions.peek(), "true_block")
        let false_block = LLVMAppendBasicBlock(this.functions.peek(), "false_block")
        let end = LLVMAppendBasicBlock(this.functions.peek(), "end")
        let cond = this.codegen_expression(builder, ternary_exp.cond)
        LLVMBuildCondBr(builder, cond, true_block, false_block)
        LLVMPositionBuilderAtEnd(builder, true_block)
        let is_true = this.codegen_expression(builder, ternary_exp.is_true)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, false_block)
        let is_false = this.codegen_expression(builder, ternary_exp.is_false)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, end)
        let phi_node = LLVMBuildPhi(builder, this.codegen_type(ternary_exp.is_true.value_type), "ternary")
        let incomming_vals: LLVMValueRef[2] = [is_true, is_false]
        let blocks: LLVMBasicBlockRef[2] = [true_block, false_block]
        LLVMAddIncoming(phi_node, &incomming_vals[0], &blocks[0], blocks.size)
        return phi_node
    }
    private codegen_match_case(this, builder: LLVMBuilderRef, switch: LLVMValueRef, expression: Expression, block: LLVMBasicBlockRef){
        if expression.expr_kind == ExpressionKind.BIN {
            let bin_expression = expression as BinaryExpression
            if bin_expression.op == BinaryOp.OR {
                this.codegen_match_case(builder, switch, bin_expression.lhs, block)
                this.codegen_match_case(builder, switch, bin_expression.rhs, block)
                return
            }
        }
        LLVMAddCase(switch, this.codegen_expression(builder, expression), block)
    }
    private codegen_match_exp(this, builder: LLVMBuilderRef, match_exp: MatchExpression): LLVMValueRef {
        let else_block = LLVMAppendBasicBlock(this.functions.peek(), "match.else")
        let end_block = LLVMAppendBasicBlock(this.functions.peek(), "match.end")
        let cases_size = match_exp.cases.length + 1
        let cases_blocks: LLVMBasicBlockRef*(cases_size)
        let yield_values: LLVMValueRef*(cases_size)
        let idx = 0
        let curr_block: LLVMBasicBlockRef = null
        let match_type = this.codegen_type(match_exp.value_type)
        let subject = this.codegen_expression(builder, match_exp.subject)
        let switch: LLVMValueRef = match_exp.use_ifs ? null : LLVMBuildSwitch(builder, subject, else_block, idx)
        for case in match_exp.cases {
            if curr_block != null {
                LLVMPositionBuilderAtEnd(builder, curr_block)
            }
            let case_block = LLVMAppendBasicBlock(this.functions.peek(), "match.case")
            if case.kind == MatchCaseKind.EEQ and (switch != null) {
                this.codegen_match_case(builder, switch, case.condition, case_block)
            } else {
                curr_block = (idx == match_exp.cases.length - 1) ? else_block : LLVMAppendBasicBlock(this.functions.peek(), "match.case.else")
                LLVMBuildCondBr(builder, this.codegen_expression(builder, case.condition), case_block, curr_block)
            }
            LLVMPositionBuilderAtEnd(builder, case_block)
            let yield_value = this.codegen_block(builder, case.block)
            LLVMBuildBr(builder, end_block)
            cases_blocks[idx] = case_block
            yield_values[idx++] = yield_value
        }
        LLVMPositionBuilderAtEnd(builder, else_block)
        cases_blocks[idx] = else_block
        yield_values[idx++] = this.codegen_block(builder, match_exp.else_block)
        LLVMBuildBr(builder, end_block)
        LLVMPositionBuilderAtEnd(builder, end_block)
        if match_exp.value_type.kind != TypeKind.VOID {
            let phi_node = LLVMBuildPhi(builder, match_type, "match.phi.node")
            LLVMAddIncoming(phi_node, yield_values, cases_blocks, idx)
            return phi_node
        }
        return null
    }
    /* TODO: Needs refactoring to remove array expression */
    private codegen_call_exp(this, builder: LLVMBuilderRef, call_exp: CallExpression): LLVMValueRef {
        let func: LLVMValueRef = null
        let args_value: LLVMValueRef[] = []
        if !(is_function(call_exp.callee.value_type )) panic("codegen_call_exp: callee is not a function")
        if ((call_exp.callee.value_type as FunctionType).has_implicit_this) and (call_exp.callee.expr_kind == ExpressionKind.MEMBER) {
            let member_exp = call_exp.callee as MemberExpression
            let struct_class = this.get_or_codegen_class_from_typeid(member_exp.member_id.type_id)
            let self = this.codegen_expression(builder, member_exp.expression)
            func = this.codegen_member_exp(builder, member_exp, self)
            args_value << self
        } else {
            func = this.codegen_expression(builder, call_exp.callee)
        }
        for call_arg in call_exp.args {
            args_value << this.codegen_expression(builder, call_arg)
        }
        return LLVMBuildCall2(builder, this.codegen_function_type(call_exp.callee.value_type as FunctionType), func, args_value.buffer, args_value.length, "")
    }
    private codegen_index_exp(this, builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, index_exp)
        return LLVMBuildLoad2(builder, this.codegen_type(index_exp.value_type), ptr, "")
    }
    private codegen_new_exp(this, builder: LLVMBuilderRef, new_expr: NewExpression): LLVMValueRef {
        let ptr: LLVMValueRef = null
        let alloc_ty = new_expr.memory_type
        let llvm_type: LLVMTypeRef = null
        if is_pointer(new_expr.value_type) {
            llvm_type = this.codegen_type(alloc_ty)
            let size = this.codegen_expression(builder, new_expr.args[0])
            if new_expr.onheap {
                ptr = LLVMBuildArrayMalloc(builder, llvm_type, size, "")
            } else {
                ptr = LLVMBuildArrayAlloca(builder, llvm_type, size, "")
            }
        } else if is_object(alloc_ty) {
            let args_length = new_expr.args.length + 1
            let args: LLVMValueRef*(args_length)
            llvm_type = this.codegen_class_type(alloc_ty as ObjectType)
            if new_expr.onheap {
                ptr = LLVMBuildMalloc(builder, llvm_type, "")
            } else {
                ptr = LLVMBuildAlloca(builder, llvm_type, "")
            }
            args[0] = ptr
            this.evaluate_expression_list(builder, args, 1, new_expr.args)
            this.build_constructor_call(builder, alloc_ty as ObjectType, args, args_length)
        }
        return ptr
    }
    private codegen_member_exp(this, builder: LLVMBuilderRef, member_exp: MemberExpression, self: LLVMValueRef): LLVMValueRef {
        if is_object(member_exp.expression.value_type) {
            let ptr = this.get_member_expr_mem(builder, member_exp, self)
            if is_function(member_exp.value_type)
                return ptr
            return LLVMBuildLoad2(builder, this.codegen_type(member_exp.value_type), ptr, "")
        }
        let var_id = (member_exp.expression as VarAccessExpression).value_id
        if var_id.kind == VarIdKind.CLASS {
            let struct_class = this.get_or_codegen_class_from_typeid(ClassVarId.to_class_id(var_id))
            if struct_class == null {
                panic("this should not happen; (codegen_member_exp); class")
            }
            let prop = struct_class.get_field(member_exp.member_id)
            if prop == null {
                panic("This should never happen; (codegen_member_expr; class prop)")
            }
            if is_function(member_exp.value_type)
                return prop.llvm_value
            return LLVMBuildLoad2(builder, this.codegen_type(member_exp.value_type), prop.llvm_value, "")
        }
        if var_id.kind == VarIdKind.ENUM {
           let enum_type = this.get_or_codegen_enum_from_typeid(EnumVarId.to_enum_id(var_id)) 
            if enum_type == null {
                panic("this should not happen; (codegen_member_exp); enum")
            }
            let field = enum_type.get_field(member_exp.member_id)
            if (field == null ){
                panic("this should not happen; (codegen_member_exp); enum->field")
            }
            return field.llvm_value
        }
        return null
    }
    private codegen_string_to_cstring(this, builder: LLVMBuilderRef, value: LLVMValueRef, range: TextRange): LLVMValueRef {
        let string_class_id = this.program.get_scope(this.program.modules[0].scope).classes["String"]
        let string_obj_ty: ObjectType(string_class_id)
        let prop_ty: FunctionType
        let func = this.codegen_get_member_with_name(builder, value, string_obj_ty, "to_cstring", range, &prop_ty)
        let args: LLVMValueRef[1] = [value] 
        return LLVMBuildCall2(builder, this.codegen_function_type(prop_ty as FunctionType), func, &args[0], args.size, "")
    }
    private codegen_intrinsic_exp(this, builder: LLVMBuilderRef, intrinsic_call_exp: IntrinsicCall): LLVMValueRef {
        let intrinsic_type = intrinsic_call_exp.intrinsic
        if intrinsic_type < Intrinsics.MEMCPY {
            let cbuff = this.codegen_string_to_cstring(builder, this.codegen_expression(builder, intrinsic_call_exp.args[0]), intrinsic_call_exp.range)
            let value: LLVMValueRef = null
            if intrinsic_type == Intrinsics.STR_TO_F {
                value = this.codegen_atof_call(builder, cbuff)
            }
            if intrinsic_type == Intrinsics.STR_TO_I {
                value = this.codegen_atoi_call(builder, cbuff)
            }
            if intrinsic_type == Intrinsics.STR_TO_L {
                value = this.codegen_atol_call(builder, cbuff)
            }
            LLVMBuildFree(builder, cbuff)
            return value
        }
        let args: LLVMValueRef*(intrinsic_call_exp.args.length)
        this.evaluate_expression_list(builder, args, 0, intrinsic_call_exp.args)
        let arg0_pointee_ty = (intrinsic_call_exp.args[0].value_type as PointerType).pointee_type
        let arg0_pointee_size = LLVMSizeOf(this.codegen_type(arg0_pointee_ty))
        if intrinsic_type == Intrinsics.MEMRESIZE {
            args[1] = LLVMBuildMul(builder, args[1], arg0_pointee_size, "")
            return this.codegen_realloc_call(builder, args)
        }
        args[2] = LLVMBuildMul(builder, args[2], arg0_pointee_size, "")
        if intrinsic_type == Intrinsics.MEMCMP {
            return this.codegen_memcmp_call(builder, args)
        }

        let arg0_align = LLVMGetAlignment(args[0])
        if intrinsic_type == Intrinsics.MEMSET {
            return LLVMBuildMemSet(builder, args[0], LLVMBuildIntCast2(builder, args[1], this.debug_info.type_scope.u8_type.llvm_type, false, ""), args[2], arg0_align)
        }

        let arg1_align = LLVMGetAlignment(args[1])
        if intrinsic_type == Intrinsics.MEMCPY {
            return LLVMBuildMemCpy(builder, args[0], arg0_align, args[1], arg1_align, args[2])
        }
        if intrinsic_type == Intrinsics.MEMMOVE {
            return LLVMBuildMemMove(builder, args[0], arg0_align, args[1], arg1_align, args[2])
        }
        panic("instrinsic not found!")
        return null
    }
    private codegen_range_exp(this, builder: LLVMBuilderRef, range_exp: RangeExpression): LLVMValueRef {
        let start = this.codegen_expression(builder, range_exp.left)
        let end = this.codegen_expression(builder, range_exp.right)
        let llvm_type = this.codegen_class_type(range_exp.value_type as ObjectType)
        let self = LLVMBuildMalloc(builder, llvm_type, "")
        let args: LLVMValueRef[3] = [self, start, end]
        this.build_constructor_call(builder, range_exp.value_type as ObjectType, &args[0], args.size)
        return self
    }
    private codegen_expression(this, builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        this.debug_info.emit_location(builder, expression)
        if expression.expr_kind == ExpressionKind.BOOL
            return this.codegen_bool(expression as BooleanExpression)
        if expression.expr_kind == ExpressionKind.INT
            return this.codegen_int(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegen_float(expression as FloatExpression)
        if expression.expr_kind == ExpressionKind.NULL
            return this.codegen_null(expression as NullExpression)
        if expression.expr_kind == ExpressionKind.STRING
            return this.codegen_string(builder, expression as StringExpression)
        if expression.expr_kind == ExpressionKind.ACCESS
            return this.codegen_var_access_exp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegen_bin_exp(builder, expression as BinaryExpression)
        if expression.expr_kind == ExpressionKind.UNARY
             return this.codegen_unary_exp(builder, expression as UnaryExpression)
        if expression.expr_kind == ExpressionKind.CALL
            return this.codegen_call_exp(builder, expression as CallExpression)
        if expression.expr_kind == ExpressionKind.INDEX
            return this.codegen_index_exp(builder, expression as IndexExpression)
        if expression.expr_kind == ExpressionKind.MEMBER
            return this.codegen_member_exp(builder, expression as MemberExpression, null)
        if expression.expr_kind == ExpressionKind.NEW
            return this.codegen_new_exp(builder, expression as NewExpression)
        if expression.expr_kind == ExpressionKind.TERNARY
            return this.codegen_ternary_exp(builder, expression as TernaryExpression)
        if expression.expr_kind == ExpressionKind.CAST
            return this.codegen_typecast_exp(builder, expression as TypeCastExpression)
        if expression.expr_kind == ExpressionKind.ARRAY
            return this.codegen_array_exp(builder, expression as ArrayExpression)
        if expression.expr_kind == ExpressionKind.TUPLE
            return this.codegen_tuple_exp(builder, expression as TupleExpression)
        if expression.expr_kind == ExpressionKind.MATCH
            return this.codegen_match_exp(builder, expression as MatchExpression)
        if expression.expr_kind == ExpressionKind.INTRINSIC
            return this.codegen_intrinsic_exp(builder, expression as IntrinsicCall)
        if expression.expr_kind == ExpressionKind.RANGE
            return this.codegen_range_exp(builder, expression as RangeExpression)
        return null
    }
    private codegen_if_stmt(this, builder: LLVMBuilderRef, if_stmt: IfStatement){
        let condition = this.codegen_expression(builder, if_stmt.condition)
        let if_bb = LLVMAppendBasicBlock(this.functions.peek(), "if.entry")
        let else_bb = LLVMAppendBasicBlock(this.functions.peek(), "else")
        let merge_bb = LLVMAppendBasicBlock(this.functions.peek(), "ifend")
        LLVMBuildCondBr(builder, condition, if_bb, else_bb)
        LLVMPositionBuilderAtEnd(builder, if_bb)
        this.codegen_block(builder, if_stmt.block)
        let if_terminated = if_stmt.block.is_terminated()
        if !if_terminated
            LLVMBuildBr(builder, merge_bb)

        LLVMPositionBuilderAtEnd(builder, else_bb)
        let else_terminated = false
        if if_stmt.else_block != null {
            this.codegen_block(builder, if_stmt.else_block)
            else_terminated = if_stmt.else_block.is_terminated()
        }
        if !else_terminated
            LLVMBuildBr(builder, merge_bb)
        else if if_terminated
            LLVMDeleteBasicBlock(merge_bb)
    
        LLVMPositionBuilderAtEnd(builder, merge_bb)
    }
    private codegen_for_in_stmt(this, builder: LLVMBuilderRef, for_stmt: ForInStatement){
        let for_in_entry_block = LLVMAppendBasicBlock(this.functions.peek(), "for.entry")
        LLVMBuildBr(builder, for_in_entry_block)

        LLVMPositionBuilderAtEnd(builder, for_in_entry_block)
        let for_in_next_block = LLVMAppendBasicBlock(this.functions.peek(), "for.next")
        let for_in_body_block = LLVMAppendBasicBlock(this.functions.peek(), "for.body")
        let for_in_end_block = LLVMAppendBasicBlock(this.functions.peek(), "for.end")

        let iterator = this.codegen_expression(builder, for_stmt.iterator)
        let iter_func_type: FunctionType
        let iter_func = this.codegen_get_member_with_name(builder, iterator, for_stmt.iterator.value_type as ObjectType, "__iter__", for_stmt.iterator.range, &iter_func_type)
        let args: LLVMValueRef[1] = [iterator]
        this.codegen_var_declaration(builder, for_stmt.it_var)
        let iterable_type = iter_func_type.return_type as ObjectType
        let iteratable = LLVMBuildCall2(builder, this.codegen_function_type(iter_func_type), iter_func, &args[0], args.size, "")
        args[0] = iteratable
        let next_func_type: FunctionType
        let next_func = this.codegen_get_member_with_name(builder, iteratable, iterable_type, "next", for_stmt.iterator.range, &next_func_type)
        LLVMBuildBr(builder, for_in_next_block)

        LLVMPositionBuilderAtEnd(builder, for_in_next_block)
        let next_val = LLVMBuildCall2(builder, this.codegen_function_type(next_func_type), next_func, &args[0], args.size, "")
        let next_var_mem = this.get_var_from_varid(for_stmt.it_var.var_id)
        let iter_done = this.codegen_get_member_with_name(builder, iteratable, iterable_type, "done", for_stmt.iterator.range)
        LLVMBuildStore(builder, next_val, next_var_mem)
        LLVMBuildCondBr(builder, iter_done, for_in_end_block, for_in_body_block)
        
        LLVMPositionBuilderAtEnd(builder, for_in_body_block)
        this.break_bbs.push(for_in_end_block)
        this.continue_bbs.push(for_in_next_block)
        this.codegen_block(builder, for_stmt.block)
        if !for_stmt.block.is_terminated()
            LLVMBuildBr(builder, for_in_next_block)

        LLVMPositionBuilderAtEnd(builder, for_in_end_block)
        this.codegen_del_call(builder, iteratable, iterable_type, for_stmt.iterator.range)
        LLVMBuildFree(builder, iteratable)
        this.break_bbs.pop()
        this.continue_bbs.pop()
    }
    private codegen_for_stmt(this, builder: LLVMBuilderRef, for_stmt: ForStatement){
        let for_entry_block = LLVMAppendBasicBlock(this.functions.peek(), "for.entry")
        LLVMBuildBr(builder, for_entry_block)
        LLVMPositionBuilderAtEnd(builder, for_entry_block)
        if for_stmt.initialization != null {
            this.codegen_statement(builder, for_stmt.initialization)
        }
        let for_cond_block = LLVMAppendBasicBlock(this.functions.peek(), "for.cond")
        let for_body_block = LLVMAppendBasicBlock(this.functions.peek(), "for.body")
        let for_update_block = LLVMAppendBasicBlock(this.functions.peek(), "for.incr")
        let for_end_block = LLVMAppendBasicBlock(this.functions.peek(), "for.end")
        this.break_bbs.push(for_end_block)
        this.continue_bbs.push(for_update_block)
        LLVMBuildBr(builder, for_cond_block)
        LLVMPositionBuilderAtEnd(builder, for_cond_block)
        let condition = this.createLLVMBool(true)
        if for_stmt.condition != null {
            condition = this.codegen_expression(builder, for_stmt.condition)
        }
        LLVMBuildCondBr(builder, condition, for_body_block, for_end_block)
        LLVMPositionBuilderAtEnd(builder, for_body_block)
        this.codegen_block(builder, for_stmt.block)
        if !for_stmt.block.is_terminated()
            LLVMBuildBr(builder, for_update_block)
        LLVMPositionBuilderAtEnd(builder, for_update_block)
        if for_stmt.update != null
            this.codegen_expression(builder, for_stmt.update)
        LLVMBuildBr(builder, for_cond_block)
        this.break_bbs.pop()
        this.continue_bbs.pop()
        LLVMPositionBuilderAtEnd(builder, for_end_block)
    }
    private codegen_while_stmt(this, builder: LLVMBuilderRef, while_stmt: WhileStatement){
        let while_entry_bb = LLVMAppendBasicBlock(this.functions.peek(), "while.entry")
        let while_end_bb = LLVMAppendBasicBlock(this.functions.peek(), "while.end")
        let while_body_bb = LLVMAppendBasicBlock(this.functions.peek(), "while.body")

        this.break_bbs.push(while_end_bb)
        this.continue_bbs.push(while_entry_bb)
        LLVMBuildBr(builder, while_entry_bb)

        LLVMPositionBuilderAtEnd(builder, while_entry_bb)
        let condition = this.codegen_expression(builder, while_stmt.condition)
        LLVMBuildCondBr(builder, condition, while_body_bb, while_end_bb)

        LLVMPositionBuilderAtEnd(builder, while_body_bb)
        this.codegen_block(builder, while_stmt.block)
        if !while_stmt.block.is_terminated()
            LLVMBuildBr(builder, while_entry_bb)   

        LLVMPositionBuilderAtEnd(builder, while_end_bb)
        this.break_bbs.pop()
        this.continue_bbs.pop()
    }
    private evaluate_expression_list(this, builder: LLVMBuilderRef, evaluated_list: LLVMValueRef*, start: int, list: Expression[]){
        for item in list {
            evaluated_list[start++] = this.codegen_expression(builder, item)
        }
    }
    private build_constructor_call(this, builder: LLVMBuilderRef, obj_type: ObjectType, params: LLVMValueRef*, params_length: uint){
        let checked_class = this.program.get_class_from_type(obj_type)
        let constructor = this.get_or_codegen_class_from_typeid(obj_type.class_id).get_field(checked_class.constructor_id)
        if constructor != null {
            LLVMBuildCall2(builder, LLVM_GetFunctionType(constructor.llvm_value), constructor.llvm_value, params, params_length, "")
        } else {
            panic("Could not find constructor for constructor call")
        }
    }
    private codegen_var_declaration(this, builder: LLVMBuilderRef, var_decl: VarDeclaration){
        let var_id = var_decl.var_id
        let var = this.program.get_var(var_id)
        let expression = var.value
        if var_decl.is_static {
            let name = var_decl.name.to_cstring()
            let expression_val_type = var.value_type
            let ty = this.codegen_type(expression_val_type)
            let ptr = LLVMAddGlobal(this.module, ty, name)
            if expression != null {
                let value = this.codegen_expression(builder, expression)
                LLVMSetInitializer(ptr, value)
                if(var_id.kind == VarIdKind.CONST) {
                    LLVMSetGlobalConstant(ptr, true)
                }
            }
            this.add_var(var_id, ptr)
        } else {
            let ptr = this.get_var_from_varid(var_id)
            let var_type = this.program.get_var(var_id).value_type
            let dbg_var = this.debug_info.create_auto_variable(var_id.module_id, var_decl.name, var_type, var_decl.range)
            this.debug_info.insert_declare_before(ptr, dbg_var)
            if expression != null {
                this.store_expr_to_mem(builder, ptr, expression)
            }
        }
    }
    private codegen_statement(this, builder: LLVMBuilderRef, statement: Statement){
        if statement.kind == StatementKind.IF
            this.codegen_if_stmt(builder, statement as IfStatement)
        if statement.kind == StatementKind.FOR
            this.codegen_for_stmt(builder, statement as ForStatement)
        if statement.kind == StatementKind.FOR_IN
            this.codegen_for_in_stmt(builder, statement as ForInStatement)
        if statement.kind == StatementKind.WHILE
            this.codegen_while_stmt(builder, statement as WhileStatement)
        if statement.kind == StatementKind.CONTINUE
            LLVMBuildBr(builder, this.continue_bbs.peek())
        if statement.kind == StatementKind.BREAK
            LLVMBuildBr(builder, this.break_bbs.peek())
        if statement.kind == StatementKind.VAR
            this.codegen_var_declaration(builder, statement as VarDeclaration)
        if statement.kind == StatementKind.RETURN
            this.codegen_return_stmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegen_expression(builder, statement as Expression)
    }
    private codegen_block(this, builder: LLVMBuilderRef, block: Block, lexical_block: LLVMMetadataRef = null): LLVMValueRef {
        if(lexical_block == null) lexical_block = this.debug_info.create_lexical_block(block)
        this.debug_info.lexical_blocks.push(lexical_block)
        for statement in block.statements {
            this.codegen_statement(builder, statement)
        }
        if block.yields != null {
           return this.codegen_expression(builder, block.yields)
        }
        this.debug_info.lexical_blocks.pop()
        return null
    }
    private codegen_vars_alloc_function_scope(this, builder: LLVMBuilderRef, scope: ScopeId){
        let current_scope = this.program.get_scope(scope)
        for var_entry in current_scope.vars {
            let var_name = var_entry.key
            let var_id = var_entry.value
            let var_value_type: Type = null
            if var_id.kind == VarIdKind.VAR or var_id.kind == VarIdKind.CONST {
                var_value_type = this.program.get_var(var_id).value_type
            } else if var_id.kind == VarIdKind.FNC {
                var_value_type = this.program.get_func(var_id).fnc_type
            } else {
                panic("unknown var_id kind $(var_id.kind)")
            }
            let ptr = LLVMBuildAlloca(builder, this.codegen_type(var_value_type), "")
            this.add_var(var_id, ptr)
        }
        for child_scope in current_scope.children {
            this.codegen_vars_alloc_function_scope(builder, child_scope)
        }
        
    }
    private codegen_function_body(this, llvm_fnc: LLVMValueRef, llvm_fnc_dbg: LLVMMetadataRef, params: FunctionParam[], fnc_block: Block, fnc_scope: ScopeId){
        LLVMSetSubprogram(llvm_fnc, llvm_fnc_dbg)
        let func_builder = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, LLVMAppendBasicBlock(llvm_fnc, ""))
        this.codegen_vars_alloc_function_scope(func_builder, fnc_scope)
        for let i = 0; i < params.length; i++ {
            let arg = params[i]
            let alloc = this.get_var_from_varid(arg.id)
            let param = LLVMGetParam(llvm_fnc, i)
            LLVMBuildStore(func_builder, param, alloc)

            let var_dbg = this.debug_info.create_param_variable(llvm_fnc_dbg, i + 1, arg)
            this.debug_info.insert_declare_before(alloc, var_dbg)
        }
        this.functions.push(llvm_fnc)
        this.codegen_block(func_builder, fnc_block, llvm_fnc_dbg)
        this.debug_info.finalize_subprogram(llvm_fnc_dbg)
        LLVMDisposeBuilder(func_builder)
        this.functions.pop()
    }
    private codegen_function(this, checked_function: Function, is_instantiation = false){
        if (checked_function.is_instantiated_generic) return
        if (checked_function.generics.parameters.length > 0 and !is_instantiation) {
            for let j = 0; j < checked_function.generics.specializations.length; j++ {
                let specializations = checked_function.generics.specializations[j]
                for let i = 0; i < specializations.length; i++ {
                    checked_function.generics.parameters[i].current_instance = specializations[i]
                }
                checked_function.id = checked_function.generics.specialization_ids[j]
                
                this.codegen_function(checked_function, true)
            }
            return
        }
        let llvm_fnc = LLVMAddFunction(this.module, checked_function.name.to_cstring(), this.codegen_function_type(checked_function.fnc_type))
        this.add_var(checked_function.id, llvm_fnc)
        if checked_function.is_external { 
            LLVMSetLinkage(llvm_fnc, LLVMLinkage.LLVMExternalLinkage)
            return
        }
        let fnc_dbg = this.debug_info.create_function(checked_function)
        this.codegen_function_body(llvm_fnc, fnc_dbg, checked_function.params, checked_function.block, checked_function.scope)
    }
    private codegen_class(this, checked_class: Class){
        for method in checked_class.methods {
            if method.is_abstract continue
            let llvm_method = LLVMGetNamedFunction(this.module, "$(checked_class.name)_$(method.name)")
            let method_dbg = this.debug_info.create_method(method)
            this.codegen_function_body(llvm_method, method_dbg, method.params, method.block, method.scope)
        }
    }
    private declare_class_method(this, checked_class: Class, method_name: String, method_type: FunctionType): GeneratedField {
        let llvm_method_type = this.codegen_function_type(method_type)
        let llvm_method_val = LLVMAddFunction(this.module, "$(checked_class.name)_$method_name", llvm_method_type)
        return new GeneratedField(llvm_method_val, null)
    }
    private declare_class_field(this, checked_class: Class, field_name: String, field_type: Type, initializer: Expression): GeneratedField {
        let llvm_field_type = this.codegen_type(field_type)
        let llvm_field_value = LLVMAddGlobal(this.module, llvm_field_type, "$(checked_class.name)_$field_name")
        let llvm_field_initializer = this.codegen_expression(null, initializer)
        LLVMSetInitializer(llvm_field_value, llvm_field_initializer)
        return new GeneratedField(llvm_field_value, null) 
    }
    private declare_static_props(this, struct_class: GeneratedRecordType, checked_class: Class, members_metadata: LLVMMetadataRef[]){
        for entry in checked_class.static_prop_map {
            let prop_id = entry.value
            let static_prop_name = entry.key
            let prop_type = this.program.get_class_prop_type(prop_id)
            let static_prop_value: GeneratedField = null
            if prop_id.kind == PropIdKind.METHOD {
                static_prop_value = this.declare_class_method(checked_class, static_prop_name, prop_type as FunctionType)
            } else {
                static_prop_value = this.declare_class_field(checked_class, static_prop_name, prop_type, checked_class.fields[prop_id.id].initializer)
                members_metadata << this.debug_info.create_static_member_type(
                    checked_class.id, static_prop_name,
                    this.program.get_class_prop_definition_range(prop_id),
                    prop_type,
                    this.program.get_class_prop_visibility(prop_id),
                    LLVMGetInitializer(static_prop_value.llvm_value)
                )
            }
            struct_class.set_field(prop_id, static_prop_value)
        }
    }
    private declare_class_props(this, struct_class: GeneratedRecordType, checked_class: Class, prop_types: LLVMTypeRef[], members_metadata: LLVMMetadataRef[]){
        let organized_fields: ClassField[] = []
        let member_offset_in_bits: u64 = 0
        for entry in checked_class.prop_map {
            let prop_id = entry.value
            let prop_name = entry.key
            if prop_name == "super" continue
            let prop_type = this.program.get_class_prop_type(prop_id)
            if prop_id.kind == PropIdKind.FIELD {
                let field_offset = this.program.get_field_offset(prop_id)
                let offset_cap = field_offset + 1
                organized_fields.ensure_capacity(offset_cap)
                organized_fields[field_offset] = this.program.get_class_from_prop_id(prop_id).fields[prop_id.id]
                if (offset_cap > organized_fields.length) {
                    organized_fields.length = offset_cap
                }
            } else {
                struct_class.set_field(prop_id, this.declare_class_method(checked_class, prop_name, prop_type as FunctionType))
            }
        }
        for class_field in organized_fields {
            prop_types << this.codegen_type(class_field.field_type)
            members_metadata << this.debug_info.create_member_type(
                    checked_class.id, 
                    class_field.name,
                    class_field.definition_range,
                    class_field.field_type,
                    class_field.visibility,
                    &member_offset_in_bits
                )
        }
    }
    private declare_class(this, checked_class: Class){
        let struct_class = new GeneratedRecordType()
        this.debug_info.type_scope.add_record(checked_class.id, struct_class)
        struct_class.llvm_type = LLVMStructCreateNamed(LLVMGetModuleContext(this.module), checked_class.name.to_cstring())
        struct_class.llvm_metadata = this.debug_info.create_temp_compound_type(checked_class.id.module_id,
            checked_class.name, checked_class.id.id, checked_class.definition_range)

        let prop_types: LLVMTypeRef[] = []
        let members_metadata: LLVMMetadataRef[] = []
        // Taking care of static methods.
        this.declare_static_props(struct_class, checked_class, members_metadata)
        this.declare_class_props(struct_class, checked_class, prop_types, members_metadata)
        LLVMStructSetBody(struct_class.llvm_type, prop_types.buffer, prop_types.length, true)
        let llvm_metadata = this.debug_info.create_struct_type(
            checked_class.id, checked_class.name, checked_class.definition_range,
            members_metadata.buffer, members_metadata.length,
            struct_class.llvm_type
        )
        this.debug_info.replace_temp_node_with(struct_class.llvm_metadata, llvm_metadata)
        struct_class.llvm_metadata = llvm_metadata
        del prop_types
        // Now constructor
        if checked_class.constructor_id != null {
            let constructor_type = this.program.get_class_prop_type(checked_class.constructor_id)
            struct_class.set_field(checked_class.constructor_id, this.declare_class_method(checked_class, "constructor", constructor_type as FunctionType))
        }
        this.classes_to_codegen << checked_class
    }
    private codegen_enum(this, checked_enum: Enum){
        let enum_type = new GeneratedRecordType()
        enum_type.llvm_type = this.codegen_type(checked_enum.variant_type)
        let enum_fields_dbg: LLVMMetadataRef*(checked_enum.fields.length)
        let idx = 0
        for enum_field in checked_enum.fields {
            let prop_id = enum_field.id
            let value = this.codegen_expression(null, enum_field.initializer)
            let value_dbg = this.debug_info.create_enumerator(enum_field.name, LLVMConstIntGetSExtValue(value), !(enum_field.initializer.value_type as IntType).is_signed)
            enum_fields_dbg[idx++] = value_dbg
            enum_type.set_field(prop_id, new GeneratedField(value, value_dbg))
        }
        enum_type.llvm_metadata = this.debug_info.create_enum_type(checked_enum.id, checked_enum.name, checked_enum.definition_range, enum_fields_dbg, idx, checked_enum.variant_type)
        this.debug_info.type_scope.add_record(checked_enum.id, enum_type)
    }
}