import "llvm"
class GeneratedModule {
    llvm_mod: LLVMModuleRef
    errors: i8*
    constructor(llvm_mod: LLVMModuleRef){
        this.llvm_mod = llvm_mod
        let zero = '\0'
        this.errors = &zero
        LLVMLinkInMCJIT()
        LLVMInitializeNativeTarget()
        LLVMInitializeNativeAsmPrinter()
        LLVMInitializeNativeAsmParser()
    }
    check_errors(){
        if (this.errors[0]) {
            println("error:", string_from_cstring(this.errors))
            LLVMDisposeMessage(this.errors)
            exit()
        }
    }
    exec(){
        LLVMVerifyModule(this.llvm_mod, LLVMVerifierFailureAction.LLVMAbortProcessAction, &this.errors)
        this.check_errors()

        let engine: LLVMExecutionEngineRef = new i8[64] as LLVMExecutionEngineRef
        if (LLVMCreateExecutionEngineForModule(&engine, this.llvm_mod, &this.errors) != 0) {
            println("failed to create execution engine")
        }
        this.check_errors()
        let main_fnc = LLVMGetFunctionAddress(engine, "main")  as () => float
        println(main_fnc())
    }
    create_target_machine(): LLVMTargetMachineRef {
        let triple = LLVMGetDefaultTargetTriple()
        let target = LLVMGetFirstTarget()
        if (LLVMGetTargetFromTriple(triple, &target, &this.errors) != 0) {
            println("failed to get target tripple")
        }
        this.check_errors()
        let CPU: i8* = "generic"
        return LLVMCreateTargetMachine(target, triple, CPU, LLVMGetHostCPUFeatures(), LLVMCodeGenOptLevel.LLVMCodeGenLevelNone, LLVMRelocMode.LLVMRelocDefault, LLVMCodeModel.LLVMCodeModelDefault)
    }
    write_object(fn: string){
        let tm = this.create_target_machine()
        LLVMSetDataLayout(this.llvm_mod, LLVMCreateTargetDataLayout(tm))
        LLVMSetTarget(this.llvm_mod, LLVMGetTargetMachineTriple(tm))
        if (LLVMTargetMachineEmitToFile(tm, this.llvm_mod, fn.to_cstring(), 1, &this.errors) != 0) {
            println("target machine failed to emit object code")
        }
        this.check_errors()
        LLVMDisposeTargetMachine(tm)
    }
    print(){
        LLVMDumpModule(this.llvm_mod)
    }
    destroy(){
        LLVMDisposeModule(this.llvm_mod)
    }
}
class IntrinsicResult {
    call: LLVMValueRef
    fnc_type: LLVMTypeRef
}
fnc get_intrinsic(mod: LLVMModuleRef, name: string, params: LLVMTypeRef[]): IntrinsicResult {
    let result = new IntrinsicResult()
    result.fnc_type = LLVMFunctionType(params[0], params.buffer, params.length, false)
    result.call = LLVMAddFunction(mod, name.to_cstring(), result.fnc_type)
    return result
}
fnc createLLVMBool(val: bool): LLVMValueRef{
    return LLVMConstInt(LLVMInt1Type(), val as int, false)
}
fnc is_terminated(stmts: Statement[]): bool {
    return stmts[stmts.length - 1].kind == StatementKind.RETURN
}
class CodeGen {
    modules: LLVMModuleRef[]
    module: LLVMModuleRef
    global_var_scope: Map<string, LLVMValueRef>
    intrinsic_scope: Map<string, IntrinsicResult>
    function: LLVMValueRef
    codegenProgram(program: Program): GeneratedModule{
        this.modules = []
        this.global_var_scope = new Map<string, LLVMValueRef>()
        this.intrinsic_scope = new Map<string, IntrinsicResult>()
        for let i = 0; i < program.modules.length; ++i {
            this.modules << this.codegenModule(program.modules[i])
        }
        this.linkModules()
        return new GeneratedModule(this.modules[0])
    }
    linkModules(){
        for let i = 1; i < this.modules.length; ++i {
            LLVMLinkModules2(this.modules[0], this.modules[i])
        }
    }
    codegenModule(module: Module): LLVMModuleRef {
        this.module = LLVMModuleCreateWithName(module.name.to_cstring())
        LLVMContextSetOpaquePointers(LLVMGetGlobalContext(), false)
        //let DBFloInfo = new DebugInfo(this.module, module.name)
        for let i = 0; i < module.functions.length; ++i {
            this.codegen_function(module.functions[i])
        }
        return this.module
    }
    codegen_type(tt: Type): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidType()
        if tt.kind == TypeKind.BOOL
            return LLVMInt1Type()
        if tt.kind == TypeKind.I4
            return LLVMIntType(4)
        if tt.kind == TypeKind.I8
            return LLVMInt8Type()
        if tt.kind == TypeKind.I16
            return LLVMInt16Type()
        if tt.kind == TypeKind.I32
            return LLVMInt32Type()
        if tt.kind == TypeKind.I64 or tt.kind == TypeKind.INT
            return LLVMInt64Type()
        if tt.kind == TypeKind.I128
            return LLVMInt128Type()
        if tt.kind == TypeKind.F16 
            return LLVMHalfType()
        if tt.kind == TypeKind.F32
            return LLVMFloatType()
        if tt.kind == TypeKind.F64 or tt.kind == TypeKind.FLOAT
            return LLVMDoubleType()
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegen_type((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            let arr_ty = tt as ArrayType
            let arr_len = arr_ty.length
            let element_type = this.codegen_type(arr_ty.element_type)
            if arr_len.is_constant
                return LLVMArrayType(element_type, (arr_len as IntExpression).value)
            return LLVMPointerType(element_type)
        }
        if tt.kind == TypeKind.FNC {
            let param_types: LLVMTypeRef[] = []
            let func_ty = tt as FunctionType
            for let i = 0; i < func_ty.arg_types.length; ++i {
                param_types << this.codegen_type(func_ty.arg_types[i])
                //TODO: add a new context and put the argnames to context
            }
            let ret_type = this.codegen_type(func_ty.return_type)
            return  LLVMFunctionType(ret_type, param_types.buffer, param_types.length, false)
        }
        
        //if tt.kind == TypeKind.ENUM
            return LLVMInt32Type()
            // STRING
            // OBJECT
            // GENERIC_TEMPLATE
            // RESOLVED_GENERIC

    }
    codegen_return_stmt(builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value.has_value 
            LLVMBuildRet(builder, this.codegen_expression(builder, return_stmt.return_value.value))
        else
            LLVMBuildRetVoid(builder)
    }
    codegen_int(int_exp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegen_type(int_exp.value_type), int_exp.value, true)
    }
    codegen_float(float_exp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegen_type(float_exp.value_type), float_exp.value)
    }
    codegen_assignment(builder: LLVMBuilderRef, assign_exp: AssignmentExression): LLVMValueRef {
        let value = this.codegen_expression(builder, assign_exp.rhs)
        if assign_exp.assign_kind == AssignKind.VAR {
            let var_assign = assign_exp as VarAssignmentExpression
            let ptr = this.global_var_scope.get(this.create_var_key(var_assign.value_id))
            if !ptr.has_value {
                println("This should never happen! (codegen_assignment)")
                exit()
            }
            LLVMBuildStore(builder, value, ptr.value)
        }
        return value
    }
    codegen_bin_exp(builder: LLVMBuilderRef, bin_exp: BinaryExpression): LLVMValueRef {   
        let op = bin_exp.op
        if bin_exp.lhs.value_type != bin_exp.rhs.value_type {
            if op == BinaryOp.EEQ
                return createLLVMBool(0)
            else if op == BinaryOp.NEQ
                return createLLVMBool(1)
        }
        if op == BinaryOp.ASSIGN
            return this.codegen_assignment(builder, bin_exp as AssignmentExression)
        let lhs = this.codegen_expression(builder, bin_exp.lhs)
        let rhs = this.codegen_expression(builder, bin_exp.rhs)
        let rty = bin_exp.rhs.value_type
        let llvmty = this.codegen_type(rty)
        if is_numeric(rty) and op == BinaryOp.POW {
            let args = [lhs, rhs]
            let name = "llvm.pow."+dump_type(rty)
            let cached_instrinsic = this.intrinsic_scope.get(name)
            let res = new IntrinsicResult()
            if cached_instrinsic.has_value {
                res = cached_instrinsic.value
            } else {
                res = get_intrinsic(this.module, name, [llvmty, llvmty])
                this.intrinsic_scope.set(name, res)
            }
            return LLVMBuildCall2(builder, res.fnc_type, res.call, &args[0], 2, "")
        }
        let pred = 0
        let is_const_expr = LLVMIsConstant(lhs) and LLVMIsConstant(rhs)
        if is_int(rty) {
            if op == BinaryOp.ADD {
                if is_const_expr
                    return  LLVMConstAdd(lhs, rhs)
                return LLVMBuildAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                if is_const_expr 
                    return LLVMConstSub(lhs, rhs) 
                return LLVMBuildSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                if is_const_expr 
                    return LLVMConstMul(lhs, rhs) 
                return LLVMBuildMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildSDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildSRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + 38
                if is_const_expr 
                    return LLVMConstICmp(pred, lhs, rhs)
                return LLVMBuildICmp(builder, pred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = op - BinaryOp.EEQ + 32
                if is_const_expr 
                    return LLVMConstICmp(pred, lhs, rhs)
                return LLVMBuildICmp(builder, pred, lhs, rhs, "")
            } else if op == BinaryOp.SL {
                if is_const_expr 
                    return LLVMConstShl(lhs, rhs)
                return LLVMBuildShl(builder, lhs, rhs, "")
            } else if op == BinaryOp.SR {
                if is_const_expr 
                    return LLVMConstAShr(lhs, rhs)
                return LLVMBuildAShr(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                if is_const_expr 
                    return LLVMConstOr(lhs, rhs)
                return LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.AND {
                if is_const_expr 
                    return LLVMConstAnd(lhs, rhs)
                return LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.XOR {
                if is_const_expr 
                    return LLVMConstXor(lhs, rhs)
                return LLVMBuildXor(builder, lhs, rhs, "")
            }
        } else if is_float(rty) {
            if op == BinaryOp.ADD { 
                return LLVMBuildFAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return LLVMBuildFSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return LLVMBuildFMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildFDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildFRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + LLVMRealPredicate.LLVMRealOGT
                if is_const_expr 
                    return LLVMConstFCmp(pred, lhs, rhs) 
                return LLVMBuildFCmp(builder, pred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = op == BinaryOp.NEQ ? LLVMRealPredicate.LLVMRealONE : LLVMRealPredicate.LLVMRealOEQ
                if is_const_expr 
                    return LLVMConstFCmp(pred, lhs, rhs) 
                return LLVMBuildFCmp(builder, pred, lhs, rhs, "")
            }
        } else if is_bool(rty) {
            if op == BinaryOp.AND {
                 if is_const_expr 
                    return LLVMConstAnd(lhs, rhs)
                return LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                 if is_const_expr 
                    return LLVMConstOr(lhs, rhs)
                return LLVMBuildOr(builder, lhs, rhs, "")
            }
        }
        return lhs
    }
    codegen_type_exp(builder: LLVMBuilderRef, type_exp: TypeExpression): LLVMValueRef {
        let exp = type_exp.expr
        let bty = type_exp.bound_type
        let val = this.codegen_expression(builder, exp)
        let ty = this.codegen_type(bty)
        let is_const = LLVMIsConstant(val)
        if type_exp.ty_op == TypeExprOp.AS {
            if is_bool(bty) {
                 if is_const 
                        return createLLVMBool(LLVMIsNull(val)) 
                    return LLVMBuildIsNull(builder, val, "")
            }
            if is_int(exp.value_type) and is_float(bty) {
                 if is_const 
                        return LLVMConstSIToFP(val, ty) 
                    return LLVMBuildSIToFP(builder, val, ty, "")
            } else if is_float(exp.value_type) and is_int(bty) {
                 if is_const 
                        return LLVMConstFPToSI(val, ty) 
                    return LLVMBuildFPToSI(builder, val, ty, "")
            } else if is_int(exp.value_type) and is_int(bty){
                if exp.value_type.kind > bty.kind {
                     if is_const 
                        return LLVMConstTrunc(val, ty) 
                    return LLVMBuildTrunc(builder, val, ty, "")
                } else {
                     if is_const 
                        return LLVMConstZExt(val, ty) 
                    return LLVMBuildTrunc(builder, val, ty,"")
                }
            } else if is_float(exp.value_type) and is_float(bty){
                if exp.value_type.kind > bty.kind {
                     if is_const 
                        return LLVMConstFPTrunc(val, ty) 
                    return LLVMBuildFPTrunc(builder, val, ty, "")
                } else {
                     if is_const 
                        return LLVMConstFPExt(val, ty) 
                    return LLVMBuildFPExt(builder, val, ty,"")
                }
            }
             if is_const 
                        return LLVMConstBitCast(val, ty) 
                    return LLVMBuildBitCast(builder, val, ty, "")
        } 
        return val
    }
    codegen_bool(bool_exp: BooleanExpression): LLVMValueRef {
        let val = bool_exp.value
        return LLVMConstInt(LLVMInt1Type(), val, false)
    }
    codegen_unary_exp(builder: LLVMBuilderRef, unary_exp: UnaryExpression): LLVMValueRef {
        let op = unary_exp.op
        let exp = unary_exp.expression
        let val = this.codegen_expression(builder, exp)
        if op == UnaryOp.NEG {
            if is_int(exp.value_type){
                return LLVMIsConstant(val) ? LLVMConstNeg(val) : LLVMBuildNeg(builder, val, "")
            } else if is_float(exp.value_type){
                return LLVMBuildFNeg(builder, val, "")
            }
        } 
        if op == UnaryOp.NOT {
            return LLVMIsConstant(val) ? LLVMConstNot(val) : LLVMBuildNot(builder, val, "")
        }
        return val
    }
    codegen_var_exp(builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let val = this.global_var_scope.get(this.create_var_key(var_exp.value_id))
        if !val.has_value {
            println("This should never happen; (codegen_var_exp)")
            exit()
        }
        return LLVMBuildLoad(builder, val.value, "")
    }
    codegen_null(null_exp: NullExpression): LLVMValueRef{
        return LLVMConstNull(this.codegen_type(null_exp.value_type))
    }
    codegen_expression(builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        if expression.expr_kind == ExpressionKind.BOOL
            return this.codegen_bool(expression as BooleanExpression)
        if expression.expr_kind == ExpressionKind.INT
            return this.codegen_int(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegen_float(expression as FloatExpression)
        if expression.expr_kind == ExpressionKind.NULL
            return this.codegen_null(expression as NullExpression)
        // if expression.expr_kind == ExpressionKind.STR
        //     return this.codegen_string(builder, expression as StringExpression)
        if expression.expr_kind == ExpressionKind.VAR 
              return this.codegen_var_exp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegen_bin_exp(builder, expression as BinaryExpression)
        if expression.expr_kind == ExpressionKind.UNARY
             return this.codegen_unary_exp(builder, expression as UnaryExpression)
        // if expression.expr_kind == ExpressionKind.CALL
        //     return this.codegen_call_exp(builder, expression as CallExpression)
        // if expression.expr_kind == ExpressionKind.MEMBER
        //     return this.codegen_member_exp(builder, expression as MemberExpression)
        // if expression.expr_kind == ExpressionKind.INDEX
        //     return this.codegen_index_exp(builder, expression as IndexExpression)
        // if expression.expr_kind == ExpressionKind.NEW
        //     return this.codegen_new_exp(builder, expression as NewExpression)
        // if expression.expr_kind == ExpressionKind.TERNARY
        //     return this.codegen_ternary_exp(builder, expression as TernaryExpression)
        if expression.expr_kind == ExpressionKind.TYPEBOUND {
            return this.codegen_type_exp(builder, expression as TypeExpression)
        }
        // if expression.expr_kind == ExpressionKind.ARRAY
        //     return this.codegen_array_exp(builder, expression as ArrayExpression)
        return LLVMConstInt(LLVMInt32Type(), 0, false)
    }
    codegen_if_stmt(builder: LLVMBuilderRef, if_stmt: IfStatement){
        let condition = this.codegen_expression(builder, if_stmt.condition)
        let if_block = LLVMAppendBasicBlock(this.function, "then")
        let else_block = LLVMAppendBasicBlock(this.function, "else")
        let merge_block = LLVMAppendBasicBlock(this.function, "ifend")
        LLVMBuildCondBr(builder, condition, if_block, else_block)
        LLVMPositionBuilderAtEnd(builder, if_block)
        this.codegen_block(builder, if_stmt.block)
        if !is_terminated(if_stmt.block.statements)
            LLVMBuildBr(builder, merge_block)

        LLVMPositionBuilderAtEnd(builder, else_block)
        let else_terminated = false
        if if_stmt.else_block.has_value {
            this.codegen_block(builder, if_stmt.else_block.value)
            else_terminated = is_terminated(if_stmt.else_block.value.statements)
        }
        if !else_terminated
            LLVMBuildBr(builder, merge_block)
    
        LLVMPositionBuilderAtEnd(builder, merge_block)
    }
    // codegenForStmt(builder: LLVMBuilderRef, for_stmt: ForStatement){

    // }
    // codegenWhileStmt(builder: LLVMBuilderRef, while_stmt: WhileStatement){

    // }
    create_var_key(var_id: VarId): string{
        return var_id.module_id + ";" + var_id.id
    }
    codegen_var_declaration(builder: LLVMBuilderRef, var_decl: VarDeclaration){
        let ty = this.codegen_type(var_decl.expression.value_type)
        let val = this.codegen_expression(builder, var_decl.expression)
        let ptr = LLVMBuildAlloca(builder, ty, var_decl.name.to_cstring())
        let var_id = var_decl.var_id
        LLVMBuildStore(builder, val, ptr)
        this.global_var_scope.set(this.create_var_key(var_id), ptr)
    }
    codegen_statement(builder: LLVMBuilderRef, statement: Statement){
        if statement.kind == StatementKind.IF
            this.codegen_if_stmt(builder, statement as IfStatement)
        // if statement.kind == StatementKind.FOR
        //     this.codegen_for_stmt(builder, statement as ForStatement)
        // if statement.kind == StatementKind.WHILE
        //     this.codegen_while_stmt(builder, statement as WhileStatement)
        // if statement.kind == StatementKind.CONTINUE
        // if statement.kind == StatementKind.BREAK
        if statement.kind == StatementKind.VAR
            this.codegen_var_declaration(builder, statement as VarDeclaration)
        if statement.kind == StatementKind.RETURN
            this.codegen_return_stmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegen_expression(builder, statement as Expression)
    }
    codegen_block(builder: LLVMBuilderRef, block: Block){
        for let i = 0; i < block.statements.length; ++i {
            this.codegen_statement(builder, block.statements[i])
        }
    }
    codegen_function(func: Function){
        let llvm_fnc: LLVMValueRef = LLVMAddFunction(this.module, func.name.to_cstring(), this.codegen_type(func.value_type))
        let entry_block: LLVMBasicBlockRef  = LLVMAppendBasicBlock(llvm_fnc, "")
        let func_builder: LLVMBuilderRef = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, entry_block)
        this.function = llvm_fnc
        this.codegen_block(func_builder, func.block)
    }
}