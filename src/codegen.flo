import panic in "utils"
import "typechecker"
import ARCH_WORD_SIZE in "@sys/lib"
import "llvm/types"
import "llvm/core"
import "types"
import "codegenMod"

class IntrinsicResult {
    call: LLVMValueRef
    fnc_type: LLVMTypeRef
    constructor(this){
        this.call = null
        this.fnc_type = null
    }
}
class CGClassType  {
    llvm_type: LLVMTypeRef
    vt_methods_pos_map: [string: int]
    fields_pos_map: [string: int]
    static_props_map: [string: LLVMValueRef]
    vtable: LLVMValueRef
    vtable_type: LLVMTypeRef
    class_constructor: LLVMValueRef
    constructor(this){
        this.vt_methods_pos_map = new Map<string, int>()
        this.fields_pos_map = new Map<string, int>()
        this.static_props_map = new Map<string, LLVMValueRef>()
        this.vtable = null
        this.vtable_type = null
    }
}
class CGEnumType {
    llvm_type: LLVMTypeRef
    field_map: [string: LLVMValueRef]
    metanames: LLVMValueRef
    constructor(this){
        this.field_map = new Map<string, LLVMValueRef>()
    }
}
fnc get_intrinsic(mod: LLVMModuleRef, name: string, params_types: LLVMTypeRef*, params_length: int, return_type: LLVMTypeRef, var_args = false): IntrinsicResult {
    let result = new IntrinsicResult()
    result.fnc_type = LLVMFunctionType(return_type, params_types, params_length, var_args)
    let fn_name = name.to_cstring()
    let fnc_in_mod = LLVMGetNamedFunction(mod, fn_name)
    if fnc_in_mod != null {
        result.call = fnc_in_mod
    } else {
        result.call = LLVMAddFunction(mod, fn_name, result.fnc_type)
    }
    return result
}
fnc is_terminated(block: Block): bool {
    return block.returns or block.continues or block.breaks
}
fnc create_var_key(var_id: VarId): string {
    return  "$(var_id.module_id);$(var_id.kind as int);$(var_id.id)"
}
fnc create_type_id_key(type_id: TypeId): string {
    return "$(type_id.module_id);$(type_id.kind as int);$(type_id.id)"
}
fnc create_type_key_from_var(var_id: VarId): string {
    let diff =  (var_id.kind as int) - (VarIdKind.CLASS as int)
    return "$(var_id.module_id);$diff;$(var_id.id)"
}
fnc create_prop_key(prop_id: PropId): string {
    return "$(create_type_id_key(prop_id.type_id));$(prop_id.kind as int);$(prop_id.id)"
}
// These two functions will eventually become a generic function once we implement those.
fnc resize_type_array(array: LLVMTypeRef[], amt: int){
    for let i = array.length; i <= amt; i++ {
        array << null
    }
}
fnc resize_value_array(array: LLVMValueRef[], amt: int){
    for let i = array.length; i <= amt; i++ {
        array << null
    }
}
fnc get_format_from_type(ty: Type): string {
    if is_int(ty){
        if ty.kind == TypeKind.I128
            return "%lld"
        if ty.kind == TypeKind.I64 
            return "%ld"
        return "%d"
    }
    if ty.kind == TypeKind.F32 
        return "%f"
    if ty.kind == TypeKind.F64
        return "%lf"
    if is_pointer(ty)
        return "0x%X"
    return "%s"
}
class CodeGen {
    private module: LLVMModuleRef
    private function: LLVMValueRef
    private break_bb: LLVMBasicBlockRef
    private continue_bb: LLVMBasicBlockRef
    private program: Program
    private in_static_ctx: bool
    private global_var_scope: [string: LLVMValueRef]
    private global_string_scope: [string: LLVMValueRef]
    private global_class_scope: [string: CGClassType]
    private global_enum_scope: [string: CGEnumType]
    private super_functions: [string: LLVMValueRef]
    constructor(this, program: Program, module_name: string){
        this.program = program
        this.global_var_scope = new Map<string, LLVMValueRef>()
        this.global_string_scope = new Map<string, LLVMValueRef>()
        this.global_class_scope = new Map<string, CGClassType>()
        this.global_enum_scope = new Map<string, CGEnumType>()
        this.super_functions = new Map<string, LLVMValueRef>()
        this.in_static_ctx = true
        this.continue_bb = null
        this.break_bb = null
        this.module = LLVMModuleCreateWithName(module_name.to_cstring())
    }
    public codegen(program: Program): GeneratedModule{
        let module = program.modules[2]
        let codegen: CodeGen(program, module.name)
        for enum_ in module.enums  {
            codegen.declare_enum(enum_)
        }
        for class_ in module.classes {
            codegen.declare_class(class_)
        }
        for const_ in module.global_consts {
            codegen.codegen_const_declaration(null, const_)
        }
        for var_ in module.global_vars {
            codegen.codegen_var_declaration(null, var_)
        }
        for class_ in module.classes {
            codegen.codegen_class(class_)
        }
        for func_ in module.functions {
            codegen.codegen_function(func_)
        }
        codegen.destroy()
        del program
        return new GeneratedModule(codegen.module)
    }
    private destroy(this){
        for var_entry in this.global_var_scope {
            del var_entry.key
        }
        del this.global_var_scope
        for string_entry in this.global_string_scope {
            del string_entry.key
        }
        del this.global_string_scope 
        for func_entry in this.super_functions {
            del func_entry.key
        }
        del this.super_functions
        for class_entry in this.global_class_scope {
            del class_entry.key
            del class_entry.value
        }
        del this.global_class_scope
        for enum_entry in this.global_enum_scope {
            del enum_entry.key
            del enum_entry.value
        }
        del this.global_enum_scope
    }
    private get_var_from_varid(this, var_id: VarId): LLVMValueRef{
        return this.global_var_scope[create_var_key(var_id)]
    }
    private get_class_from_typeid(this, type_id: TypeId): CGClassType {
        return this.global_class_scope[create_type_id_key(type_id)]
    }
    private get_enum_from_typeid(this, type_id: TypeId): CGEnumType {
        return this.global_enum_scope[create_type_id_key(type_id)]
    }
    private add_class(this, type_id: TypeId, struct_class: CGClassType){
        this.global_class_scope[create_type_id_key(type_id)] = struct_class
    }
    private add_enum(this, type_id: TypeId, enum_type: CGEnumType){
        this.global_enum_scope[create_type_id_key(type_id)] = enum_type
    }
    private add_var(this, var_id: VarId, value: LLVMValueRef){
        this.global_var_scope[create_var_key(var_id)] = value
    }
    private neg_int(builder: LLVMBuilderRef, val: LLVMValueRef): LLVMValueRef {
        return LLVMIsConstant(val) ? LLVMConstNeg(val) : LLVMBuildNeg(builder, val, "")
    }
    private createLLVMBool(this, val: bool): LLVMValueRef{
        return LLVMConstInt(LLVMInt1Type(), val ? 1 : 0 as i64, false)
    }
    private createLLVMInt(this, i: int): LLVMValueRef {
        return LLVMConstInt(LLVMIntType(ARCH_WORD_SIZE), i as i64, false)
    }
    private codegen_type(this, tt: Type, as_pointer = true): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidType()
        if tt.kind == TypeKind.BOOL
            return LLVMInt1Type()
        if tt.kind == TypeKind.I4
            return LLVMIntType(4)
        if tt.kind == TypeKind.I8
            return LLVMInt8Type()
        if tt.kind == TypeKind.I16
            return LLVMInt16Type()
        if tt.kind == TypeKind.I32
            return LLVMInt32Type()
        if tt.kind == TypeKind.INT
            return LLVMIntType(ARCH_WORD_SIZE)
        if tt.kind == TypeKind.I64
            return LLVMInt64Type()
        if tt.kind == TypeKind.I128
            return LLVMInt128Type()
        if tt.kind == TypeKind.F32 
            return LLVMFloatType()
        if tt.kind == TypeKind.F64
            return LLVMDoubleType()
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegen_type((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            let arr_ty = tt as ArrayType
            let element_type = this.codegen_type(arr_ty.element_type)
            return LLVMArrayType(element_type, arr_ty.length)
        }
        if tt.kind == TypeKind.RESOLVED_GENERIC {
            tt = (tt as GenericType).instantiated_type
        }
        if is_function(tt) {
            let func_ty = tt as FunctionType
            let param_types: LLVMTypeRef*(func_ty.arg_types.length)
            let idx = 0
            for arg_ty in func_ty.arg_types {
                param_types[idx++] = this.codegen_type(arg_ty)
            }
            let llvm_fnty = LLVMFunctionType(this.codegen_type(func_ty.return_type), param_types, func_ty.arg_types.length, false)
            return as_pointer ? LLVMPointerType(llvm_fnty) : llvm_fnty
        }
        if tt.kind == TypeKind.OBJECT {
            let obj_type = this.get_or_codegen_class_from_typeid((tt as ObjectType).class_id)
            if obj_type != null {
                return as_pointer ? LLVMPointerType(obj_type.llvm_type) : obj_type.llvm_type
            }
        }
        if tt.kind == TypeKind.ENUM {
            let enum_type = this.get_or_codegen_enum_from_typeid((tt as EnumType).enum_id)
            if enum_type != null {
                return enum_type.llvm_type
            }
        }
        panic("Type could not be code generated")
        return null
    }
    private codegen_return_stmt(this, builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value != null {
            let expression = this.codegen_expression(builder, return_stmt.return_value)
            if return_stmt.return_value.value_type.kind != TypeKind.VOID {
                LLVMBuildRet(builder, expression)
                return
            }
        }
        LLVMBuildRetVoid(builder)
    }
    private codegen_int(this, int_exp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegen_type(int_exp.value_type), int_exp.value, true)
    }
    private codegen_float(this, float_exp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegen_type(float_exp.value_type), float_exp.value)
    }
    private codegen_bool(this, bool_exp: BooleanExpression): LLVMValueRef {
        let val = bool_exp.value
        return this.createLLVMBool(val)
    }
    private codegen_atof_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(LLVMInt8Type())]
        let args: LLVMValueRef[1] = [arg]
        let float_ty = LLVMDoubleType()
        let atof = get_intrinsic(this.module, "atof", &arg_types[0], 1, float_ty)
        return LLVMBuildCall2(builder, atof.fnc_type, atof.call, &args[0], 1, "")
    }
    private codegen_atoi_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(LLVMInt8Type())]
        let args: LLVMValueRef[1] = [arg]
        let int_ty = LLVMInt32Type()
        let atoi = get_intrinsic(this.module, "atoi", &arg_types[0], 1, int_ty)
        return LLVMBuildCall2(builder, atoi.fnc_type, atoi.call, &args[0], 1, "")
    }
    private codegen_atol_call(this, builder: LLVMBuilderRef, arg: LLVMValueRef): LLVMValueRef {
        let arg_types: LLVMTypeRef[1] = [LLVMPointerType(LLVMInt8Type())]
        let args: LLVMValueRef[1] = [arg]
        let big_int_ty = LLVMInt64Type()
        let atol = get_intrinsic(this.module, "atol", &arg_types[0], 1, big_int_ty)
        return LLVMBuildCall2(builder, atol.fnc_type, atol.call, &args[0], 1, "")
    }
    private codegen_realloc_call(this, builder: LLVMBuilderRef, args: LLVMValueRef*): LLVMValueRef {
        let i8_ptr_ty = LLVMPointerType(LLVMInt8Type())
        let arg_types: LLVMTypeRef[2] = [i8_ptr_ty, LLVMIntType(ARCH_WORD_SIZE)]
        let realloc = get_intrinsic(this.module, "realloc", &arg_types[0], 2, i8_ptr_ty)
        return LLVMBuildCall2(builder, realloc.fnc_type, realloc.call, args, 2, "")
    }
    private codegen_memcmp_call(this, builder: LLVMBuilderRef, args: LLVMValueRef*): LLVMValueRef {
        let i8_ptr_ty = LLVMPointerType(LLVMInt8Type())
        let int_ty = LLVMIntType(ARCH_WORD_SIZE)
        let arg_types: LLVMTypeRef[3] = [i8_ptr_ty, i8_ptr_ty, int_ty]
        let memcmp = get_intrinsic(this.module, "memcmp", &arg_types[0], 3, int_ty)
        return LLVMBuildCall2(builder, memcmp.fnc_type, memcmp.call, args, 3, "")
    }
    private codegen_del_call(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_ty: ObjectType): LLVMValueRef {
        let func_ty: FunctionType
        let func = this.get_member_with_name(builder, self, obj_ty, "__del__", &func_ty)
        if func == null return null
        let args: LLVMValueRef[1] = [self]
        return LLVMBuildCall2(builder, this.codegen_type(func_ty, false), func, &args[0], 1, "")
    }
    private createGlobalLLVMString(this, builder: LLVMBuilderRef, str_value: string): LLVMValueRef {
        let str = this.global_string_scope[str_value]
        if str == null {
            str = LLVMBuildGlobalString(builder, str_value.to_cstring(), "")
            this.global_string_scope[str_value] = str
        }
        return str
    }
    private codegen_safe_fmt_string(this, builder: LLVMBuilderRef, fmt: string, args: LLVMValueRef*, args_length: int, len_ptr: LLVMValueRef*): LLVMValueRef {
        let i8_ty = LLVMInt8Type()
        let i8_ptr_ty = LLVMPointerType(i8_ty)
        let int_ty = LLVMIntType(ARCH_WORD_SIZE)
        let alloc_buff = LLVMBuildAlloca(builder, i8_ptr_ty, "")
        let llvm_fmt = this.createGlobalLLVMString(builder, fmt)
        let num_passed_args = args_length + 2
        let call_args_buffer: LLVMValueRef*(num_passed_args)
        call_args_buffer[0] = alloc_buff
        call_args_buffer[1] = llvm_fmt
        (call_args_buffer + 2).copy_from(args, args_length)
        let arg_types: LLVMTypeRef[2] = [i8_ptr_ty, i8_ptr_ty]
        let asprintf = get_intrinsic(this.module, "asprintf", &arg_types[0], 2, int_ty, true)
        let str_len = LLVMBuildCall2(builder, asprintf.fnc_type, asprintf.call, call_args_buffer, num_passed_args, "")
        if len_ptr != null {
            len_ptr[0] = str_len
        }
        return LLVMBuildLoad2(builder, i8_ptr_ty, alloc_buff, "")
    }
    private get_string_val(this, builder: LLVMBuilderRef, llvm_val: LLVMValueRef, val_ty: Type, malloc_list: LLVMValueRef[], depth = 0): LLVMValueRef {
        if is_bool(val_ty){
            let true_str = this.createGlobalLLVMString(builder, "true")
            let false_str = this.createGlobalLLVMString(builder, "false")
            return LLVMBuildSelect(builder, llvm_val, true_str, false_str, "")
        }
        if is_object(val_ty){
            if is_buitin(this.program, val_ty, "string") {
                let result = this.codegen_string_to_cstring(builder, llvm_val)
                malloc_list << result
                return result
            }
            //TODO: will need to check for nullable
            let obj_class = get_class_from_type(this.program, val_ty)
            let str_builder: StringBuilder(obj_class.name.length + 14)
            str_builder.append_string("$(obj_class.name) {\n")
            if depth == 3 {
                str_builder.append_string(" ... }")
                return this.createGlobalLLVMString(builder, str_builder.get_string())
            }
            let fmt_args_length = obj_class.prop_map.length
            let fmt_args: LLVMValueRef*(fmt_args_length)
            let idx = 0
            for field_entry in obj_class.prop_map {
                let field_ty = get_class_prop_type(this.program, field_entry.value)
                let member_val = this.get_member_with_name(builder, llvm_val, val_ty as ObjectType, field_entry.key)
                let arg = this.get_string_val(builder, member_val, field_ty, malloc_list, depth + 1)
                if !is_object(field_ty) and LLVMGetTypeKind(LLVMTypeOf(arg)) == LLVMTypeKind.LLVMPointerTypeKind and !LLVMIsGlobalConstant(arg) {
                    malloc_list << arg
                }
                fmt_args[idx++] = arg
                str_builder.append_string(" '$(field_entry.key)': $(get_format_from_type(field_ty)), \n")
            }
            str_builder.append_string("}")
            let result = this.codegen_safe_fmt_string(builder, str_builder.get_string(), fmt_args, fmt_args_length, null)
            malloc_list << result
            return result
        }
        //TODO: Better toString for functions
        if is_function(val_ty) {
            return this.createGlobalLLVMString(builder, "<function>")
        }
        if val_ty.kind == TypeKind.ENUM {
            let enum_meta = this.get_or_codegen_enum_from_typeid((val_ty as EnumType).enum_id).metanames
            let indices: LLVMValueRef[1] = [llvm_val]
            let ptr = LLVMBuildInBoundsGEP2(builder, LLVMTypeOf(enum_meta), enum_meta, &indices[0], 1, "")
            return LLVMBuildLoad2(builder, LLVMTypeOf(ptr), ptr, "")
        }
        return llvm_val
    }
    private codegen_string(this, builder: LLVMBuilderRef, string_exp: StringExpression): LLVMValueRef {
        let str_value = string_exp.value
        let fmt_str_builder: StringBuilder(str_value.length + string_exp.fmt_indices.length*2)
        let chars = str_value.get_bytes()
        let curr_ind = 0
        let prev_ind = 0
        let malloc_list: LLVMValueRef[] = []
        let call_args_length = string_exp.template_args.length
        let call_args: LLVMValueRef*(call_args_length)
        for let i = 0; i < call_args_length; i++ {
            let templ_arg = string_exp.template_args[i]
            let templ_arg_ty = templ_arg.value_type
            let fmt = get_format_from_type(templ_arg_ty)
            prev_ind = curr_ind
            curr_ind = string_exp.fmt_indices[i]
            let incr = curr_ind - prev_ind
            fmt_str_builder.add_bytes_length(chars, incr)
            fmt_str_builder.append_string(fmt)
            chars += incr
            let templ_arg_exp = this.codegen_expression(builder, templ_arg)
            call_args[i] = this.get_string_val(builder, templ_arg_exp, templ_arg_ty, malloc_list)
        }
        fmt_str_builder.add_bytes_length(chars, str_value.length - curr_ind)
        str_value = fmt_str_builder.get_string()
        let str_len = this.createLLVMInt(str_value.length)
        let str = call_args_length > 0 ? this.codegen_safe_fmt_string(builder, str_value, call_args, call_args_length, &str_len) : this.createGlobalLLVMString(builder, str_value)
        if is_object(string_exp.value_type) {
            let str_ty = this.codegen_type(string_exp.value_type, false)
            if LLVMIsConstant(str) and LLVMIsGlobalConstant(str) {
                let func = LLVMGetNamedFunction(this.module, "string_from_bytes")
                if func == null {
                    panic("Could not find function 'string.from_bytes' in program")
                }
                let args: LLVMValueRef[2] = [str, str_len]
                str = LLVMBuildCall2(builder, LLVM_GetFunctionType(func), func, &args[0], 2, "")
            } else {
                let self = LLVMBuildMalloc(builder, str_ty, "")
                let args: LLVMValueRef[3] = [self, str, str_len] 
                this.build_constructor_call(builder, string_exp.value_type as ObjectType, &args[0], 3)
                str = self
            }
        }
        for mem in malloc_list {
            LLVMBuildFree(builder, mem)
        }
        del malloc_list
        return str
    }
    private store_array_elements(this, builder: LLVMBuilderRef, ptr: LLVMValueRef, array_exp: ArrayExpression): LLVMValueRef {
        let next_args: LLVMValueRef[1] = [this.createLLVMInt(1)]
        let ptr_ty = LLVMTypeOf(ptr)
        let addr = ptr
        for value in array_exp.elements {
            LLVMBuildStore(builder, this.codegen_expression(builder, value), addr)
            addr = LLVMBuildInBoundsGEP2(builder, ptr_ty, addr, &next_args[0], 1, "")
        }
        return addr
    }
    private codegen_array_exp(this, builder: LLVMBuilderRef, array_exp: ArrayExpression): LLVMValueRef {
        if array_exp.value_type.kind == TypeKind.RESOLVED_GENERIC {
            return this.codegen_builtin_array(builder, array_exp.value_type as GenericType, array_exp)
        } 
        //FIXME: What if array is not constant?
        if !array_exp.is_constant {
            panic("Array expression is not a constant (codegen_array_exp)")
        }
        let elem_ty = this.codegen_type((array_exp.value_type as ArrayType).element_type)
        let elems_buffer: LLVMValueRef*(array_exp.elements.length)
        let idx = 0
        for value in array_exp.elements {
            elems_buffer[idx++] = this.codegen_expression(builder, value)
        }
        return LLVMConstArray(elem_ty, elems_buffer, array_exp.elements.length)
    }
    private get_or_codegen_var(this, target_id: VarId): LLVMValueRef {
        let var = this.get_var_from_varid(target_id)
        if var != null return var
        // We need to find this var..
        let module = this.program.modules[target_id.module_id]
        if target_id.kind == VarIdKind.CONST {
            for global_const in module.global_consts {
                let const_id = global_const.const_id
                if const_id.id == target_id.id {
                    this.codegen_const_declaration(null, global_const)
                    return this.get_var_from_varid(target_id)
                }
            }
        }
        if target_id.kind == VarIdKind.VAR {
            for global_var in module.global_vars {
                let var_id = global_var.var_id
                if var_id.id == target_id.id {
                    this.codegen_var_declaration(null, global_var)
                    return this.get_var_from_varid(target_id)
                }
            }
        }
        if target_id.kind == VarIdKind.FNC {
            for function in module.functions {
                let fnc_id = function.id
                if fnc_id.id == target_id.id {
                    this.codegen_function(function)
                    return this.get_var_from_varid(target_id)
                }
            }
        }
        return null
    }
    private construct_class(this, class_: Class): CGClassType {
        this.declare_class(class_)
        this.codegen_class(class_)
        return this.get_class_from_typeid(class_.id)
    }
    private construct_enum(this, enum_: Enum): CGEnumType {
        this.declare_enum(enum_)
        return this.get_enum_from_typeid(enum_.id)
    }
    private get_or_codegen_class_from_typeid(this, ty_id: TypeId): CGClassType {
        let cg_class = this.get_class_from_typeid(ty_id)
        if cg_class != null return cg_class
        let class_ = get_class(this.program, ty_id as ClassId)
        return this.construct_class(class_)
    }
    private get_or_codegen_enum_from_typeid(this, ty_id: TypeId): CGEnumType {
        let cg_enum = this.get_enum_from_typeid(ty_id)
        if cg_enum != null return cg_enum
        let enum_ = get_enum(this.program, ty_id as EnumId)
        return this.construct_enum(enum_)
    }
    private get_var_expr_mem(this, builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let ptr = this.get_or_codegen_var(var_exp.value_id)
        if ptr == null {
            panic("This should never happen! (get_expr_mem: var)")
        }
        return ptr
    }
    private get_index_expr_mem(this, builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let index = this.codegen_expression(builder, index_exp.index)
        let expr_val_ty = index_exp.expression.value_type
        let ty = is_pointer(expr_val_ty) ? this.codegen_type((expr_val_ty as PointerType).pointee_type) : this.codegen_type(expr_val_ty)
        let ind_ptr: LLVMValueRef = null
        if expr_val_ty.kind == TypeKind.ARRAY {
            let indices: LLVMValueRef[2] = [this.createLLVMInt(0), index]
            ind_ptr = this.get_expr_mem(builder, index_exp.expression)
            return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices[0], 2, "arrayidx")
        }
        let indices_1: LLVMValueRef[1] = [index]
        ind_ptr = this.codegen_expression(builder, index_exp.expression)
        return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices_1[0], 1, "ptridx")
    }
    private get_member_expr_mem(this, builder: LLVMBuilderRef, member_expr: MemberExpression, ptr: LLVMValueRef): LLVMValueRef {
        let struct_class = this.get_or_codegen_class_from_typeid(member_expr.member_id.type_id)
        let prop_id_key = create_prop_key(member_expr.member_id)
        let struct_type = struct_class.llvm_type
        let method = struct_class.static_props_map[prop_id_key]
        if method != null return method
        if ptr == null {
            ptr = this.codegen_expression(builder, member_expr.expression)
        }
        const indices_count = 2
        let indices_buffer: LLVMValueRef[indices_count] = [LLVMConstInt(LLVMInt32Type(), 0, false), null]
        if !is_function(member_expr.value_type) {
            let vtoffset = struct_class.vtable_type == null ? 0 : 1
            indices_buffer[1] = LLVMConstInt(LLVMInt32Type(), struct_class.fields_pos_map[prop_id_key] + vtoffset as i64, false)
        } else {
            indices_buffer[1] = LLVMConstInt(LLVMInt32Type(), 0, false)
            ptr = LLVMBuildInBoundsGEP2(builder, struct_type, ptr, &indices_buffer[0], indices_count, "")
            ptr = LLVMBuildLoad2(builder, LLVMPointerType(struct_class.vtable_type), ptr, "")
            indices_buffer[1] = LLVMConstInt(LLVMInt32Type(), struct_class.vt_methods_pos_map[prop_id_key] as i64, false)
            struct_type = struct_class.vtable_type
        }
        return LLVMBuildInBoundsGEP2(builder, struct_type, ptr, &indices_buffer[0], indices_count, "memberidx")
    }
    private get_expr_mem(this, builder: LLVMBuilderRef, exp: Expression): LLVMValueRef {
        if exp.expr_kind == ExpressionKind.ACCESS
            return this.get_var_expr_mem(builder, exp as VarAccessExpression)
        if exp.expr_kind == ExpressionKind.INDEX
            return this.get_index_expr_mem(builder, exp as IndexExpression)
        if exp.expr_kind == ExpressionKind.MEMBER
            return this.get_member_expr_mem(builder, exp as MemberExpression, null)
        return this.codegen_expression(builder, exp)
    }
    // Only call for non-static members.
    private get_member_mem_with_name(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_type: ObjectType, name: string, save_type: Type* = null): LLVMValueRef {
        let obj_class = get_class_from_type(this.program, obj_type)
        let prop_id = obj_class.prop_map[name]
        if prop_id == null  return null
        let prop_ty = get_class_prop_type(this.program, prop_id)
        if save_type != null save_type[0] = prop_ty
        let member_expr: MemberExpression(null, prop_id, prop_ty)
        return this.get_member_expr_mem(builder, member_expr, self)
    }
    // Only call for non-static members.
    private get_member_with_name(this, builder: LLVMBuilderRef, self: LLVMValueRef, obj_type: ObjectType, name: string, save_type: Type* = null): LLVMValueRef {
        let obj_class = get_class_from_type(this.program, obj_type)
        let prop_id = obj_class.prop_map[name]
        if prop_id == null  return null
        let prop_ty = get_class_prop_type(this.program, prop_id)
        if save_type != null save_type[0] = prop_ty
        let expr: Expression(ExpressionKind.ACCESS)
        expr.value_type = obj_type
        let member_expr: MemberExpression(expr, prop_id, prop_ty)
        return this.codegen_member_exp(builder, member_expr, self)
    }
    private codegen_builtin_array(this, builder: LLVMBuilderRef, arrgen_ty: GenericType, arr_expr: ArrayExpression): LLVMValueRef {
        let obj_ty = (arrgen_ty as GenericType).instantiated_type as ObjectType
        let objllvm_ty = this.codegen_type(obj_ty, false)
        let elmllvm_ty = this.codegen_type(arrgen_ty.arg_types[0])
        let self = LLVMBuildMalloc(builder, objllvm_ty, "")
        let len_val = arr_expr.elements.length
        let size_value = this.createLLVMInt(len_val > 0 ? len_val: 1)
        let len_value = this.createLLVMInt(len_val)
        let args: LLVMValueRef[2] = [self, LLVMConstMul(size_value, LLVMSizeOf(elmllvm_ty))]
        this.build_constructor_call(builder, obj_ty, &args[0], 2)
        let buff_ptr = this.get_member_mem_with_name(builder, self, obj_ty, "buffer")
        let arg_ptr = LLVMBuildLoad2(builder, LLVMPointerType(elmllvm_ty), buff_ptr, "")
        this.store_array_elements(builder, arg_ptr, arr_expr)
        let len_ptr = this.get_member_mem_with_name(builder, self, obj_ty, "length")
        LLVMBuildStore(builder, len_value, len_ptr)
        return self
    }
    private store_expr_to_mem(this, builder: LLVMBuilderRef, ptr: LLVMValueRef, expr: Expression): LLVMValueRef {
        let value: LLVMValueRef = null
        if expr.expr_kind == ExpressionKind.ARRAY and !expr.is_constant {
            let arr_expr = expr as ArrayExpression
            let value_ty = expr.value_type
            if value_ty.kind != TypeKind.RESOLVED_GENERIC {
                let zero = this.createLLVMInt(0)
                let args: LLVMValueRef[2] = [zero, zero]
                let array_type = this.codegen_type(value_ty)
                ptr = LLVMBuildInBoundsGEP2(builder, array_type, ptr, &args[0], 2, "")
                return this.store_array_elements(builder, ptr, arr_expr)
            }
            value = this.codegen_builtin_array(builder, value_ty as GenericType, arr_expr)
        } else {
            value = this.codegen_expression(builder, expr)
        }
        LLVMBuildStore(builder, value, ptr)
        return value
    }
    private codegen_assignment(this, builder: LLVMBuilderRef, assign_exp: BinaryExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, assign_exp.lhs)
        return this.store_expr_to_mem(builder, ptr, assign_exp.rhs)
    }
    private codegen_pow_expr(this, builder: LLVMBuilderRef, ty: Type,  lhs: LLVMValueRef, rhs: LLVMValueRef): LLVMValueRef {
        let args: LLVMValueRef[2] = [lhs, rhs]
        let name = "llvm.pow.$(dump_type(ty, true))"
        let llvmty = this.codegen_type(ty)
        let arg_types: LLVMTypeRef[2] = [llvmty, llvmty]
        let res = get_intrinsic(this.module, name, &arg_types[0], 2, llvmty)
        return LLVMBuildCall2(builder, res.fnc_type, res.call, &args[0], 2, "")
    }
    private codegen_bin_exp(this, builder: LLVMBuilderRef, bin_exp: BinaryExpression): LLVMValueRef {   
        let op = bin_exp.op
        if bin_exp.lhs.value_type.kind != bin_exp.rhs.value_type.kind {
            if op == BinaryOp.EEQ
                return this.createLLVMBool(false)
            else if op == BinaryOp.NEQ
                return this.createLLVMBool(true)
        }
        if op == BinaryOp.ASSIGN
            return this.codegen_assignment(builder, bin_exp)
        let lhs = this.codegen_expression(builder, bin_exp.lhs)
        let rhs = this.codegen_expression(builder, bin_exp.rhs)
        if is_null(bin_exp.rhs) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ) {
            if LLVMIsConstant(lhs)
                return this.createLLVMBool(op == BinaryOp.EEQ ? LLVMIsNull(lhs) : LLVMIsNull(lhs))
            return op == BinaryOp.EEQ ? LLVMBuildIsNull(builder, lhs, "") : LLVMBuildIsNotNull(builder, lhs, "")
        }
        let lty = bin_exp.lhs.value_type
        let rty = bin_exp.rhs.value_type
        if is_numeric(rty) and op == BinaryOp.POW
            return this.codegen_pow_expr(builder, rty, lhs, rhs)
        if is_pointer(lty){
            let indices: LLVMValueRef[1] = [op == BinaryOp.ADD ? rhs: CodeGen.neg_int(builder, rhs)]
            let pointee_type = this.codegen_type((lty as PointerType).pointee_type)
            return LLVMBuildInBoundsGEP2(builder, pointee_type, lhs, &indices[0], 1, "")
        }
        let ipred: LLVMIntPredicate = null
        let rpred: LLVMRealPredicate = null
        let is_const_expr = LLVMIsConstant(lhs) and LLVMIsConstant(rhs)
        if is_int(rty) or (is_object(lty) and is_object(rty) and (op == BinaryOp.EEQ or op == BinaryOp.NEQ)) or (rty.kind == TypeKind.ENUM) {
            if op == BinaryOp.ADD {
                return is_const_expr ? LLVMConstNSWAdd(lhs, rhs) : LLVMBuildNSWAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return is_const_expr ? LLVMConstSub(lhs, rhs) : LLVMBuildSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return is_const_expr ? LLVMConstMul(lhs, rhs) : LLVMBuildMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildSDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildSRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                ipred = ((op as int) - (BinaryOp.GT as int) + 38) as LLVMIntPredicate // Consider Enum variants
                return is_const_expr ? LLVMConstICmp(ipred, lhs, rhs) : LLVMBuildICmp(builder, ipred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                ipred = ((op as int) - (BinaryOp.EEQ as int) + 32) as LLVMIntPredicate
                return is_const_expr ? LLVMConstICmp(ipred, lhs, rhs) : LLVMBuildICmp(builder, ipred, lhs, rhs, "")
            } else if op == BinaryOp.SL {
                return is_const_expr ? LLVMConstShl(lhs, rhs) : LLVMBuildShl(builder, lhs, rhs, "")
            } else if op == BinaryOp.SR {
                return is_const_expr ? LLVMConstLShr(lhs, rhs) : LLVMBuildLShr(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.AND {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.XOR {
                return is_const_expr ? LLVMConstXor(lhs, rhs) : LLVMBuildXor(builder, lhs, rhs, "")
            }
        } else if is_float(rty) {
            if op == BinaryOp.ADD { 
                return LLVMBuildFAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return LLVMBuildFSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return LLVMBuildFMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildFDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildFRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                rpred = ((op as int) - (BinaryOp.GT as int) + (LLVMRealPredicate.LLVMRealOGT as int)) as LLVMRealPredicate
                return is_const_expr ? LLVMConstFCmp(rpred, lhs, rhs) : LLVMBuildFCmp(builder, rpred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                rpred = op == BinaryOp.NEQ ? LLVMRealPredicate.LLVMRealONE : LLVMRealPredicate.LLVMRealOEQ
                return is_const_expr ? LLVMConstFCmp(rpred, lhs, rhs) : LLVMBuildFCmp(builder, rpred, lhs, rhs, "")
            }
        } else if is_bool(rty) {
            if op == BinaryOp.AND or op == BinaryOp.EEQ {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.NEQ {
                return is_const_expr ? LLVMConstXor(lhs, rhs) : LLVMBuildXor(builder, lhs, rhs, "")
            }
        }
        panic("Unknown bin expression case case!")
        return null
    }
    private codegen_typecast_exp(this, builder: LLVMBuilderRef, type_exp: TypeCastExpression): LLVMValueRef {
        let exp = type_exp.expr
        let value_type = type_exp.value_type
        let val = this.codegen_expression(builder, exp)
        let ty = this.codegen_type(value_type)
        let is_const = LLVMIsConstant(val)
        if is_bool(value_type) {
            return is_const ? this.createLLVMBool(!LLVMIsNull(val)) : LLVMBuildIsNotNull(builder, val, "")
        }
        if is_int(exp.value_type) and is_float(value_type) {
            return is_const ? LLVMConstSIToFP(val, ty) : LLVMBuildSIToFP(builder, val, ty, "")
        } else if is_float(exp.value_type) and is_int(value_type) {
            return is_const ? LLVMConstFPToSI(val, ty) : LLVMBuildFPToSI(builder, val, ty, "")
        } else if is_int(exp.value_type) and is_int(value_type){
            if value_type.kind != TypeKind.I128
                return is_const ? LLVMConstIntCast(val, ty, true) : LLVMBuildIntCast2(builder, val, ty, true, "")
            return is_const ? LLVMConstSExt(val, ty) : LLVMBuildSExt(builder, val, ty, "")
        } else if is_float(exp.value_type) and is_float(value_type){
            return is_const ? LLVMConstFPCast(val, ty) : LLVMBuildFPCast(builder, val, ty, "")
        }
        return is_const ? LLVMConstBitCast(val, ty) : LLVMBuildBitCast(builder, val, ty, "")
    }
    //TODO: Refactor!!
    private codegen_unary_exp(this, builder: LLVMBuilderRef, unary_exp: UnaryExpression): LLVMValueRef { 
        let op = unary_exp.op
        let exp = unary_exp.expression
        let val = this.codegen_expression(builder, exp)
        if op == UnaryOp.DEL {
            if is_object(exp.value_type)
                this.codegen_del_call(builder, val, exp.value_type as ObjectType)
            LLVMBuildFree(builder, val)
            return null
        }
        if op == UnaryOp.NEG {
            if is_int(exp.value_type){
                return CodeGen.neg_int(builder, val)
            } else if is_float(exp.value_type){
                return LLVMBuildFNeg(builder, val, "")
            }
        } 
        if op == UnaryOp.NOT {
            return LLVMIsConstant(val) ? LLVMConstNot(val) : LLVMBuildNot(builder, val, "")
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR or op == UnaryOp.ADDROF {
            let ptr = this.get_expr_mem(builder, exp)
            if op == UnaryOp.ADDROF {
                return ptr
            }
            let alloc_ty = this.codegen_type(exp.value_type)
            let incr_value = op == UnaryOp.PREINCR or op == UnaryOp.POSTINCR ? 1 : -1
            let new_value: LLVMValueRef = null
            if is_pointer(exp.value_type) {
                alloc_ty = this.codegen_type((exp.value_type as PointerType).pointee_type)
                let indices: LLVMValueRef[1] = [this.createLLVMInt(incr_value)]
                new_value = LLVMBuildInBoundsGEP2(builder, alloc_ty, val, &indices[0], 1, "incdec.ptr")
            } else if is_numeric(exp.value_type){
                let incr_amt = is_int(exp.value_type) ? LLVMConstInt(alloc_ty, incr_value as i64, false) : LLVMConstReal(alloc_ty, incr_value * 1.0 as f64)
                new_value = LLVMBuildNSWAdd(builder, val, incr_amt, "")
            }
            LLVMBuildStore(builder, new_value, ptr)
            return op >= UnaryOp.PREDECR ? val : new_value 
        }
        return val
    }
    private codegen_var_access_exp(this, builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let val = this.get_or_codegen_var(var_exp.value_id)
        let ty = this.codegen_type(var_exp.value_type)
        if val == null {
            panic("This should never happen; (codegen_var_access_exp)")
        }
        if var_exp.value_id.kind == VarIdKind.FNC
            return val
        if this.in_static_ctx
            return LLVMGetInitializer(val)
        return LLVMBuildLoad2(builder, ty, val, "")
    }
    private codegen_null(this, null_exp: NullExpression): LLVMValueRef{
        return LLVMConstNull(this.codegen_type(null_exp.value_type))
    }
    private codegen_ternary_exp(this, builder: LLVMBuilderRef, ternary_exp: TernaryExpression): LLVMValueRef {
        let true_block = LLVMAppendBasicBlock(this.function, "true_block")
        let false_block = LLVMAppendBasicBlock(this.function, "false_block")
        let end = LLVMAppendBasicBlock(this.function, "end")
        let cond = this.codegen_expression(builder, ternary_exp.cond)
        LLVMBuildCondBr(builder, cond, true_block, false_block)
        LLVMPositionBuilderAtEnd(builder, true_block)
        let is_true = this.codegen_expression(builder, ternary_exp.is_true)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, false_block)
        let is_false = this.codegen_expression(builder, ternary_exp.is_false)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, end)
        let phi_node = LLVMBuildPhi(builder, this.codegen_type(ternary_exp.is_true.value_type), "ternary")
        let incomming_vals: LLVMValueRef[2] = [is_true, is_false]
        let blocks: LLVMBasicBlockRef[2] = [true_block, false_block]
        LLVMAddIncoming(phi_node, &incomming_vals[0], &blocks[0], 2)
        return phi_node
    }
    /* TODO: Needs refactoring to remove array expression */
    private codegen_call_exp(this, builder: LLVMBuilderRef, call_exp: CallExpression): LLVMValueRef {
        let func: LLVMValueRef = null
        let args_value: LLVMValueRef[] = []
        if call_exp.callee.expr_kind == ExpressionKind.MEMBER {
            let member_exp = call_exp.callee as MemberExpression
            if !get_method(this.program, member_exp.member_id).is_static {
                let struct_class = this.get_or_codegen_class_from_typeid(member_exp.member_id.type_id)
                let self = this.codegen_expression(builder, member_exp.expression)
                func = this.codegen_member_exp(builder, member_exp, self)
                args_value << self
            }
        }
        if func == null {
            if call_exp.callee.expr_kind == ExpressionKind.ACCESS {
                let super_id = (call_exp.callee as VarAccessExpression).value_id
                let this_param = this.super_functions[create_var_key(super_id)]
                if this_param != null {
                    args_value << this_param
                }
            }
            func = this.codegen_expression(builder, call_exp.callee)
        }
        for call_arg in call_exp.args {
            args_value << this.codegen_expression(builder, call_arg)
        }
        return LLVMBuildCall2(builder, this.codegen_type(call_exp.callee.value_type, false), func, args_value.buffer, args_value.length, "")
    }
    private codegen_index_exp(this, builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, index_exp)
        return LLVMBuildLoad2(builder, this.codegen_type(index_exp.value_type), ptr, "")
    }
    private codegen_new_exp(this, builder: LLVMBuilderRef, new_expr: NewExpression): LLVMValueRef {
        let ptr: LLVMValueRef = null
        let alloc_ty = new_expr.memory_type
        let llvm_type: LLVMTypeRef = null
        if is_pointer(new_expr.value_type) {
            llvm_type = this.codegen_type(alloc_ty)
            let size = this.codegen_expression(builder, new_expr.args[0])
            if new_expr.onheap {
                ptr = LLVMBuildArrayMalloc(builder, llvm_type, size, "")
            } else {
                ptr = LLVMBuildArrayAlloca(builder, llvm_type, size, "")
            }
        } else if is_object(alloc_ty) {
            let args_length = new_expr.args.length + 1
            let args: LLVMValueRef*(args_length)
            llvm_type = this.codegen_type(alloc_ty, false)
            if new_expr.onheap {
                ptr = LLVMBuildMalloc(builder, llvm_type, "")
            } else {
                ptr = LLVMBuildAlloca(builder, llvm_type, "")
            }
            args[0] = ptr
            this.evaluate_expression_list(builder, args, 1, new_expr.args)
            this.build_constructor_call(builder, alloc_ty as ObjectType, args, args_length)
        }
        return ptr
    }
    private codegen_member_exp(this, builder: LLVMBuilderRef, member_exp: MemberExpression, self: LLVMValueRef): LLVMValueRef {
        if is_object(member_exp.expression.value_type) {
            let ptr = this.get_member_expr_mem(builder, member_exp, self)
            if get_class_prop_visibility(this.program, member_exp.member_id) == ACCESS_ATTR.PRIVATE and is_function(member_exp.value_type)
                return ptr
            return LLVMBuildLoad2(builder, this.codegen_type(member_exp.value_type), ptr, "")
        }
        let var_id = (member_exp.expression as VarAccessExpression).value_id
        let prop_id_key = create_prop_key(member_exp.member_id)
        if var_id.kind == VarIdKind.CLASS {
            let struct_class = this.get_or_codegen_class_from_typeid(ClassVarId.to_classId(var_id))
            if struct_class == null {
                panic("this should not happen; (codegen_member_exp); class")
            }
            let prop = struct_class.static_props_map[prop_id_key]
            if prop == null {
                panic("This should never happen; (codegen_member_expr; class prop)")
            }
            if is_function(member_exp.value_type)
                return prop
            return LLVMBuildLoad2(builder, this.codegen_type(member_exp.value_type), prop, "")
        }
        if var_id.kind == VarIdKind.ENUM {
           let enum_type = this.get_or_codegen_enum_from_typeid(EnumVarId.to_enumId(var_id)) 
             if enum_type == null {
                panic("this should not happen; (codegen_member_exp); enum")
            }
            return enum_type.field_map[prop_id_key]
        }
        return null
    }
    private codegen_string_to_cstring(this, builder: LLVMBuilderRef, value: LLVMValueRef): LLVMValueRef {
        let string_class_id = get_scope(this.program, this.program.modules[0].scope).classes["string"]
        let string_obj_ty: ObjectType(string_class_id)
        let prop_ty = get_class_prop_type_with_name(this.program, string_obj_ty, "to_cstring")
        let func = this.get_member_with_name(builder, value, string_obj_ty, "to_cstring")
        let args: LLVMValueRef[1] = [value] 
        return LLVMBuildCall2(builder, this.codegen_type(prop_ty, false), func, &args[0], 1, "")
    }
    private codegen_intrinsic_exp(this, builder: LLVMBuilderRef, intrinsic_call_exp: IntrinsicCall): LLVMValueRef {
        let intrinsic_type = intrinsic_call_exp.intrinsic
        if intrinsic_type < Intrinsics.MEMCPY {
            let cbuff = this.codegen_string_to_cstring(builder, this.codegen_expression(builder, intrinsic_call_exp.args[0]))
            let value: LLVMValueRef = null
            if intrinsic_type == Intrinsics.STR_TO_F {
                value = this.codegen_atof_call(builder, cbuff)
            }
            if intrinsic_type == Intrinsics.STR_TO_I {
                value = this.codegen_atoi_call(builder, cbuff)
            }
            if intrinsic_type == Intrinsics.STR_TO_L {
                value = this.codegen_atol_call(builder, cbuff)
            }
            LLVMBuildFree(builder, cbuff)
            return value
        }
        let args: LLVMValueRef*(intrinsic_call_exp.args.length)
        this.evaluate_expression_list(builder, args, 0, intrinsic_call_exp.args)
        let arg0_pointee_ty = (intrinsic_call_exp.args[0].value_type as PointerType).pointee_type
        let arg0_pointee_size = LLVMSizeOf(this.codegen_type(arg0_pointee_ty))
        if intrinsic_type == Intrinsics.MEMRESIZE {
            args[1] = LLVMBuildMul(builder, args[1], arg0_pointee_size, "")
            return this.codegen_realloc_call(builder, args)
        }
        args[2] = LLVMBuildMul(builder, args[2], arg0_pointee_size, "")
        if intrinsic_type == Intrinsics.MEMCMP {
            return this.codegen_memcmp_call(builder, args)
        }

        let arg0_align = LLVMGetAlignment(args[0])
        if intrinsic_type == Intrinsics.MEMSET {
            return LLVMBuildMemSet(builder, args[0], LLVMBuildIntCast2(builder, args[1], LLVMInt8Type(), false, ""), args[2], arg0_align)
        }

        let arg1_align = LLVMGetAlignment(args[1])
        if intrinsic_type == Intrinsics.MEMCPY {
            return LLVMBuildMemCpy(builder, args[0], arg0_align, args[1], arg1_align, args[2])
        }
        if intrinsic_type == Intrinsics.MEMMOVE {
            return LLVMBuildMemMove(builder, args[0], arg0_align, args[1], arg1_align, args[2])
        }
        panic("instrinsic not found!")
        return null
    }
    private codegen_expression(this, builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        if expression.expr_kind == ExpressionKind.BOOL
            return this.codegen_bool(expression as BooleanExpression)
        if expression.expr_kind == ExpressionKind.INT
            return this.codegen_int(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegen_float(expression as FloatExpression)
        if expression.expr_kind == ExpressionKind.NULL
            return this.codegen_null(expression as NullExpression)
        if expression.expr_kind == ExpressionKind.STRING
            return this.codegen_string(builder, expression as StringExpression)
        if expression.expr_kind == ExpressionKind.ACCESS
            return this.codegen_var_access_exp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegen_bin_exp(builder, expression as BinaryExpression)
        if expression.expr_kind == ExpressionKind.UNARY
             return this.codegen_unary_exp(builder, expression as UnaryExpression)
        if expression.expr_kind == ExpressionKind.CALL
            return this.codegen_call_exp(builder, expression as CallExpression)
        if expression.expr_kind == ExpressionKind.INDEX
            return this.codegen_index_exp(builder, expression as IndexExpression)
        if expression.expr_kind == ExpressionKind.MEMBER
            return this.codegen_member_exp(builder, expression as MemberExpression, null)
        if expression.expr_kind == ExpressionKind.NEW
            return this.codegen_new_exp(builder, expression as NewExpression)
        if expression.expr_kind == ExpressionKind.TERNARY
            return this.codegen_ternary_exp(builder, expression as TernaryExpression)
        if expression.expr_kind == ExpressionKind.CAST
            return this.codegen_typecast_exp(builder, expression as TypeCastExpression)
        if expression.expr_kind == ExpressionKind.ARRAY
            return this.codegen_array_exp(builder, expression as ArrayExpression)
        if expression.expr_kind == ExpressionKind.INTRINSIC
            return this.codegen_intrinsic_exp(builder, expression as IntrinsicCall)
        return null
    }
    private codegen_if_stmt(this, builder: LLVMBuilderRef, if_stmt: IfStatement){
        let condition = this.codegen_expression(builder, if_stmt.condition)
        let if_bb = LLVMAppendBasicBlock(this.function, "if.entry")
        let else_bb = LLVMAppendBasicBlock(this.function, "else")
        let merge_bb = LLVMAppendBasicBlock(this.function, "ifend")
        LLVMBuildCondBr(builder, condition, if_bb, else_bb)
        LLVMPositionBuilderAtEnd(builder, if_bb)
        this.codegen_block(builder, if_stmt.block)
        let if_terminated = is_terminated(if_stmt.block)
        if !if_terminated
            LLVMBuildBr(builder, merge_bb)

        LLVMPositionBuilderAtEnd(builder, else_bb)
        let else_terminated = false
        if if_stmt.else_block != null {
            this.codegen_block(builder, if_stmt.else_block)
            else_terminated = is_terminated(if_stmt.else_block)
        }
        if !else_terminated
            LLVMBuildBr(builder, merge_bb)
        else if if_terminated
            LLVMDeleteBasicBlock(merge_bb)
    
        LLVMPositionBuilderAtEnd(builder, merge_bb)
    }
    private codegen_for_stmt(this, builder: LLVMBuilderRef, for_stmt: ForStatement){
        let for_entry_block = LLVMAppendBasicBlock(this.function, "for.entry")
        LLVMBuildBr(builder, for_entry_block)
        LLVMPositionBuilderAtEnd(builder, for_entry_block)
        if for_stmt.for_in_setup != null {
            this.codegen_statement(builder, for_stmt.for_in_setup)
        }
        if for_stmt.initialization != null {
            this.codegen_statement(builder, for_stmt.initialization)
        }
        let for_cond_block = LLVMAppendBasicBlock(this.function, "for.cond")
        let for_body_block = LLVMAppendBasicBlock(this.function, "for.body")
        let for_incr_block = LLVMAppendBasicBlock(this.function, "for.incr")
        let for_end_block = LLVMAppendBasicBlock(this.function, "for.end")
        let prev_break_bb = this.break_bb
        let prev_continue_bb = this.continue_bb
        this.break_bb = for_end_block
        this.continue_bb = for_incr_block
        LLVMBuildBr(builder, for_cond_block)
        LLVMPositionBuilderAtEnd(builder, for_cond_block)
        let condition = this.createLLVMBool(true)
        if for_stmt.condition != null {
            condition = this.codegen_expression(builder, for_stmt.condition)
        }
        LLVMBuildCondBr(builder, condition, for_body_block, for_end_block)
        LLVMPositionBuilderAtEnd(builder, for_body_block)
        this.codegen_block(builder, for_stmt.block)
        if !is_terminated(for_stmt.block)
            LLVMBuildBr(builder, for_incr_block)
        LLVMPositionBuilderAtEnd(builder, for_incr_block)
        if for_stmt.incr_decr != null
            this.codegen_statement(builder, for_stmt.incr_decr)
        LLVMBuildBr(builder, for_cond_block)
        this.break_bb = prev_break_bb
        this.continue_bb = prev_continue_bb
        LLVMPositionBuilderAtEnd(builder, for_end_block)
        if for_stmt.for_in_setup != null {
            let var_id = (for_stmt.for_in_setup as VarDeclaration).var_id
            let it_load_exp: VarAccessExpression(var_id, get_var(this.program, var_id).value_type)
            let mem = this.codegen_var_access_exp(builder, it_load_exp)
            LLVMBuildFree(builder, mem)
        }
    }
    private codegen_while_stmt(this, builder: LLVMBuilderRef, while_stmt: WhileStatement){
        let while_bb = LLVMAppendBasicBlock(this.function, "while.entry")
        let while_end_bb = LLVMAppendBasicBlock(this.function, "while.end")
        let prev_break_bb = this.break_bb
        let prev_continue_bb = this.continue_bb
        this.break_bb = while_end_bb
        this.continue_bb = while_bb
        let condition = this.codegen_expression(builder, while_stmt.condition)
        LLVMBuildCondBr(builder, condition, while_bb, while_end_bb)
        LLVMPositionBuilderAtEnd(builder, while_bb)
        this.codegen_block(builder, while_stmt.block)
        if !is_terminated(while_stmt.block) {
            condition = this.codegen_expression(builder, while_stmt.condition)
            LLVMBuildCondBr(builder, condition, while_bb, while_end_bb)
        }
        LLVMPositionBuilderAtEnd(builder, while_end_bb)
        this.break_bb = prev_break_bb
        this.continue_bb = prev_continue_bb
    }
    private evaluate_expression_list(this, builder: LLVMBuilderRef, evaluated_list: LLVMValueRef*, start: int, list: Expression[]){
        for item in list {
            evaluated_list[start++] = this.codegen_expression(builder, item)
        }
    }
    private build_constructor_call(this, builder: LLVMBuilderRef, obj_type: ObjectType, params: LLVMValueRef*, params_length: int){
        let checked_class = get_class_from_type(this.program, obj_type)
        let constructor = this.get_or_codegen_class_from_typeid(obj_type.class_id).class_constructor
        if constructor != null {
            LLVMBuildCall2(builder, LLVM_GetFunctionType(constructor), constructor, params, params_length, "")
        } else {
            panic("Could not find constructor for constructor call")
        }
    }
    private codegen_var_declaration(this, builder: LLVMBuilderRef, var_decl: VarDeclaration){
        let var_id = var_decl.var_id
        let var = get_var(this.program, var_id)
        let expression = var.value
        let expression_val_type = var.value_type
        let ty = this.codegen_type(expression_val_type)
        let name = var_decl.name.to_cstring()
        let ptr: LLVMValueRef = null
        if var_decl.is_static {
            ptr = LLVMAddGlobal(this.module, ty, name)
            if expression != null {
                let value = this.codegen_expression(builder, expression)
                LLVMSetInitializer(ptr, value)
            }
        } else {
            ptr = LLVMBuildAlloca(builder, ty, name)
            if expression != null {
                this.store_expr_to_mem(builder, ptr, expression)
            }
        }
        this.add_var(var_id, ptr)
    }
    private codegen_const_declaration(this, builder: LLVMBuilderRef, const_decl: ConstDeclaration){
        let const_id = const_decl.const_id
        let expression = get_const(this.program, const_id).value
        let ty = this.codegen_type(expression.value_type)
        let name = const_decl.name.to_cstring()
        let ptr: LLVMValueRef = null
        if const_decl.is_static {
            let value = this.codegen_expression(builder, expression)
            ptr = LLVMAddGlobal(this.module, ty, name)
            LLVMSetInitializer(ptr, value)
            LLVMSetGlobalConstant(ptr, true)
        } else {
            ptr = LLVMBuildAlloca(builder, ty, name)
            this.store_expr_to_mem(builder, ptr, expression)
        }
        this.add_var(const_id, ptr)
    }
    private codegen_statement(this, builder: LLVMBuilderRef, statement: Statement){
        if statement.kind == StatementKind.IF
            this.codegen_if_stmt(builder, statement as IfStatement)
        if statement.kind == StatementKind.FOR
            this.codegen_for_stmt(builder, statement as ForStatement)
        if statement.kind == StatementKind.WHILE
            this.codegen_while_stmt(builder, statement as WhileStatement)
        if statement.kind == StatementKind.CONTINUE
            LLVMBuildBr(builder, this.continue_bb)
        if statement.kind == StatementKind.BREAK
            LLVMBuildBr(builder, this.break_bb)
        if statement.kind == StatementKind.VAR
            this.codegen_var_declaration(builder, statement as VarDeclaration)
        if statement.kind == StatementKind.CONST
            this.codegen_const_declaration(builder, statement as ConstDeclaration)
        if statement.kind == StatementKind.RETURN
            this.codegen_return_stmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegen_expression(builder, statement as Expression)
    }
    private codegen_block(this, builder: LLVMBuilderRef, block: Block){
        let was_instatic_ctx = this.in_static_ctx
        this.in_static_ctx = false
        for statement in block.statements {
            this.codegen_statement(builder, statement)
        }
        this.in_static_ctx = was_instatic_ctx
    }
    private codegen_function(this, func: Function){
        let fn_name = func.name.to_cstring()
        let llvm_fnc = LLVMAddFunction(this.module, fn_name, this.codegen_type(func.fnc_type, false))
        this.add_var(func.id, llvm_fnc)
        if func.is_external { 
            LLVMSetLinkage(llvm_fnc, LLVMLinkage.LLVMExternalLinkage)
            return
        }
        let func_builder = LLVMCreateBuilder()
        LLVMPositionBuilderAtEnd(func_builder, LLVMAppendBasicBlock(llvm_fnc, ""))
        for let i = 0; i < func.args.length; i++ {
            let arg = func.args[i]
            let param = LLVMGetParam(llvm_fnc, i)
            let alloc = LLVMBuildAlloca(func_builder, this.codegen_type(arg.value_type), arg.name.to_cstring())
            LLVMBuildStore(func_builder, param, alloc)
            this.add_var(arg.id, alloc)
        }
        let prev_func = this.function
        this.function = llvm_fnc
        this.codegen_block(func_builder, func.block)
        LLVMDisposeBuilder(func_builder)
        this.function = prev_func
    }
    private codegen_class(this, checked_class: Class){
        let struct_class = this.get_class_from_typeid(checked_class.id)
        for method in checked_class.methods {
            if method.is_abstract continue
            let prop_id_key = create_prop_key(method.id)
            let llvm_fnc = struct_class.static_props_map[prop_id_key]
            let is_constructor = method.name == "constructor"
            llvm_fnc = LLVMGetNamedFunction(this.module, "$(checked_class.name)_$(method.name)".to_cstring())
            let entry_block = LLVMAppendBasicBlock(llvm_fnc, "")
            let func_builder = LLVMCreateBuilder()
            LLVMPositionBuilderAtEnd(func_builder, entry_block)
            let offset = 0
            if !method.is_static {
                let object_type = LLVMPointerType(struct_class.llvm_type)
                let this_param = LLVMGetParam(llvm_fnc, 0)
                let this_alloc = LLVMBuildAlloca(func_builder, object_type, "this")
                let this_id = get_scope(this.program, method.scope).vars["this"]
                LLVMBuildStore(func_builder, this_param, this_alloc)
                this.add_var(this_id, this_alloc)
                if is_constructor {
                    if struct_class.vtable != null {
                        let index: LLVMValueRef[1] = [this.createLLVMInt(0)]
                        let vt_ptr =  LLVMBuildInBoundsGEP2(func_builder, object_type, this_param, &index[0], 1, "")
                        LLVMBuildStore(func_builder, struct_class.vtable, vt_ptr)
                    }
                    let parent_ty = checked_class.parent as ObjectType
                    if parent_ty != null {
                        let super_id = get_scope(this.program, method.scope).vars["super"]
                        if super_id != null {
                            let super_constructor = this.get_or_codegen_class_from_typeid(parent_ty.class_id).class_constructor
                            let super_ptr = LLVMBuildAlloca(func_builder, object_type, "super")
                            LLVMBuildStore(func_builder, super_constructor, super_ptr)
                            this.add_var(super_id, super_ptr)
                            this.super_functions[create_var_key(super_id)] = this_param
                        }
                    }
                }
                offset = 1
            }
            for let i = 0; i < method.args.length; i++ {
                let arg = method.args[i]
                let param = LLVMGetParam(llvm_fnc, i + offset)
                let alloc = LLVMBuildAlloca(func_builder, this.codegen_type(arg.value_type), arg.name.to_cstring())
                LLVMBuildStore(func_builder, param, alloc)
                this.add_var(arg.id, alloc)
            }
            let prev_func = this.function
            this.function = llvm_fnc
            this.codegen_block(func_builder, method.block)
            this.function = prev_func
            LLVMDisposeBuilder(func_builder)
        }
    }
    private declare_method(this, method_name: string, method_type: LLVMTypeRef): LLVMValueRef {
        return LLVMAddFunction(this.module, method_name.to_cstring(), method_type)
    }
    private declare_static_props(this, struct_class: CGClassType, checked_class: Class){
        for entry in checked_class.static_prop_map {
            let prop_id = entry.value
            let static_prop_name = entry.key
            let prop_id_key = create_prop_key(prop_id)
            let prop_type = get_class_prop_type(this.program, prop_id)
            let static_prop_type = this.codegen_type(prop_type, is_object(prop_type))
            let static_prop_name_concat = "$(checked_class.name)_$static_prop_name"
            let static_prop_value: LLVMValueRef = null
            if prop_id.kind == PropIdKind.METHOD {
                static_prop_value = this.declare_method(static_prop_name_concat, static_prop_type)
            } else {
                static_prop_value = LLVMAddGlobal(this.module, static_prop_type, static_prop_name_concat.to_cstring())
                let global_prop_initializer = this.codegen_expression(null, checked_class.fields[prop_id.id].initializer)
                LLVMSetInitializer(static_prop_value, global_prop_initializer)
            }
            struct_class.static_props_map[prop_id_key] = static_prop_value
        }
    }
    private declare_class_props(this, struct_class: CGClassType, checked_class: Class, prop_types: LLVMTypeRef[]){
        let vtable_values: LLVMValueRef[] = []
        let vtable_types: LLVMTypeRef[] = []
        let field_types: LLVMTypeRef[] = []
        for entry in checked_class.prop_map {
            let prop_id = entry.value
            let prop_name = entry.key
            let prop_owner = checked_class
            let prop_id_key = create_prop_key(prop_id)
            let prop_type = get_class_prop_type(this.program, prop_id)
            let prop_index = get_vtable_index(this.program, prop_id)
            if prop_id.kind == PropIdKind.FIELD {
                let field_type = this.codegen_type(prop_type)
                struct_class.fields_pos_map[prop_id_key] = prop_index
                resize_type_array(field_types, prop_index)
                field_types[prop_index] = field_type
            } else {
                let method_type = prop_type as FunctionType
                let llvm_method_val: LLVMValueRef = null
                let llvm_method_type: LLVMTypeRef = null
                if prop_id.type_id == checked_class.id {
                    let arg_types: Type[] = [new ObjectType(checked_class.id)]
                    arg_types += method_type.arg_types
                    del method_type.arg_types
                    method_type.arg_types = arg_types
                    llvm_method_type = this.codegen_type(method_type, false)
                    if !checked_class.methods[prop_id.id].is_abstract {
                        llvm_method_val = this.declare_method("$(checked_class.name)_$prop_name", llvm_method_type)
                    }
                    if (get_class_prop_visibility(this.program, prop_id) == ACCESS_ATTR.PRIVATE){ 
                        struct_class.static_props_map[prop_id_key] = llvm_method_val
                        continue
                    }
                } else {
                    llvm_method_type = this.codegen_type(method_type, false)
                    prop_owner = get_class_from_prop_id(this.program, prop_id)
                    llvm_method_val = LLVMGetNamedFunction(this.module, "$(prop_owner.name)_$prop_name".to_cstring())
                    if llvm_method_val == null {
                        panic("This should not happen: could not find function $(prop_owner.name)_$prop_name (declare_class_props)")
                    }
                }
                struct_class.vt_methods_pos_map[prop_id_key] = prop_index
                if !prop_owner.methods[prop_id.id].is_abstract {
                    resize_value_array(vtable_values, prop_index)
                    vtable_values[prop_index] = llvm_method_val
                }
                resize_type_array(vtable_types, prop_index)
                vtable_types[prop_index] = LLVMPointerType(llvm_method_type)
            }
        }
        if vtable_types.length > 0 {
            let vtable_struct_ty = LLVMStructType(vtable_types.buffer, vtable_types.length, true)
            if !checked_class.is_abstract {
                struct_class.vtable = LLVMAddGlobal(this.module, vtable_struct_ty, "VTable$(checked_class.name)".to_cstring())
                let vtable_intializer = LLVMConstStruct(vtable_values.buffer, vtable_values.length, true)
                LLVMSetInitializer(struct_class.vtable, vtable_intializer)
            }
            struct_class.vtable_type = vtable_struct_ty
            prop_types << LLVMPointerType(vtable_struct_ty)
        }
        prop_types += field_types
        del field_types
        del vtable_types
        del vtable_values
    }
    private declare_class(this, checked_class: Class){
        let struct_class = new CGClassType()
        struct_class.llvm_type = LLVMStructCreateNamed(LLVMGetModuleContext(this.module), checked_class.name.to_cstring())
        this.add_class(checked_class.id, struct_class)
        let prop_types: LLVMTypeRef[] = []
        // Taking care of static methods.
        this.declare_static_props(struct_class, checked_class)
        // creating a vtable
        this.declare_class_props(struct_class, checked_class, prop_types)
        LLVMStructSetBody(struct_class.llvm_type, prop_types.buffer, prop_types.length, true)
        del prop_types
        // Now constructor
        if checked_class.construct != null {
            let constructor_type = get_class_prop_type(this.program, checked_class.construct) as FunctionType
            let arg_types: Type[] = [new ObjectType(checked_class.id)]
            arg_types += constructor_type.arg_types
            del constructor_type.arg_types
            constructor_type.arg_types = arg_types
            let constructor_llvm_method_type = this.codegen_type(constructor_type, false)
            struct_class.class_constructor = this.declare_method("$(checked_class.name)_constructor", constructor_llvm_method_type)
        } else {
            struct_class.class_constructor = null
        }
    }
    private declare_enum(this, checked_enum: Enum){
        let enum_type = new CGEnumType()
        if checked_enum.fields.length > 0 {
            enum_type.llvm_type = this.codegen_type(checked_enum.fields[0].initializer.value_type)
        } else {
            enum_type.llvm_type = LLVMIntType(ARCH_WORD_SIZE)
        }
        let elements: LLVMValueRef*(checked_enum.fields.length)
        let idx = 0
        for enum_field in checked_enum.fields {
            let prop_id = enum_field.id
            enum_type.field_map[create_prop_key(prop_id)] = this.codegen_expression(null, enum_field.initializer)
            let str = "$(checked_enum.name).$(enum_field.name)"
            let str_const = LLVMConstString(str.to_cstring(), str.length, false) //Issue: Mem lick!
            let str_global = LLVMAddGlobal(this.module, LLVMTypeOf(str_const), "")
            LLVMSetInitializer(str_global, str_const)
            elements[idx++] = str_global
        }
        let metanames_initializer = LLVMConstArray(LLVMPointerType(LLVMInt8Type()), elements, idx)
        let metanames = LLVMAddGlobal(this.module, LLVMTypeOf(metanames_initializer), "$(checked_enum.name)_names".to_cstring())
        LLVMSetInitializer(metanames, metanames_initializer)
        enum_type.metanames = metanames
        this.add_enum(checked_enum.id, enum_type)
    }
}