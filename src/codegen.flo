import "llvm"
$WORD_INT_TYPE = LLVMIntType($WORD_SIZE)
class GeneratedModule {
    llvm_mod: LLVMModuleRef
    errors: i8*
    constructor(llvm_mod: LLVMModuleRef){
        this.llvm_mod = llvm_mod
        this.errors = null
        LLVMVerifyModule(this.llvm_mod, LLVMVerifierFailureAction.LLVMAbortProcessAction, &this.errors)
        this.check_errors()
        LLVMLinkInMCJIT()
        LLVMInitializeAllTargets()
        LLVMInitializeAllTargetInfos()
        LLVMInitializeAllTargetMCs()
        LLVMInitializeAllTargetPrinters()
        LLVMInitializeAllTargetParsers()
    }
    check_errors(){
        if (this.errors[0] != 0) {
            println("error:", string_from_cstring(this.errors))
            LLVMDisposeMessage(this.errors)
            exit()
        }
    }
    run_passes(level: int){
        let fpm = LLVMCreateFunctionPassManagerForModule(this.llvm_mod)
        // let mpm = LLVMCreatePassManager()
        let pmb = LLVMPassManagerBuilderCreate()
        LLVMPassManagerBuilderSetOptLevel(pmb, level)
        LLVMPassManagerBuilderUseInlinerWithThreshold(pmb, 255)
        // LLVMPassManagerBuilderPopulateModulePassManager(pmb, mpm)
        let func = LLVMGetFirstFunction(this.llvm_mod)
        LLVMPassManagerBuilderPopulateFunctionPassManager(pmb, fpm)
        while func != null {
            LLVMRunFunctionPassManager(fpm, func)
            func = LLVMGetNextFunction(func)
        }
        // LLVMRunPassManager(mpm, this.llvm_mod)
        LLVMDisposePassManager(fpm)
        // LLVMDisposePassManager(mpm)
        LLVMPassManagerBuilderDispose(pmb)
    }
    exec(){
        let module_copy = this.copy_llvm_module()
        let engine: LLVMExecutionEngineRef = null
        if (LLVMCreateExecutionEngineForModule(&engine, module_copy, &this.errors) != 0) {
            println("failed to create execution engine")
            return
        }
        let main_fnc = LLVMGetFunctionAddress(engine, "main")  as () => int
        if main_fnc == null {
            println("Main function not found in module; can't execute")
            LLVMDisposeExecutionEngine(engine)
            return
        }
        println("Exited with code:", main_fnc())
        LLVMDisposeExecutionEngine(engine)
    }
    create_target_machine(triple_str: string): LLVMTargetMachineRef {
        let triple = triple_str == "" ? LLVMGetDefaultTargetTriple() : triple_str.to_cstring()
        let target = LLVMGetFirstTarget()
        if (LLVMGetTargetFromTriple(triple, &target, &this.errors) != 0) {
            println("failed to get target triple:", triple_str)
        }
        this.check_errors()
        let CPU: i8* = "generic"
        return LLVMCreateTargetMachine(target, triple, CPU, LLVMGetHostCPUFeatures(), LLVMCodeGenOptLevel.LLVMCodeGenLevelAggressive, LLVMRelocMode.LLVMRelocDefault, LLVMCodeModel.LLVMCodeModelDefault)
    }
    write_object(fn: string, target: string){
        let tm = this.create_target_machine(target)
        let module_copy = this.copy_llvm_module()
        LLVMSetDataLayout(module_copy, LLVMCreateTargetDataLayout(tm))
        LLVMSetTarget(module_copy, LLVMGetTargetMachineTriple(tm))
        if (LLVMTargetMachineEmitToFile(tm, module_copy, fn.to_cstring(), 1, &this.errors) != 0) {
            println("target machine failed to emit object code")
        }
        this.check_errors()
        LLVMDisposeTargetMachine(tm)
    }
    print(){
        LLVMDumpModule(this.llvm_mod)
    }
    copy_llvm_module(): LLVMModuleRef{
        return LLVMCloneModule(this.llvm_mod)
    }
    destroy(){
        let ctx = LLVMGetModuleContext(this.llvm_mod)
        LLVMDisposeModule(this.llvm_mod)
        LLVMContextDispose(ctx)
        LLVMShutdown()
    }
}
class IntrinsicResult {
    call: LLVMValueRef
    fnc_type: LLVMTypeRef
}
fnc get_intrinsic(mod: LLVMModuleRef, name: string, params: LLVMTypeRef[]): IntrinsicResult {
    let result: IntrinsicResult
    result.fnc_type = LLVMFunctionType(params[0], params.buffer, params.length, false)
    result.call = LLVMAddFunction(mod, name.to_cstring(), result.fnc_type)
    return result
}
fnc createLLVMBool(val: bool): LLVMValueRef{
    return LLVMConstInt(LLVMInt1Type(), val as int, false)
}
fnc createLLVMMachineSizeInt(i: int): LLVMValueRef {
    return LLVMConstInt($WORD_INT_TYPE, i, false)
}

$ZERO = createLLVMMachineSizeInt(0)
$ONE = createLLVMMachineSizeInt(1)
fnc is_terminated(block: Block): bool {
    return block.returns or block.continues or block.breaks
}
fnc create_var_key(var_id: VarId): string {
    return var_id.module_id + ";" + var_id.kind + ";" + var_id.id
}
fnc create_type_id_key(type_id: TypeId): string {
    return type_id.module_id + ";" type_id.kind + ";" + type_id.id
}
fnc create_method_key(prop_id: PropId): string {
    return create_type_id_key(prop_id.type_id) + ";" + prop_id.kind + ";" + prop_id.id
}
class CodeGen {
    modules: LLVMModuleRef[]
    module: LLVMModuleRef
    global_var_scope: Map<string, LLVMValueRef>
    module_intrinsic_scope: Map<string, IntrinsicResult>
    module_string_scope: Map<string, LLVMValueRef>
    module_types: Map<string, LLVMTypeRef>
    function: LLVMValueRef
    break_bb: LLVMBasicBlockRef
    continue_bb: LLVMBasicBlockRef
    program: Program
    in_static_ctx: bool
    module_ctx: LLVMContextRef
    codegenProgram(program: Program): GeneratedModule{
        this.program = program
        this.modules = []
        this.continue_bb = null
        this.break_bb = null
        let global_var_map: Map<string, LLVMValueRef>
        this.global_var_scope = global_var_map
        for let i = 0; i < program.modules.length; ++i {
            this.modules << this.codegen_module(program.modules[i])
        }
        this.link_modules()
        return new GeneratedModule(this.modules[0])
    }
    link_modules(){
        for let i = 1; i < this.modules.length; ++i {
            LLVMLinkModules2(this.modules[0], this.modules[i])
        }
    }
    codegen_module(module: Module): LLVMModuleRef {
        this.module_ctx = LLVMContextCreate()
        let module_string_scope: Map<string, LLVMValueRef>
        let module_intrinsic_scope: Map<string, IntrinsicResult>
        let module_types: Map<string, LLVMTypeRef>
        this.module_string_scope = module_string_scope
        this.module_intrinsic_scope = module_intrinsic_scope
        this.module_types = module_types
        this.module = LLVMModuleCreateWithNameInContext(module.name.to_cstring(), this.module_ctx)
        //let DBFloInfo = new DebugInfo(this.module, module.name)
        this.in_static_ctx = true
        for let i = 0; i < module.global_consts.length; ++i {
            this.codegen_const_declaration(null, module.global_consts[i])
        }
        for i = 0; i < module.global_vars.length; ++i {
            this.codegen_var_declaration(null, module.global_vars[i])
        }
        for i = 0; i < module.classes.length; ++i {
            this.declare_class(module.classes[i])
        }
        for i = 0; i < module.functions.length; ++i {
            this.declare_function(module.functions[i])
        }
        this.in_static_ctx = false
        for i = 0; i < module.classes.length; ++i {
            this.codegen_class(module.classes[i])
        }
        for i = 0; i < module.functions.length; ++i {
            this.codegen_function(module.functions[i])
        }
        return this.module
    }
    codegen_type(tt: Type, as_pointer = true): LLVMTypeRef {
        if tt.kind == TypeKind.VOID
            return LLVMVoidTypeInContext(this.module_ctx)
        if tt.kind == TypeKind.BOOL
            return LLVMInt1TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.I4
            return LLVMIntTypeInContext(this.module_ctx, 4)
        if tt.kind == TypeKind.I8
            return LLVMInt8TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.I16
            return LLVMInt16TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.I32
            return LLVMInt32TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.INT
            return LLVMIntTypeInContext(this.module_ctx, $WORD_SIZE)
        if tt.kind == TypeKind.I64
            return LLVMInt64TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.I128
            return LLVMInt128TypeInContext(this.module_ctx)
        if tt.kind == TypeKind.F16 
            return LLVMHalfTypeInContext(this.module_ctx)
        if tt.kind == TypeKind.F32
            return LLVMFloatTypeInContext(this.module_ctx)
        if tt.kind == TypeKind.F64 or tt.kind == TypeKind.FLOAT
            return LLVMDoubleTypeInContext(this.module_ctx)
        if tt.kind == TypeKind.PTR
            return LLVMPointerType(this.codegen_type((tt as PointerType).pointee_type))
        if tt.kind == TypeKind.ARRAY {
            let arr_ty = tt as ArrayType
            let element_type = this.codegen_type(arr_ty.element_type)
            return LLVMArrayType(element_type, arr_ty.length)
        }
        if tt.kind == TypeKind.FNC {
            let param_types: LLVMTypeRef[] = []
            let func_ty = tt as FunctionType
            for let i = 0; i < func_ty.arg_types.length; ++i {
                param_types << this.codegen_type(func_ty.arg_types[i])
            }
            let ret_type = this.codegen_type(func_ty.return_type)
            let llvm_fnty = LLVMFunctionType(ret_type, param_types.buffer, param_types.length, false)
            return as_pointer ? LLVMPointerType(llvm_fnty) : llvm_fnty
        }
        if tt.kind == TypeKind.OBJECT {
            let obj_type = this.module_types.get(create_type_id_key((tt as ObjectType).class_id))
            if obj_type != null {
                return as_pointer ? LLVMPointerType(obj_type) : obj_type
            }
        }
        // if tt.kind == TypeKind.ENUM
        // GENERIC_TEMPLATE
        // RESOLVED_GENERIC
        return LLVMInt32Type()
    }
    codegen_return_stmt(builder: LLVMBuilderRef, return_stmt: ReturnStatement){
        if return_stmt.return_value != null 
            LLVMBuildRet(builder, this.codegen_expression(builder, return_stmt.return_value))
        else
            LLVMBuildRetVoid(builder)
    }
    codegen_int(int_exp: IntExpression): LLVMValueRef {
        return LLVMConstInt(this.codegen_type(int_exp.value_type), int_exp.value, true)
    }
    codegen_float(float_exp: FloatExpression): LLVMValueRef {
        return LLVMConstReal(this.codegen_type(float_exp.value_type), float_exp.value)
    }
    codegen_bool(bool_exp: BooleanExpression): LLVMValueRef {
        let val = bool_exp.value
        return LLVMConstInt(LLVMInt1Type(), val, false)
    }
    
    codegen_string(builder: LLVMBuilderRef, string_exp: StringExpression): LLVMValueRef {
        let result = this.module_string_scope.get(string_exp.value)
        if result != null
            return result
        let str = LLVMBuildGlobalString(builder, string_exp.value.to_cstring(), "")
        this.module_string_scope.set(string_exp.value, str)
        return str
    }
    store_array_elements(builder: LLVMBuilderRef, ptr: LLVMValueRef, array_exp: ArrayExpression): LLVMValueRef {
        let args = [$ZERO, $ZERO]
        let next_args = [$ONE]
        let array_type = this.codegen_type(array_exp.value_type)
        let elem_ty = LLVMPointerType(this.codegen_type((array_exp.value_type as ArrayType).element_type))
        let addr = LLVMBuildInBoundsGEP2(builder, array_type, ptr, &args[0], 2, "")
        for let i = 0; i < array_exp.value.length; ++i {
            LLVMBuildStore(builder, this.codegen_expression(builder, array_exp.value[i]), addr)
            addr = LLVMBuildInBoundsGEP2(builder, elem_ty, addr, &next_args[0], 1, "")
        }
        return addr
    }
    codegen_array_exp(builder: LLVMBuilderRef, array_exp: ArrayExpression): LLVMValueRef {
        let elem_ty = this.codegen_type((array_exp.value_type as ArrayType).element_type)
        let elems: LLVMValueRef[] = []
        for let i = 0; i < array_exp.value.length; i++ {
            elems << this.codegen_expression(builder, array_exp.value[i])
        }
        return LLVMConstArray(elem_ty, elems.buffer, elems.length)
    }
    get_var_expr_mem(builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let ptr = this.global_var_scope.get(create_var_key(var_exp.value_id))
        if ptr == null {
            println("This should never happen! (get_expr_mem: var)")
            exit()
        }
        return ptr
    }
    get_index_expr_mem(builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let ind_ptr = this.get_expr_mem(builder, index_exp.expression)
        let index_ty = this.codegen_type(index_exp.index.value_type)
        let index = this.codegen_expression(builder, index_exp.index)
        let indices_0 = [$ZERO, $ZERO]
        let ty = this.codegen_type(index_exp.expression.value_type)
        if index_exp.expression.value_type.kind == TypeKind.ARRAY {
            ind_ptr = LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices_0[0], 2, "arrayidx")
        } else {
            ind_ptr = LLVMBuildLoad2(builder, ty, ind_ptr, "")
        }
        let indices_1 = [index]
        return LLVMBuildInBoundsGEP2(builder, ty, ind_ptr, &indices_1[0], 1, "ptridx")
    }
    get_member_expr_mem(builder: LLVMBuilderRef, member_expr: MemberExpression): LLVMValueRef {
        let ptr = this.codegen_expression(builder, member_expr.expression)
        let ty = this.codegen_type(member_expr.expression.value_type)
        let indices = [createLLVMMachineSizeInt(member_expr.member_id.id)]
        return LLVMBuildInBoundsGEP2(builder, ty, ptr, &indices[0], 1, "memberidx")
    }
    get_expr_mem(builder: LLVMBuilderRef, exp: Expression): LLVMValueRef {
        if exp.expr_kind == ExpressionKind.ACCESS
            return this.get_var_expr_mem(builder, exp as VarAccessExpression)
        if exp.expr_kind == ExpressionKind.INDEX
            return this.get_index_expr_mem(builder, exp as IndexExpression)
        if exp.expr_kind == ExpressionKind.MEMBER
            return this.get_member_expr_mem(builder, exp as MemberExpression)
        return this.codegen_expression(builder, exp)
    }
    store_expr_to_mem(builder: LLVMBuilderRef, ptr: LLVMValueRef, expr: Expression): LLVMValueRef {
        if expr.expr_kind == ExpressionKind.ARRAY and expr.is_constant == false
            return this.store_array_elements(builder, ptr, expr as ArrayExpression)
        let value = this.codegen_expression(builder, expr)
        LLVMBuildStore(builder, value, ptr)
        return value
    }
    codegen_assignment(builder: LLVMBuilderRef, assign_exp: BinaryExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, assign_exp.lhs)
        return this.store_expr_to_mem(builder, ptr, assign_exp.rhs)
    }
    codegen_pow_expr(builder: LLVMBuilderRef, ty: Type,  lhs: LLVMValueRef, rhs: LLVMValueRef): LLVMValueRef {
        let args = [lhs, rhs]
        let name = "llvm.pow."+dump_type(ty, true)
        let llvmty = this.codegen_type(ty)
        let cached_instrinsic = this.module_intrinsic_scope.get(name)
        let res: IntrinsicResult
        if cached_instrinsic != null {
            res = cached_instrinsic
        } else {
            res = get_intrinsic(this.module, name, [llvmty, llvmty])
            this.module_intrinsic_scope.set(name, res)
        }
        return LLVMBuildCall2(builder, res.fnc_type, res.call, &args[0], 2, "")
    }
    codegen_bin_exp(builder: LLVMBuilderRef, bin_exp: BinaryExpression): LLVMValueRef {   
        let op = bin_exp.op
        if bin_exp.lhs.value_type != bin_exp.rhs.value_type {
            if op == BinaryOp.EEQ
                return createLLVMBool(false)
            else if op == BinaryOp.NEQ
                return createLLVMBool(true)
        }
        if op == BinaryOp.ASSIGN
            return this.codegen_assignment(builder, bin_exp)
        let lhs = this.codegen_expression(builder, bin_exp.lhs)
        let rhs = this.codegen_expression(builder, bin_exp.rhs)
        let rty = bin_exp.rhs.value_type
        if is_numeric(rty) and op == BinaryOp.POW
            return this.codegen_pow_expr(builder, rty, lhs, rhs)
        let pred = 0
        let is_const_expr = LLVMIsConstant(lhs) and LLVMIsConstant(rhs)
        if is_int(rty) {
            if op == BinaryOp.ADD {
                return is_const_expr ? LLVMConstAdd(lhs, rhs) : LLVMBuildAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return is_const_expr ? LLVMConstSub(lhs, rhs) : LLVMBuildSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return is_const_expr ? LLVMConstMul(lhs, rhs) : LLVMBuildMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildSDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildSRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + 38
                return is_const_expr ? LLVMConstICmp(pred, lhs, rhs) : LLVMBuildICmp(builder, pred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = op - BinaryOp.EEQ + 32
                return is_const_expr ? LLVMConstICmp(pred, lhs, rhs) : LLVMBuildICmp(builder, pred, lhs, rhs, "")
            } else if op == BinaryOp.SL {
                return is_const_expr ? LLVMConstShl(lhs, rhs) : LLVMBuildShl(builder, lhs, rhs, "")
            } else if op == BinaryOp.SR {
                return is_const_expr ? LLVMConstAShr(lhs, rhs) : LLVMBuildAShr(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            } else if op == BinaryOp.AND {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.XOR {
                return is_const_expr ? LLVMConstXor(lhs, rhs) : LLVMBuildXor(builder, lhs, rhs, "")
            }
        } else if is_float(rty) {
            if op == BinaryOp.ADD { 
                return LLVMBuildFAdd(builder, lhs, rhs, "")
            } else if op == BinaryOp.SUB {
                return LLVMBuildFSub(builder, lhs, rhs, "")
            } else if op == BinaryOp.MUL {
                return LLVMBuildFMul(builder, lhs, rhs, "")
            } else if op == BinaryOp.DIV {
                return LLVMBuildFDiv(builder, lhs, rhs, "")
            } else if op == BinaryOp.MOD {
                return LLVMBuildFRem(builder, lhs, rhs, "")
            } else if op >= BinaryOp.GT and op <= BinaryOp.LTE {
                pred = op - BinaryOp.GT + LLVMRealPredicate.LLVMRealOGT
                return is_const_expr ? LLVMConstFCmp(pred, lhs, rhs) : LLVMBuildFCmp(builder, pred, lhs, rhs, "")
            } else if op >= BinaryOp.EEQ and op <= BinaryOp.NEQ {
                pred = op == BinaryOp.NEQ ? LLVMRealPredicate.LLVMRealONE : LLVMRealPredicate.LLVMRealOEQ
                return is_const_expr ? LLVMConstFCmp(pred, lhs, rhs) : LLVMBuildFCmp(builder, pred, lhs, rhs, "")
            }
        } else if is_bool(rty) {
            if op == BinaryOp.AND {
                return is_const_expr ? LLVMConstAnd(lhs, rhs) : LLVMBuildAnd(builder, lhs, rhs, "")
            } else if op == BinaryOp.OR {
                return is_const_expr ? LLVMConstOr(lhs, rhs) : LLVMBuildOr(builder, lhs, rhs, "")
            }
        } 
        // else if is_object(rty){
        //     if op == BinaryOp.EEQ {
        //         let i8_ptr_ty = LLVMPointerType(LLVMInt8TypeInContext(this.module_ctx))
        //         let lhs_addr = LLVMBuildBitCast(builder, lhs, i8_ptr_ty, "")
        //         let rhs_addr = LLVMBuildBitCast(builder, rhs, i8_ptr_ty, "")
        //     }
        // }
        return lhs
    }
    codegen_type_exp(builder: LLVMBuilderRef, type_exp: TypeExpression): LLVMValueRef {
        let exp = type_exp.expr
        let bty = type_exp.bound_type
        let val = this.codegen_expression(builder, exp)
        let ty = this.codegen_type(bty)
        let is_const = LLVMIsConstant(val)
        if type_exp.ty_op == TypeExprOp.AS {
            if is_bool(bty) {
                return is_const ? createLLVMBool(!LLVMIsNull(val)) : LLVMBuildIsNotNull(builder, val, "")
            }
            if is_int(exp.value_type) and is_float(bty) {
                return is_const ? LLVMConstSIToFP(val, ty) : LLVMBuildSIToFP(builder, val, ty, "")
            } else if is_float(exp.value_type) and is_int(bty) {
                return is_const ? LLVMConstFPToSI(val, ty) : LLVMBuildFPToSI(builder, val, ty, "")
            } else if is_int(exp.value_type) and is_int(bty){
                return is_const ? LLVMConstIntCast(val, ty, true) : LLVMBuildIntCast2(builder, val, ty, true, "")
            } else if is_float(exp.value_type) and is_float(bty){
                return is_const ? LLVMConstFPCast(val, ty) : LLVMBuildFPCast(builder, val, ty, "")
            }
            return is_const ? LLVMConstBitCast(val, ty) : LLVMBuildBitCast(builder, val, ty, "")
        } 
        return val
    }
    codegen_unary_exp(builder: LLVMBuilderRef, unary_exp: UnaryExpression): LLVMValueRef {
        let op = unary_exp.op
        let exp = unary_exp.expression
        let val = this.codegen_expression(builder, exp)
        if op == UnaryOp.NEG {
            if is_int(exp.value_type){
                return LLVMIsConstant(val) ? LLVMConstNeg(val) : LLVMBuildNeg(builder, val, "")
            } else if is_float(exp.value_type){
                return LLVMBuildFNeg(builder, val, "")
            }
        } 
        if op == UnaryOp.NOT {
            return LLVMIsConstant(val) ? LLVMConstNot(val) : LLVMBuildNot(builder, val, "")
        }
        if op >= UnaryOp.PREINCR and op <= UnaryOp.POSTDECR or op == UnaryOp.ADDROF {
            let ptr = this.get_expr_mem(builder, exp)
            if op == UnaryOp.ADDROF {
                return ptr
            }
            let alloc_ty = this.codegen_type(exp.value_type)
            let incr_value = op == UnaryOp.PREINCR or op == UnaryOp.POSTINCR ? 1 : -1
            let new_value: LLVMValueRef = null
            if is_pointer(exp.value_type) {
                let indices = [createLLVMMachineSizeInt(incr_value)]
                new_value = LLVMBuildInBoundsGEP2(builder, alloc_ty, val, &indices[0], 1, "incdec.ptr")
            } else if is_numeric(exp.value_type){
                let incr_amt = is_int(exp.value_type) ? LLVMConstInt(alloc_ty, incr_value, false) : LLVMConstReal(alloc_ty, incr_value * 1.0)
                new_value = LLVMBuildAdd(builder, val, incr_amt, "")
            }
            LLVMBuildStore(builder, new_value, ptr)
            return op >= UnaryOp.PREDECR ? val : new_value 
        }
        return val
    }
    codegen_var_access_exp(builder: LLVMBuilderRef, var_exp: VarAccessExpression): LLVMValueRef {
        let val = this.global_var_scope.get(create_var_key(var_exp.value_id))
        let ty = this.codegen_type(var_exp.value_type)
        if val == null {
            println("This should never happen; (codegen_var_access_exp)")
            exit()
        }
        if var_exp.value_id.kind == VarIdKind.FNC
            return val
        if this.in_static_ctx
            return LLVMGetInitializer(val)
        return LLVMBuildLoad2(builder, ty, val, "")
    }
    codegen_null(null_exp: NullExpression): LLVMValueRef{
        return LLVMConstNull(this.codegen_type(null_exp.value_type))
    }
    codegen_ternary_exp(builder: LLVMBuilderRef, ternary_exp: TernaryExpression): LLVMValueRef {
        let true_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "true_block")
        let false_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "false_block")
        let end = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "end")
        let cond = this.codegen_expression(builder, ternary_exp.cond)
        LLVMBuildCondBr(builder, cond, true_block, false_block)
        LLVMPositionBuilderAtEnd(builder, true_block)
        let is_true = this.codegen_expression(builder, ternary_exp.is_true)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, false_block)
        let is_false = this.codegen_expression(builder, ternary_exp.is_false)
        LLVMBuildBr(builder, end)
        LLVMPositionBuilderAtEnd(builder, end)
        let phi_node = LLVMBuildPhi(builder, this.codegen_type(ternary_exp.is_true.value_type), "ternary")
        let incomming_vals = [is_true, is_false]
        let blocks = [true_block, false_block]
        LLVMAddIncoming(phi_node, &incomming_vals[0], &blocks[0], 2)
        return phi_node
    }
    codegen_call_exp(builder: LLVMBuilderRef, call_exp: CallExpression): LLVMValueRef {
        let args: LLVMValueRef[] = []
        if call_exp.callee.expr_kind == ExpressionKind.MEMBER {
            let member_exp = call_exp.callee as MemberExpression
            if !get_method(this.program, member_exp.member_id).is_static { 
                args << this.codegen_expression(builder, member_exp.expression)
            }
        }
        let func = this.codegen_expression(builder, call_exp.callee)
        let func_ty = this.codegen_type(call_exp.callee.value_type, false)
        for let i = 0; i < call_exp.args.length; i++ {
            args << this.codegen_expression(builder, call_exp.args[i])
        }
        return LLVMBuildCall2(builder, func_ty, func, args.buffer, args.length, "")
    }
    codegen_index_exp(builder: LLVMBuilderRef, index_exp: IndexExpression): LLVMValueRef {
        let ptr = this.get_expr_mem(builder, index_exp)
        return LLVMBuildLoad2(builder, this.codegen_type(index_exp.value_type), ptr, "")
    }
    codegen_new_exp(builder: LLVMBuilderRef, new_expr: NewExpression): LLVMValueRef {
        return LLVMBuildMalloc(builder, this.codegen_type(new_expr.value_type, false), "")
    }
    codegen_member_exp(builder: LLVMBuilderRef, member_exp: MemberExpression): LLVMValueRef {
        if member_exp.member_id.kind == PropIdKind.FIELD {
            let ptr = this.get_expr_mem(builder, member_exp)
            return LLVMBuildLoad2(builder, this.codegen_type(member_exp.value_type), ptr, "")
        }
        return this.global_var_scope.get(create_method_key(member_exp.member_id))
    }
    codegen_expression(builder: LLVMBuilderRef, expression: Expression): LLVMValueRef {
        if expression.expr_kind == ExpressionKind.BOOL
            return this.codegen_bool(expression as BooleanExpression)
        if expression.expr_kind == ExpressionKind.INT
            return this.codegen_int(expression as IntExpression)
        if expression.expr_kind == ExpressionKind.FLOAT
            return this.codegen_float(expression as FloatExpression)
        if expression.expr_kind == ExpressionKind.NULL
            return this.codegen_null(expression as NullExpression)
        if expression.expr_kind == ExpressionKind.STRING
            return this.codegen_string(builder, expression as StringExpression)
        if expression.expr_kind == ExpressionKind.ACCESS 
              return this.codegen_var_access_exp(builder, expression as VarAccessExpression)
        if expression.expr_kind == ExpressionKind.BIN 
            return this.codegen_bin_exp(builder, expression as BinaryExpression)
        if expression.expr_kind == ExpressionKind.UNARY
             return this.codegen_unary_exp(builder, expression as UnaryExpression)
        if expression.expr_kind == ExpressionKind.CALL
            return this.codegen_call_exp(builder, expression as CallExpression)
        if expression.expr_kind == ExpressionKind.INDEX
            return this.codegen_index_exp(builder, expression as IndexExpression)
        if expression.expr_kind == ExpressionKind.MEMBER
            return this.codegen_member_exp(builder, expression as MemberExpression)
        if expression.expr_kind == ExpressionKind.NEW
            return this.codegen_new_exp(builder, expression as NewExpression)
        if expression.expr_kind == ExpressionKind.TERNARY
            return this.codegen_ternary_exp(builder, expression as TernaryExpression)
        if expression.expr_kind == ExpressionKind.TYPEBOUND
            return this.codegen_type_exp(builder, expression as TypeExpression)
        if expression.expr_kind == ExpressionKind.ARRAY
            return this.codegen_array_exp(builder, expression as ArrayExpression)
        return LLVMConstInt(LLVMInt32Type(), 0, false)
    }
    codegen_if_stmt(builder: LLVMBuilderRef, if_stmt: IfStatement){
        let condition = this.codegen_expression(builder, if_stmt.condition)
        let if_bb = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "if.entry")
        let else_bb = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "else")
        let merge_bb = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "ifend")
        LLVMBuildCondBr(builder, condition, if_bb, else_bb)
        LLVMPositionBuilderAtEnd(builder, if_bb)
        this.codegen_block(builder, if_stmt.block)
        if !is_terminated(if_stmt.block)
            LLVMBuildBr(builder, merge_bb)

        LLVMPositionBuilderAtEnd(builder, else_bb)
        let else_terminated = false
        if if_stmt.else_block != null {
            this.codegen_block(builder, if_stmt.else_block)
            else_terminated = is_terminated(if_stmt.else_block)
        }
        if !else_terminated
            LLVMBuildBr(builder, merge_bb)
    
        LLVMPositionBuilderAtEnd(builder, merge_bb)
    }
    codegen_for_stmt(builder: LLVMBuilderRef, for_stmt: ForStatement){
        let for_entry_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "for.entry")
        LLVMBuildBr(builder, for_entry_block)
        LLVMPositionBuilderAtEnd(builder, for_entry_block)
        if for_stmt.initialization != null {
            this.codegen_statement(builder, for_stmt.initialization)
        }
        let for_cond_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "for.cond")
        let for_body_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "for.body")
        let for_incr_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "for.incr")
        let for_end_block = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "for.end")
        let prev_break_bb = this.break_bb
        let prev_continue_bb = this.continue_bb
        this.break_bb = for_end_block
        this.continue_bb = for_incr_block
        LLVMBuildBr(builder, for_cond_block)
        LLVMPositionBuilderAtEnd(builder, for_cond_block)
        let condition = createLLVMBool(true)
        if for_stmt.condition != null {
            condition = this.codegen_expression(builder, for_stmt.condition)
        }
        LLVMBuildCondBr(builder, condition, for_body_block, for_end_block)
        LLVMPositionBuilderAtEnd(builder, for_body_block)
        this.codegen_block(builder, for_stmt.block)
        if !is_terminated(for_stmt.block)
            LLVMBuildBr(builder, for_incr_block)
        LLVMPositionBuilderAtEnd(builder, for_incr_block)
        if for_stmt.incr_decr != null
            this.codegen_expression(builder, for_stmt.incr_decr)
        LLVMBuildBr(builder, for_cond_block)
        this.break_bb = prev_break_bb
        this.continue_bb = prev_continue_bb
        LLVMPositionBuilderAtEnd(builder, for_end_block)
    }
    codegen_while_stmt(builder: LLVMBuilderRef, while_stmt: WhileStatement){
        let while_bb = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "while.entry")
        let while_end_bb = LLVMAppendBasicBlockInContext(this.module_ctx, this.function, "while.end")
        let prev_break_bb = this.break_bb
        let prev_continue_bb = this.continue_bb
        this.break_bb = while_end_bb
        this.continue_bb = while_bb
        let condition = this.codegen_expression(builder, while_stmt.condition)
        LLVMBuildCondBr(builder, condition, while_bb, while_end_bb)
        LLVMPositionBuilderAtEnd(builder, while_bb)
        this.codegen_block(builder, while_stmt.block)
        if !is_terminated(while_stmt.block) {
            condition = this.codegen_expression(builder, while_stmt.condition)
            LLVMBuildCondBr(builder, condition, while_bb, while_end_bb)
        }
        LLVMPositionBuilderAtEnd(builder, while_end_bb)
        this.break_bb = prev_break_bb
        this.continue_bb = prev_continue_bb
    }
    build_constructor_call(builder: LLVMBuilderRef, obj_type: ObjectType, self: LLVMValueRef, params: Expression[]){
        let checked_class = get_class(this.program, obj_type.class_id)
        let constructor_id = checked_class.method_map.get("constructor")
        let passed_params: LLVMValueRef[] = [self]
        for let i = 0; i < params.length; i++ {
            passed_params << this.codegen_expression(builder, params[i])
        }
        if constructor_id != null {
            let construct_type = this.codegen_type(checked_class.methods[constructor_id.id].method_type, false)
            let constructor = this.global_var_scope.get(create_method_key(constructor_id))
            LLVMBuildCall2(builder, construct_type, constructor, passed_params.buffer, passed_params.length, "")
        }
    }
    codegen_var_declaration(builder: LLVMBuilderRef, var_decl: VarDeclaration){
        let var_id = var_decl.var_id
        let var = get_var(this.program, var_id)
        let expression = var.value
        let expression_val_type = var.value_type
        let ty = this.codegen_type(expression_val_type)
        let name = var_decl.name.to_cstring()
        let ptr: LLVMValueRef = null
        if var_decl.is_static {
            let value = this.codegen_expression(builder, expression)
            ptr = LLVMAddGlobal(this.module, ty, name)
            LLVMSetInitializer(ptr, value)
        } else {
            ptr = LLVMBuildAlloca(builder, ty, name)
            if expression != null {
                this.store_expr_to_mem(builder, ptr, expression)
            } else if expression_val_type.kind == TypeKind.OBJECT {
                ty = this.codegen_type(expression_val_type, false)
                let struct_ref = LLVMBuildAlloca(builder, ty, "")
                this.build_constructor_call(builder, expression_val_type as ObjectType, struct_ref, [])
                LLVMBuildStore(builder, struct_ref, ptr)
            }
        }
        this.global_var_scope.set(create_var_key(var_id), ptr)
    }
    codegen_const_declaration(builder: LLVMBuilderRef, const_decl: ConstDeclaration){
        let const_id = const_decl.const_id
        let expression = get_const(this.program, const_id).value
        let ty = this.codegen_type(expression.value_type)
        let name = const_decl.name.to_cstring()
        let ptr: LLVMValueRef = null
        if const_decl.is_static {
            let value = this.codegen_expression(builder, expression)
            ptr = LLVMAddGlobal(this.module, ty, name)
            LLVMSetInitializer(ptr, value)
            LLVMSetGlobalConstant(ptr, true)
        } else {
            ptr = LLVMBuildAlloca(builder, ty, name)
            this.store_expr_to_mem(builder, ptr, expression)
        }
        this.global_var_scope.set(create_var_key(const_id), ptr)
    }
    codegen_statement(builder: LLVMBuilderRef, statement: Statement){
        if statement.kind == StatementKind.IF
            this.codegen_if_stmt(builder, statement as IfStatement)
        if statement.kind == StatementKind.FOR
            this.codegen_for_stmt(builder, statement as ForStatement)
        if statement.kind == StatementKind.WHILE
            this.codegen_while_stmt(builder, statement as WhileStatement)
        if statement.kind == StatementKind.CONTINUE
            LLVMBuildBr(builder, this.continue_bb)
        if statement.kind == StatementKind.BREAK
            LLVMBuildBr(builder, this.break_bb)
        if statement.kind == StatementKind.VAR
            this.codegen_var_declaration(builder, statement as VarDeclaration)
        if statement.kind == StatementKind.CONST
            this.codegen_const_declaration(builder, statement as ConstDeclaration)
        if statement.kind == StatementKind.RETURN
            this.codegen_return_stmt(builder, statement as ReturnStatement)
        if statement.kind == StatementKind.EXPRESSION
            this.codegen_expression(builder, statement as Expression)
    }
    codegen_block(builder: LLVMBuilderRef, block: Block){
        for let i = 0; i < block.statements.length; ++i {
            this.codegen_statement(builder, block.statements[i])
        }
    }
    codegen_function(func: Function){
        let llvm_fnc = this.global_var_scope.get(create_var_key(func.id))
        if func.is_external { 
            LLVMSetLinkage(llvm_fnc, LLVMLinkage.LLVMExternalLinkage)
            return
        }
        if llvm_fnc == null {
            println("This should never happen; (codegen_function)")
            exit()
        }
        let entry_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.module_ctx, llvm_fnc, "")
        let func_builder: LLVMBuilderRef = LLVMCreateBuilderInContext(this.module_ctx)
        LLVMPositionBuilderAtEnd(func_builder, entry_block)
        for let i = 0; i < func.args.length; i++ {
            let arg = func.args[i]
            let param = LLVMGetParam(llvm_fnc, i)
            let alloc = LLVMBuildAlloca(func_builder, this.codegen_type(arg.value_type), arg.name.to_cstring())
            LLVMBuildStore(func_builder, param, alloc)
            this.global_var_scope.set(create_var_key(arg.id), alloc)
        }
        this.function = llvm_fnc
        this.codegen_block(func_builder, func.block)
        LLVMDisposeBuilder(func_builder)
    }
    codegen_class(checked_class: Class){
        for let i = 0; i < checked_class.methods.length; i++ {
            let method = checked_class.methods[i]
            let llvm_fnc = this.global_var_scope.get(create_method_key(method.id))
            if method.is_abstract {
                continue
            }
            let entry_block: LLVMBasicBlockRef = LLVMAppendBasicBlockInContext(this.module_ctx, llvm_fnc, "")
            let func_builder: LLVMBuilderRef = LLVMCreateBuilderInContext(this.module_ctx)
            LLVMPositionBuilderAtEnd(func_builder, entry_block)
            let offset = 0
            if !method.is_static {
                let object_type = LLVMPointerType(this.module_types.get(create_type_id_key(checked_class.id)))
                let this_param = LLVMGetParam(llvm_fnc, 0)
                let this_alloc = LLVMBuildAlloca(func_builder, object_type, "this")
                let this_id = get_scope(this.program, method.scope).vars.get("this")
                LLVMBuildStore(func_builder, this_param, this_alloc)
                this.global_var_scope.set(create_var_key(this_id), this_alloc)
                offset = 1
            }
            for let j = 0; j < method.args.length; j++ {
                let arg = method.args[j]
                let param = LLVMGetParam(llvm_fnc, j + offset)
                let alloc = LLVMBuildAlloca(func_builder, this.codegen_type(arg.value_type), arg.name.to_cstring())
                LLVMBuildStore(func_builder, param, alloc)
                this.global_var_scope.set(create_var_key(arg.id), alloc)
            }
            this.function = llvm_fnc
            this.codegen_block(func_builder, method.block)
            LLVMDisposeBuilder(func_builder)
        }
    }
    declare_function(func: Function) {
        let llvm_fnc = LLVMAddFunction(this.module, func.name.to_cstring(), this.codegen_type(func.fnc_type, false))
        this.global_var_scope.set(create_var_key(func.id), llvm_fnc)
    }
    declare_class(checked_class: Class) {
        let struct_ty = LLVMStructCreateNamed(this.module_ctx, checked_class.name.to_cstring())
        let fields: LLVMTypeRef[] = []
        for let i = 0; i < checked_class.fields.length; i++ {
            fields << this.codegen_type(checked_class.fields[i].field_type)
        }
        this.module_types.set(create_type_id_key(checked_class.id), struct_ty)
        for i = 0; i < checked_class.methods.length; i++ {
            let method = checked_class.methods[i]
            if !method.is_static {
                let args: Type [] = []
                args << (new ObjectType(checked_class.id) as Type)
                for let j = 0; j < method.method_type.arg_types.length; j++ {
                    args << method.method_type.arg_types[j]
                }
                method.method_type.arg_types = args
            }
            let llvm_fnc = LLVMAddFunction(this.module, (checked_class.name+method.name).to_cstring(), this.codegen_type(method.method_type, false))
            this.global_var_scope.set(create_method_key(method.id), llvm_fnc)
        }
        LLVMStructSetBody(struct_ty, fields.buffer, fields.length, true)
    }
}